const t='{"documentCount":251,"nextId":251,"documentIds":{"0":"/algorithm/classic.html#经典算法真题","1":"/algorithm/classic.html#数组扁平化","2":"/algorithm/classic.html#数组去重","3":"/algorithm/classic.html#求数组的最大值和最小值","4":"/algorithm/classic.html#求两个数的最大公约数","5":"/algorithm/classic.html#求两个数的最小公倍数","6":"/algorithm/classic.html#实现-indexof-方法","7":"/algorithm/classic.html#判断一个字符串是否为回文字符串","8":"/algorithm/classic.html#累加函数","9":"/algorithm/classic.html#查找一篇英文文章中出现频率最高的单词","10":"/algorithm/classic.html#斐波那契数列","11":"/algorithm/classic.html#跳台阶","12":"/algorithm/classic.html#最小的-k-个数","13":"/algorithm/idea.html#算法设计思想","14":"/algorithm/idea.html#分而治之","15":"/algorithm/idea.html#基本步骤","16":"/algorithm/idea.html#使用场景","17":"/algorithm/idea.html#分而治之的应用","18":"/algorithm/idea.html#多数元素","19":"/algorithm/idea.html#排序数组","20":"/algorithm/idea.html#最大子数组和","21":"/algorithm/idea.html#数组中的第-k-个最大元素","22":"/algorithm/idea.html#动态规划","23":"/algorithm/idea.html#基本步骤-1","24":"/algorithm/idea.html#使用场景-1","25":"/algorithm/idea.html#动态规划的应用","26":"/algorithm/idea.html#爬楼梯","27":"/algorithm/idea.html#最长递增子序列","28":"/algorithm/idea.html#打家劫舍","29":"/algorithm/idea.html#零钱兑换","30":"/algorithm/idea.html#贪心算法","31":"/algorithm/idea.html#基本步骤-2","32":"/algorithm/idea.html#使用场景-2","33":"/algorithm/idea.html#贪心算法的应用","34":"/algorithm/idea.html#分发饼干","35":"/algorithm/idea.html#柠檬水找零","36":"/algorithm/idea.html#跳跃游戏","37":"/algorithm/idea.html#无重叠区间","38":"/algorithm/idea.html#分发糖果","39":"/algorithm/idea.html#回溯算法","40":"/algorithm/idea.html#基本步骤-3","41":"/algorithm/idea.html#使用场景-3","42":"/algorithm/idea.html#回溯算法的应用","43":"/algorithm/idea.html#全排列","44":"/algorithm/idea.html#子集","45":"/algorithm/idea.html#单词拆分-ii","46":"/algorithm/search.html#搜索算法","47":"/algorithm/search.html#顺序搜索","48":"/algorithm/search.html#二分搜索","49":"/algorithm/sort.html#排序算法","50":"/algorithm/sort.html#冒泡排序","51":"/algorithm/sort.html#选择排序","52":"/algorithm/sort.html#插入排序","53":"/algorithm/sort.html#希尔排序","54":"/algorithm/sort.html#归并排序","55":"/algorithm/sort.html#快速排序","56":"/algorithm/sort.html#堆排序","57":"/algorithm/sort.html#基数排序","58":"/algorithm/sort.html#计数排序","59":"/data-structure/Array.html#数组","60":"/data-structure/Array.html#创建和初始化数组","61":"/data-structure/Array.html#数组常见操作","62":"/data-structure/Array.html#添加元素","63":"/data-structure/Array.html#删除元素","64":"/data-structure/Array.html#修改元素","65":"/data-structure/BinarySearchTree.html#二叉搜索树","66":"/data-structure/BinarySearchTree.html#二叉搜索树应用举例","67":"/data-structure/BinarySearchTree.html#二叉搜索树的封装","68":"/data-structure/BinarySearchTree.html#二叉搜索树的常见操作","69":"/data-structure/BinarySearchTree.html#插入数据","70":"/data-structure/BinarySearchTree.html#遍历数据","71":"/data-structure/BinarySearchTree.html#先序遍历","72":"/data-structure/BinarySearchTree.html#中序遍历","73":"/data-structure/BinarySearchTree.html#后序遍历","74":"/data-structure/BinarySearchTree.html#总结","75":"/data-structure/BinarySearchTree.html#查找数据","76":"/data-structure/BinarySearchTree.html#查找最大值或最小值","77":"/data-structure/BinarySearchTree.html#查找特定值","78":"/data-structure/BinarySearchTree.html#删除数据","79":"/data-structure/BinarySearchTree.html#删除的是叶子节点","80":"/data-structure/BinarySearchTree.html#删除的是只有一个子节点的节点","81":"/data-structure/BinarySearchTree.html#删除的是有两个子节点的节点","82":"/data-structure/BinarySearchTree.html#前驱-后继","83":"/data-structure/BinarySearchTree.html#完整实现","84":"/data-structure/BinarySearchTree.html#平衡树","85":"/data-structure/BinaryTree.html#二叉树","86":"/data-structure/BinaryTree.html#二叉树的概念","87":"/data-structure/BinaryTree.html#二叉树的组成","88":"/data-structure/BinaryTree.html#二叉树的五种形态","89":"/data-structure/BinaryTree.html#二叉树的特性","90":"/data-structure/BinaryTree.html#特殊的二叉树","91":"/data-structure/BinaryTree.html#完美二叉树","92":"/data-structure/BinaryTree.html#完全二叉树","93":"/data-structure/BinaryTree.html#二叉树的数据存储","94":"/data-structure/BinaryTree.html#使用数组","95":"/data-structure/BinaryTree.html#使用链表","96":"/data-structure/DoubleLinkedList.html#双向链表","97":"/data-structure/DoubleLinkedList.html#单向链表和双向链表","98":"/data-structure/DoubleLinkedList.html#单向链表","99":"/data-structure/DoubleLinkedList.html#双向链表-1","100":"/data-structure/DoubleLinkedList.html#双向链表结构","101":"/data-structure/DoubleLinkedList.html#双向链表常见的操作","102":"/data-structure/DoubleLinkedList.html#双向链表的封装","103":"/data-structure/DoubleLinkedList.html#创建双向链表类-doublylinkedlist","104":"/data-structure/DoubleLinkedList.html#append-element","105":"/data-structure/DoubleLinkedList.html#insert-position-element","106":"/data-structure/DoubleLinkedList.html#insert-position-element-1","107":"/data-structure/DoubleLinkedList.html#removeat-position","108":"/data-structure/DoubleLinkedList.html#update-position-data","109":"/data-structure/DoubleLinkedList.html#forwardtostring","110":"/data-structure/DoubleLinkedList.html#backwardstring","111":"/data-structure/DoubleLinkedList.html#其他方法的实现","112":"/data-structure/DoubleLinkedList.html#完整实现","113":"/data-structure/DoubleLinkedList.html#代码测试","114":"/data-structure/Graph.html#图","115":"/data-structure/Graph.html#图的概念","116":"/data-structure/Graph.html#什么是图","117":"/data-structure/Graph.html#图的术语","118":"/data-structure/Graph.html#现实建模","119":"/data-structure/Graph.html#图的表示","120":"/data-structure/Graph.html#顶点表示","121":"/data-structure/Graph.html#邻接矩阵","122":"/data-structure/Graph.html#邻接表","123":"/data-structure/Graph.html#图的封装","124":"/data-structure/Graph.html#创建图类","125":"/data-structure/Graph.html#方法","126":"/data-structure/Graph.html#添加顶点","127":"/data-structure/Graph.html#添加边","128":"/data-structure/Graph.html#tostring-方法","129":"/data-structure/Graph.html#测试代码","130":"/data-structure/Graph.html#图的遍历","131":"/data-structure/Graph.html#遍历的方式","132":"/data-structure/Graph.html#广度优先搜索-bfs","133":"/data-structure/Graph.html#深度优先搜索-dfs","134":"/data-structure/HashTable.html#哈希表","135":"/data-structure/HashTable.html#认识哈希表","136":"/data-structure/HashTable.html#认识哈希化","137":"/data-structure/HashTable.html#哈希表的一些概念","138":"/data-structure/HashTable.html#地址的冲突","139":"/data-structure/HashTable.html#链地址法-拉链法","140":"/data-structure/HashTable.html#开放地址法","141":"/data-structure/HashTable.html#线性探测","142":"/data-structure/HashTable.html#二次探测","143":"/data-structure/HashTable.html#再哈希法","144":"/data-structure/HashTable.html#装填因子","145":"/data-structure/HashTable.html#不同探测方式性能的比较","146":"/data-structure/HashTable.html#哈希函数","147":"/data-structure/HashTable.html#快速计算","148":"/data-structure/HashTable.html#均匀分布","149":"/data-structure/HashTable.html#封装哈希表","150":"/data-structure/HashTable.html#哈希表常见操作","151":"/data-structure/HashTable.html#哈希函数的简单实现","152":"/data-structure/HashTable.html#哈希表的实现","153":"/data-structure/HashTable.html#创建哈希表类","154":"/data-structure/HashTable.html#put-key-value","155":"/data-structure/HashTable.html#get-key","156":"/data-structure/HashTable.html#remove-key","157":"/data-structure/HashTable.html#isempty","158":"/data-structure/HashTable.html#size","159":"/data-structure/HashTable.html#哈希表的扩容与压缩","160":"/data-structure/HashTable.html#resize-的实现","161":"/data-structure/HashTable.html#选择质数作为哈希表容量","162":"/data-structure/HashTable.html#质数判断","163":"/data-structure/HashTable.html#实现扩容或压缩后的哈希表容量为质数","164":"/data-structure/HashTable.html#哈希表完整实现","165":"/data-structure/LinkedList.html#单向链表","166":"/data-structure/LinkedList.html#链表和数组","167":"/data-structure/LinkedList.html#数组","168":"/data-structure/LinkedList.html#链表","169":"/data-structure/LinkedList.html#单向链表-1","170":"/data-structure/LinkedList.html#链表中的常见操作","171":"/data-structure/LinkedList.html#单向链表的封装","172":"/data-structure/LinkedList.html#创建单向链表类","173":"/data-structure/LinkedList.html#实现-append-方法","174":"/data-structure/LinkedList.html#实现-tostring-方法","175":"/data-structure/LinkedList.html#实现-insert-方法","176":"/data-structure/LinkedList.html#实现-getdata-方法","177":"/data-structure/LinkedList.html#实现-indexof-方法","178":"/data-structure/LinkedList.html#实现-update-方法","179":"/data-structure/LinkedList.html#实现-removeat-方法","180":"/data-structure/LinkedList.html#实现-remove-方法","181":"/data-structure/LinkedList.html#实现-isempty-方法","182":"/data-structure/LinkedList.html#实现-size-方法","183":"/data-structure/LinkedList.html#完整实现","184":"/data-structure/Map.html#字典","185":"/data-structure/Map.html#字典特点","186":"/data-structure/Map.html#字典和映射的关系","187":"/data-structure/Map.html#字典常见的操作","188":"/data-structure/Map.html#字典封装","189":"/data-structure/Map.html#代码实现","190":"/data-structure/Map.html#代码测试","191":"/data-structure/PriorityQueue.html#优先队列","192":"/data-structure/PriorityQueue.html#场景","193":"/data-structure/PriorityQueue.html#优先队列-1","194":"/data-structure/PriorityQueue.html#优先队列的实现","195":"/data-structure/PriorityQueue.html#代码实现","196":"/data-structure/PriorityQueue.html#测试代码","197":"/data-structure/PriorityQueue.html#数组、栈和队列图解","198":"/data-structure/Queue.html#队列","199":"/data-structure/Queue.html#认识队列","200":"/data-structure/Queue.html#队列图解","201":"/data-structure/Queue.html#队列在程序中的应用","202":"/data-structure/Queue.html#队列的实现","203":"/data-structure/Queue.html#队列常见的操作","204":"/data-structure/Queue.html#代码实现","205":"/data-structure/Queue.html#测试代码","206":"/data-structure/Queue.html#队列的应用","207":"/data-structure/Queue.html#代码实现-1","208":"/data-structure/Queue.html#测试代码-1","209":"/data-structure/Set.html#集合","210":"/data-structure/Set.html#集合特点","211":"/data-structure/Set.html#封装集合","212":"/data-structure/Set.html#集合常见的操作","213":"/data-structure/Set.html#代码实现","214":"/data-structure/Set.html#代码测试","215":"/data-structure/Set.html#集合间的操作","216":"/data-structure/Set.html#并集的实现","217":"/data-structure/Set.html#交集的实现","218":"/data-structure/Set.html#差集的实现","219":"/data-structure/Set.html#子集的实现","220":"/data-structure/Set.html#集合的完整实现","221":"/data-structure/Stack.html#栈","222":"/data-structure/Stack.html#什么是栈","223":"/data-structure/Stack.html#程序中的栈结构","224":"/data-structure/Stack.html#练习","225":"/data-structure/Stack.html#栈结构实现","226":"/data-structure/Stack.html#栈常见的操作","227":"/data-structure/Stack.html#javascript-代码实现栈结构","228":"/data-structure/Stack.html#测试封装的栈结构","229":"/data-structure/Stack.html#栈结构的简单应用","230":"/data-structure/Stack.html#代码实现","231":"/data-structure/Stack.html#测试","232":"/data-structure/Tree.html#树","233":"/data-structure/Tree.html#真实的树","234":"/data-structure/Tree.html#树的特点","235":"/data-structure/Tree.html#树结构的优势","236":"/data-structure/Tree.html#树的常用术语","237":"/data-structure/Tree.html#树结构的表示方式","238":"/data-structure/Tree.html#最普通的表示方法","239":"/data-structure/Tree.html#儿子-兄弟表示法","240":"/data-structure/Tree.html#儿子-兄弟表示法旋转","241":"/foreword.html#前言","242":"/foreword.html#什么是数据结构","243":"/foreword.html#数据结构的定义","244":"/foreword.html#数据结构在生活中应用","245":"/foreword.html#常见的数据结构","246":"/foreword.html#什么是算法","247":"/foreword.html#算法-algorithm-的定义","248":"/foreword.html#算法通俗理解","249":"/foreword.html#算法案例","250":"/foreword.html#学习数据结构与算法的好处"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,53],"2":[1,1,49],"3":[1,1,26],"4":[1,1,40],"5":[1,1,55],"6":[3,1,4],"7":[1,1,40],"8":[1,1,51],"9":[1,1,52],"10":[1,1,70],"11":[1,1,68],"12":[3,1,124],"13":[1,1,1],"14":[1,1,9],"15":[1,2,12],"16":[1,2,11],"17":[1,2,1],"18":[1,3,94],"19":[1,3,82],"20":[1,3,112],"21":[3,3,103],"22":[1,1,8],"23":[1,2,20],"24":[1,2,13],"25":[1,2,1],"26":[1,3,80],"27":[1,3,95],"28":[1,3,107],"29":[1,3,99],"30":[1,1,5],"31":[1,2,19],"32":[1,2,19],"33":[1,2,1],"34":[1,3,114],"35":[1,3,126],"36":[1,3,107],"37":[1,3,112],"38":[1,3,103],"39":[1,1,7],"40":[1,2,26],"41":[1,2,17],"42":[1,2,1],"43":[1,3,97],"44":[1,3,99],"45":[2,3,149],"46":[1,1,7],"47":[1,1,41],"48":[1,1,51],"49":[1,1,11],"50":[1,1,146],"51":[1,1,140],"52":[1,1,121],"53":[1,1,126],"54":[1,1,117],"55":[1,1,107],"56":[1,1,110],"57":[1,1,138],"58":[1,1,97],"59":[1,1,8],"60":[1,1,16],"61":[1,1,1],"62":[1,2,28],"63":[1,2,25],"64":[1,2,30],"65":[1,1,35],"66":[1,1,42],"67":[1,1,26],"68":[1,1,24],"69":[1,2,65],"70":[1,2,11],"71":[1,3,42],"72":[1,3,52],"73":[1,3,52],"74":[1,3,10],"75":[1,2,1],"76":[1,3,27],"77":[1,3,44],"78":[1,2,52],"79":[1,3,38],"80":[1,3,50],"81":[1,3,44],"82":[3,4,68],"83":[1,3,60],"84":[1,1,59],"85":[1,1,1],"86":[1,1,3],"87":[1,1,9],"88":[1,1,15],"89":[1,1,41],"90":[1,1,1],"91":[1,2,13],"92":[1,2,16],"93":[1,1,2],"94":[1,2,38],"95":[1,2,6],"96":[1,1,1],"97":[1,1,1],"98":[1,2,10],"99":[1,2,17],"100":[1,1,18],"101":[1,1,45],"102":[1,1,1],"103":[2,2,27],"104":[3,2,29],"105":[4,2,59],"106":[4,2,59],"107":[3,2,42],"108":[4,2,21],"109":[2,2,21],"110":[2,2,21],"111":[1,2,2],"112":[1,2,104],"113":[1,2,31],"114":[1,1,1],"115":[1,1,5],"116":[2,2,41],"117":[1,2,84],"118":[1,2,14],"119":[1,1,6],"120":[1,2,27],"121":[1,2,42],"122":[1,2,36],"123":[1,1,1],"124":[1,2,25],"125":[1,2,1],"126":[1,3,22],"127":[1,3,25],"128":[2,3,28],"129":[1,2,29],"130":[1,1,6],"131":[1,2,59],"132":[3,2,99],"133":[3,2,79],"134":[1,1,1],"135":[1,1,68],"136":[1,2,79],"137":[1,2,11],"138":[1,2,10],"139":[3,3,21],"140":[1,3,7],"141":[1,4,82],"142":[1,4,37],"143":[1,4,48],"144":[1,3,12],"145":[1,3,28],"146":[1,2,7],"147":[1,3,28],"148":[1,3,34],"149":[1,1,1],"150":[1,2,21],"151":[1,2,47],"152":[1,2,1],"153":[1,3,20],"154":[4,3,88],"155":[3,3,50],"156":[3,3,66],"157":[2,3,8],"158":[2,3,6],"159":[1,1,49],"160":[2,2,72],"161":[1,2,1],"162":[1,3,43],"163":[1,3,67],"164":[1,1,111],"165":[1,1,1],"166":[1,1,4],"167":[1,2,21],"168":[1,2,28],"169":[1,1,16],"170":[1,1,41],"171":[1,1,1],"172":[1,2,24],"173":[3,2,66],"174":[3,2,32],"175":[3,2,79],"176":[3,2,42],"177":[3,2,34],"178":[3,2,49],"179":[3,2,56],"180":[3,2,24],"181":[3,2,20],"182":[3,2,18],"183":[1,2,134],"184":[1,1,1],"185":[1,1,26],"186":[1,1,16],"187":[1,1,26],"188":[1,1,1],"189":[1,2,39],"190":[1,2,31],"191":[1,1,1],"192":[1,1,11],"193":[1,1,6],"194":[1,1,1],"195":[1,2,76],"196":[1,2,35],"197":[2,1,1],"198":[1,1,1],"199":[1,1,27],"200":[1,2,1],"201":[1,2,10],"202":[1,1,5],"203":[1,2,36],"204":[1,2,36],"205":[1,2,24],"206":[1,1,10],"207":[1,2,63],"208":[1,2,19],"209":[1,1,9],"210":[1,1,10],"211":[1,1,8],"212":[1,2,24],"213":[1,2,38],"214":[1,2,25],"215":[1,1,10],"216":[1,2,29],"217":[1,2,26],"218":[1,2,27],"219":[1,2,23],"220":[1,1,72],"221":[1,1,7],"222":[1,1,28],"223":[1,1,35],"224":[1,1,39],"225":[1,1,1],"226":[1,2,23],"227":[2,2,37],"228":[1,2,19],"229":[1,1,2],"230":[1,2,37],"231":[1,2,12],"232":[1,1,1],"233":[1,1,1],"234":[1,1,11],"235":[1,1,68],"236":[1,1,65],"237":[1,1,1],"238":[1,2,25],"239":[2,2,21],"240":[2,2,14],"241":[1,1,1],"242":[1,1,1],"243":[1,2,24],"244":[1,2,44],"245":[1,2,20],"246":[1,1,1],"247":[3,2,7],"248":[1,2,6],"249":[1,2,43],"250":[1,1,46]},"averageFieldLength":[1.2749003984063745,1.800796812749004,36.442231075697215],"storedFields":{"0":{"title":"经典算法真题","titles":[]},"1":{"title":"数组扁平化","titles":["经典算法真题"]},"2":{"title":"数组去重","titles":["经典算法真题"]},"3":{"title":"求数组的最大值和最小值","titles":["经典算法真题"]},"4":{"title":"求两个数的最大公约数","titles":["经典算法真题"]},"5":{"title":"求两个数的最小公倍数","titles":["经典算法真题"]},"6":{"title":"实现 IndexOf 方法","titles":["经典算法真题"]},"7":{"title":"判断一个字符串是否为回文字符串","titles":["经典算法真题"]},"8":{"title":"累加函数","titles":["经典算法真题"]},"9":{"title":"查找一篇英文文章中出现频率最高的单词","titles":["经典算法真题"]},"10":{"title":"斐波那契数列","titles":["经典算法真题"]},"11":{"title":"跳台阶","titles":["经典算法真题"]},"12":{"title":"最小的 K 个数","titles":["经典算法真题"]},"13":{"title":"算法设计思想","titles":[]},"14":{"title":"分而治之","titles":["算法设计思想"]},"15":{"title":"基本步骤","titles":["算法设计思想","分而治之"]},"16":{"title":"使用场景","titles":["算法设计思想","分而治之"]},"17":{"title":"分而治之的应用","titles":["算法设计思想","分而治之"]},"18":{"title":"多数元素","titles":["算法设计思想","分而治之","分而治之的应用"]},"19":{"title":"排序数组","titles":["算法设计思想","分而治之","分而治之的应用"]},"20":{"title":"最大子数组和","titles":["算法设计思想","分而治之","分而治之的应用"]},"21":{"title":"数组中的第 K 个最大元素","titles":["算法设计思想","分而治之","分而治之的应用"]},"22":{"title":"动态规划","titles":["算法设计思想"]},"23":{"title":"基本步骤","titles":["算法设计思想","动态规划"]},"24":{"title":"使用场景","titles":["算法设计思想","动态规划"]},"25":{"title":"动态规划的应用","titles":["算法设计思想","动态规划"]},"26":{"title":"爬楼梯","titles":["算法设计思想","动态规划","动态规划的应用"]},"27":{"title":"最长递增子序列","titles":["算法设计思想","动态规划","动态规划的应用"]},"28":{"title":"打家劫舍","titles":["算法设计思想","动态规划","动态规划的应用"]},"29":{"title":"零钱兑换","titles":["算法设计思想","动态规划","动态规划的应用"]},"30":{"title":"贪心算法","titles":["算法设计思想"]},"31":{"title":"基本步骤","titles":["算法设计思想","贪心算法"]},"32":{"title":"使用场景","titles":["算法设计思想","贪心算法"]},"33":{"title":"贪心算法的应用","titles":["算法设计思想","贪心算法"]},"34":{"title":"分发饼干","titles":["算法设计思想","贪心算法","贪心算法的应用"]},"35":{"title":"柠檬水找零","titles":["算法设计思想","贪心算法","贪心算法的应用"]},"36":{"title":"跳跃游戏","titles":["算法设计思想","贪心算法","贪心算法的应用"]},"37":{"title":"无重叠区间","titles":["算法设计思想","贪心算法","贪心算法的应用"]},"38":{"title":"分发糖果","titles":["算法设计思想","贪心算法","贪心算法的应用"]},"39":{"title":"回溯算法","titles":["算法设计思想"]},"40":{"title":"基本步骤","titles":["算法设计思想","回溯算法"]},"41":{"title":"使用场景","titles":["算法设计思想","回溯算法"]},"42":{"title":"回溯算法的应用","titles":["算法设计思想","回溯算法"]},"43":{"title":"全排列","titles":["算法设计思想","回溯算法","回溯算法的应用"]},"44":{"title":"子集","titles":["算法设计思想","回溯算法","回溯算法的应用"]},"45":{"title":"单词拆分 II","titles":["算法设计思想","回溯算法","回溯算法的应用"]},"46":{"title":"搜索算法","titles":[]},"47":{"title":"顺序搜索","titles":["搜索算法"]},"48":{"title":"二分搜索","titles":["搜索算法"]},"49":{"title":"排序算法","titles":[]},"50":{"title":"冒泡排序","titles":["排序算法"]},"51":{"title":"选择排序","titles":["排序算法"]},"52":{"title":"插入排序","titles":["排序算法"]},"53":{"title":"希尔排序","titles":["排序算法"]},"54":{"title":"归并排序","titles":["排序算法"]},"55":{"title":"快速排序","titles":["排序算法"]},"56":{"title":"堆排序","titles":["排序算法"]},"57":{"title":"基数排序","titles":["排序算法"]},"58":{"title":"计数排序","titles":["排序算法"]},"59":{"title":"数组","titles":[]},"60":{"title":"创建和初始化数组","titles":["数组"]},"61":{"title":"数组常见操作","titles":["数组"]},"62":{"title":"添加元素","titles":["数组","数组常见操作"]},"63":{"title":"删除元素","titles":["数组","数组常见操作"]},"64":{"title":"修改元素","titles":["数组","数组常见操作"]},"65":{"title":"二叉搜索树","titles":[]},"66":{"title":"二叉搜索树应用举例","titles":["二叉搜索树"]},"67":{"title":"二叉搜索树的封装","titles":["二叉搜索树"]},"68":{"title":"二叉搜索树的常见操作","titles":["二叉搜索树"]},"69":{"title":"插入数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"70":{"title":"遍历数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"71":{"title":"先序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"72":{"title":"中序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"73":{"title":"后序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"74":{"title":"总结","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"75":{"title":"查找数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"76":{"title":"查找最大值或最小值","titles":["二叉搜索树","二叉搜索树的常见操作","查找数据"]},"77":{"title":"查找特定值","titles":["二叉搜索树","二叉搜索树的常见操作","查找数据"]},"78":{"title":"删除数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"79":{"title":"删除的是叶子节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"80":{"title":"删除的是只有一个子节点的节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"81":{"title":"删除的是有两个子节点的节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"82":{"title":"前驱&amp;后继","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据","删除的是有两个子节点的节点"]},"83":{"title":"完整实现","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"84":{"title":"平衡树","titles":[]},"85":{"title":"二叉树","titles":[]},"86":{"title":"二叉树的概念","titles":["二叉树"]},"87":{"title":"二叉树的组成","titles":["二叉树"]},"88":{"title":"二叉树的五种形态","titles":["二叉树"]},"89":{"title":"二叉树的特性","titles":["二叉树"]},"90":{"title":"特殊的二叉树","titles":["二叉树"]},"91":{"title":"完美二叉树","titles":["二叉树","特殊的二叉树"]},"92":{"title":"完全二叉树","titles":["二叉树","特殊的二叉树"]},"93":{"title":"二叉树的数据存储","titles":["二叉树"]},"94":{"title":"使用数组","titles":["二叉树","二叉树的数据存储"]},"95":{"title":"使用链表","titles":["二叉树","二叉树的数据存储"]},"96":{"title":"双向链表","titles":[]},"97":{"title":"单向链表和双向链表","titles":["双向链表"]},"98":{"title":"单向链表","titles":["双向链表","单向链表和双向链表"]},"99":{"title":"双向链表","titles":["双向链表","单向链表和双向链表"]},"100":{"title":"双向链表结构","titles":["双向链表"]},"101":{"title":"双向链表常见的操作","titles":["双向链表"]},"102":{"title":"双向链表的封装","titles":["双向链表"]},"103":{"title":"创建双向链表类 DoublyLinkedList","titles":["双向链表","双向链表的封装"]},"104":{"title":"append(element)","titles":["双向链表","双向链表的封装"]},"105":{"title":"insert(position, element)","titles":["双向链表","双向链表的封装"]},"106":{"title":"insert(position, element)","titles":["双向链表","双向链表的封装"]},"107":{"title":"removeAt(position)","titles":["双向链表","双向链表的封装"]},"108":{"title":"update(position, data)","titles":["双向链表","双向链表的封装"]},"109":{"title":"forwardToString()","titles":["双向链表","双向链表的封装"]},"110":{"title":"backwardString()","titles":["双向链表","双向链表的封装"]},"111":{"title":"其他方法的实现","titles":["双向链表","双向链表的封装"]},"112":{"title":"完整实现","titles":["双向链表","双向链表的封装"]},"113":{"title":"代码测试","titles":["双向链表","双向链表的封装"]},"114":{"title":"图","titles":[]},"115":{"title":"图的概念","titles":["图"]},"116":{"title":"什么是图？","titles":["图","图的概念"]},"117":{"title":"图的术语","titles":["图","图的概念"]},"118":{"title":"现实建模","titles":["图","图的概念"]},"119":{"title":"图的表示","titles":["图"]},"120":{"title":"顶点表示","titles":["图","图的表示"]},"121":{"title":"邻接矩阵","titles":["图","图的表示"]},"122":{"title":"邻接表","titles":["图","图的表示"]},"123":{"title":"图的封装","titles":["图"]},"124":{"title":"创建图类","titles":["图","图的封装"]},"125":{"title":"方法","titles":["图","图的封装"]},"126":{"title":"添加顶点","titles":["图","图的封装","方法"]},"127":{"title":"添加边","titles":["图","图的封装","方法"]},"128":{"title":"toString 方法","titles":["图","图的封装","方法"]},"129":{"title":"测试代码","titles":["图","图的封装"]},"130":{"title":"图的遍历","titles":["图"]},"131":{"title":"遍历的方式","titles":["图","图的遍历"]},"132":{"title":"广度优先搜索 (BFS)","titles":["图","图的遍历"]},"133":{"title":"深度优先搜索 (DFS)","titles":["图","图的遍历"]},"134":{"title":"哈希表","titles":[]},"135":{"title":"认识哈希表","titles":["哈希表"]},"136":{"title":"认识哈希化","titles":["哈希表","认识哈希表"]},"137":{"title":"哈希表的一些概念","titles":["哈希表","认识哈希表"]},"138":{"title":"地址的冲突","titles":["哈希表","认识哈希表"]},"139":{"title":"链地址法（拉链法）","titles":["哈希表","认识哈希表","地址的冲突"]},"140":{"title":"开放地址法","titles":["哈希表","认识哈希表","地址的冲突"]},"141":{"title":"线性探测","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"142":{"title":"二次探测","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"143":{"title":"再哈希法","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"144":{"title":"装填因子","titles":["哈希表","认识哈希表","地址的冲突"]},"145":{"title":"不同探测方式性能的比较","titles":["哈希表","认识哈希表","地址的冲突"]},"146":{"title":"哈希函数","titles":["哈希表","认识哈希表"]},"147":{"title":"快速计算","titles":["哈希表","认识哈希表","哈希函数"]},"148":{"title":"均匀分布","titles":["哈希表","认识哈希表","哈希函数"]},"149":{"title":"封装哈希表","titles":["哈希表"]},"150":{"title":"哈希表常见操作","titles":["哈希表","封装哈希表"]},"151":{"title":"哈希函数的简单实现","titles":["哈希表","封装哈希表"]},"152":{"title":"哈希表的实现","titles":["哈希表","封装哈希表"]},"153":{"title":"创建哈希表类","titles":["哈希表","封装哈希表","哈希表的实现"]},"154":{"title":"put(key,value)","titles":["哈希表","封装哈希表","哈希表的实现"]},"155":{"title":"get(key)","titles":["哈希表","封装哈希表","哈希表的实现"]},"156":{"title":"remove(key)","titles":["哈希表","封装哈希表","哈希表的实现"]},"157":{"title":"isEmpty()","titles":["哈希表","封装哈希表","哈希表的实现"]},"158":{"title":"size()","titles":["哈希表","封装哈希表","哈希表的实现"]},"159":{"title":"哈希表的扩容与压缩","titles":["哈希表"]},"160":{"title":"resize() 的实现","titles":["哈希表","哈希表的扩容与压缩"]},"161":{"title":"选择质数作为哈希表容量","titles":["哈希表","哈希表的扩容与压缩"]},"162":{"title":"质数判断","titles":["哈希表","哈希表的扩容与压缩","选择质数作为哈希表容量"]},"163":{"title":"实现扩容或压缩后的哈希表容量为质数","titles":["哈希表","哈希表的扩容与压缩","选择质数作为哈希表容量"]},"164":{"title":"哈希表完整实现","titles":["哈希表"]},"165":{"title":"单向链表","titles":[]},"166":{"title":"链表和数组","titles":["单向链表"]},"167":{"title":"数组","titles":["单向链表","链表和数组"]},"168":{"title":"链表","titles":["单向链表","链表和数组"]},"169":{"title":"单向链表","titles":["单向链表"]},"170":{"title":"链表中的常见操作","titles":["单向链表","单向链表"]},"171":{"title":"单向链表的封装","titles":["单向链表","单向链表"]},"172":{"title":"创建单向链表类","titles":["单向链表","单向链表","单向链表的封装"]},"173":{"title":"实现 append() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"174":{"title":"实现 toString() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"175":{"title":"实现 insert() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"176":{"title":"实现 getData() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"177":{"title":"实现 indexOf() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"178":{"title":"实现 update() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"179":{"title":"实现 removeAt() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"180":{"title":"实现 remove() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"181":{"title":"实现 isEmpty() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"182":{"title":"实现 size() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"183":{"title":"完整实现","titles":["单向链表","单向链表","单向链表的封装"]},"184":{"title":"字典","titles":[]},"185":{"title":"字典特点","titles":["字典"]},"186":{"title":"字典和映射的关系","titles":["字典"]},"187":{"title":"字典常见的操作","titles":["字典"]},"188":{"title":"字典封装","titles":["字典"]},"189":{"title":"代码实现","titles":["字典","字典封装"]},"190":{"title":"代码测试","titles":["字典","字典封装"]},"191":{"title":"优先队列","titles":[]},"192":{"title":"场景","titles":["优先队列"]},"193":{"title":"优先队列","titles":["优先队列"]},"194":{"title":"优先队列的实现","titles":["优先队列"]},"195":{"title":"代码实现","titles":["优先队列","优先队列的实现"]},"196":{"title":"测试代码","titles":["优先队列","优先队列的实现"]},"197":{"title":"数组、栈和队列图解","titles":["优先队列"]},"198":{"title":"队列","titles":[]},"199":{"title":"认识队列","titles":["队列"]},"200":{"title":"队列图解","titles":["队列","认识队列"]},"201":{"title":"队列在程序中的应用","titles":["队列","认识队列"]},"202":{"title":"队列的实现","titles":["队列"]},"203":{"title":"队列常见的操作","titles":["队列","队列的实现"]},"204":{"title":"代码实现","titles":["队列","队列的实现"]},"205":{"title":"测试代码","titles":["队列","队列的实现"]},"206":{"title":"队列的应用","titles":["队列"]},"207":{"title":"代码实现","titles":["队列","队列的应用"]},"208":{"title":"测试代码","titles":["队列","队列的应用"]},"209":{"title":"集合","titles":[]},"210":{"title":"集合特点","titles":["集合"]},"211":{"title":"封装集合","titles":["集合"]},"212":{"title":"集合常见的操作","titles":["集合","封装集合"]},"213":{"title":"代码实现","titles":["集合","封装集合"]},"214":{"title":"代码测试","titles":["集合","封装集合"]},"215":{"title":"集合间的操作","titles":["集合"]},"216":{"title":"并集的实现","titles":["集合","集合间的操作"]},"217":{"title":"交集的实现","titles":["集合","集合间的操作"]},"218":{"title":"差集的实现","titles":["集合","集合间的操作"]},"219":{"title":"子集的实现","titles":["集合","集合间的操作"]},"220":{"title":"集合的完整实现","titles":["集合"]},"221":{"title":"栈","titles":[]},"222":{"title":"什么是栈","titles":["栈"]},"223":{"title":"程序中的栈结构","titles":["栈"]},"224":{"title":"练习","titles":["栈"]},"225":{"title":"栈结构实现","titles":["栈"]},"226":{"title":"栈常见的操作","titles":["栈","栈结构实现"]},"227":{"title":"JavaScript 代码实现栈结构","titles":["栈","栈结构实现"]},"228":{"title":"测试封装的栈结构","titles":["栈","栈结构实现"]},"229":{"title":"栈结构的简单应用","titles":["栈"]},"230":{"title":"代码实现","titles":["栈","栈结构的简单应用"]},"231":{"title":"测试","titles":["栈","栈结构的简单应用"]},"232":{"title":"树","titles":[]},"233":{"title":"真实的树","titles":["树"]},"234":{"title":"树的特点","titles":["树"]},"235":{"title":"树结构的优势","titles":["树"]},"236":{"title":"树的常用术语","titles":["树"]},"237":{"title":"树结构的表示方式","titles":["树"]},"238":{"title":"最普通的表示方法","titles":["树","树结构的表示方式"]},"239":{"title":"儿子 - 兄弟表示法","titles":["树","树结构的表示方式"]},"240":{"title":"儿子 - 兄弟表示法旋转","titles":["树","树结构的表示方式"]},"241":{"title":"前言","titles":[]},"242":{"title":"什么是数据结构","titles":["前言"]},"243":{"title":"数据结构的定义","titles":["前言","什么是数据结构"]},"244":{"title":"数据结构在生活中应用","titles":["前言","什么是数据结构"]},"245":{"title":"常见的数据结构","titles":["前言","什么是数据结构"]},"246":{"title":"什么是算法","titles":["前言"]},"247":{"title":"算法（Algorithm）的定义","titles":["前言","什么是算法"]},"248":{"title":"算法通俗理解","titles":["前言","什么是算法"]},"249":{"title":"算法案例","titles":["前言","什么是算法"]},"250":{"title":"学习数据结构与算法的好处","titles":["前言"]}},"dirtCount":0,"index":[["机器学习",{"2":{"250":1}}],["支持技术进步",{"2":{"250":1}}],["支付的顺序",{"2":{"35":1}}],["腾讯等",{"2":{"250":1}}],["微软",{"2":{"250":1}}],["许多大公司的面试",{"2":{"250":1}}],["许多高级的编程概念和技术",{"2":{"250":1}}],["良好的数据结构设计能够使代码更清晰",{"2":{"250":1}}],["编写可维护的代码",{"2":{"250":1}}],["编译器等",{"2":{"250":1}}],["能够选择合适的数据结构和算法",{"2":{"250":1}}],["能把某一员工的姓名转换为它对应的工号",{"2":{"135":1}}],["理解计算机科学的核心",{"2":{"250":1}}],["掌握这些基础知识",{"2":{"250":1}}],["掌握基础知识",{"2":{"250":1}}],["学会如何将一个大问题分解成更小",{"2":{"250":1}}],["学习数据结构与算法的好处",{"0":{"250":1}}],["≈",{"2":{"249":1}}],["怎么计算出来的呢",{"2":{"249":1}}],["怎么找到某本指定的书",{"2":{"244":1}}],["看一下问题出在上海到中间位置",{"2":{"249":1}}],["米",{"2":{"249":1}}],["高架线长度是",{"2":{"249":1}}],["假如上海和杭州之间有一条高架线",{"2":{"249":1}}],["假设我们有一个无序数组",{"2":{"57":1,"58":1}}],["假设当前节点是最大值",{"2":{"56":1}}],["假设你是一位很棒的家长",{"2":{"34":1}}],["假设你正在爬楼梯",{"2":{"26":1}}],["假设枢纽值的位置为",{"2":{"12":1}}],["离不开算法",{"2":{"248":1}}],["散列表",{"2":{"245":1}}],["移出空位",{"2":{"244":1}}],["移除栈顶的元素",{"2":{"226":1}}],["移除集合中的所有项",{"2":{"212":1}}],["移除队列的第一",{"2":{"203":1}}],["移除",{"2":{"37":1}}],["移除所有非字母和非数字字符",{"2":{"7":1}}],["正传",{"2":{"244":1}}],["阿",{"2":{"244":1}}],["盲目找",{"2":{"244":1}}],["哪里有空位放哪里",{"2":{"244":1}}],["精心选择的数据结构可以带来最优效率的算法",{"2":{"243":1}}],["抽象数据类型",{"2":{"243":1}}],["任何树都可以通过二叉树进行模拟",{"2":{"240":1}}],["任务安排等问题",{"2":{"32":1}}],["统一只记录右边的第一个兄弟节点",{"2":{"239":1}}],["统一只记录左边的子节点",{"2":{"239":1}}],["统计数组中每个元素的出现次数",{"2":{"58":1}}],["统计每个元素出现的次数",{"2":{"58":2}}],["统计每个单词的出现次数",{"2":{"9":1}}],["统计元素出现次数",{"2":{"58":2}}],["统计元素在给定区间内的出现次数",{"2":{"18":1}}],["统计结果",{"2":{"37":1}}],["兄弟表示法组成的树结构",{"2":{"240":1}}],["兄弟表示法旋转",{"0":{"240":1}}],["兄弟表示法",{"0":{"239":1}}],["兄弟节点",{"2":{"236":1}}],["儿子",{"0":{"239":1,"240":1}}],["层",{"2":{"236":1}}],["层的最大节点树为",{"2":{"89":1}}],["规定根节点在",{"2":{"236":1}}],["规律总结",{"2":{"81":1}}],["互为兄弟节点",{"2":{"236":1}}],["互联网中的某台主机",{"2":{"117":1}}],["互联网中的网络关系",{"2":{"116":1}}],["具有同一父节点的各节点彼此是兄弟节点",{"2":{"236":1}}],["具体算法为",{"2":{"147":1}}],["具体来说",{"2":{"45":1}}],["叶节点",{"2":{"236":1}}],["叶子节点不为根节点",{"2":{"79":1}}],["叶子节点也是根节点",{"2":{"79":1}}],["≥",{"2":{"235":1}}],["底层使用的数组中很多单元没有被利用",{"2":{"235":1}}],["才能在使用数据时更加方便呢",{"2":{"244":1}}],["才能提高查找效率",{"2":{"235":1}}],["才能有效的计算",{"2":{"122":1}}],["生成有序数组",{"2":{"235":1}}],["生活中类似队列结构的场景",{"2":{"199":1}}],["生活中类似优先队列的场景",{"2":{"192":1}}],["效率天壤之别",{"2":{"249":1}}],["效率高",{"2":{"235":1}}],["效率更高",{"2":{"148":1}}],["模拟的树结构相当于旋转",{"2":{"234":1}}],["形成许多树枝",{"2":{"234":1}}],["形成新的待排序数组",{"2":{"57":1}}],["连接着根的是树干",{"2":{"234":1}}],["连续的单元",{"2":{"141":1}}],["连续子数组",{"2":{"20":1}}],["真实的树",{"0":{"233":1}}],["除数除以二",{"2":{"230":1}}],["除二取余法",{"2":{"230":1}}],["除了二叉树最后一层外",{"2":{"92":1}}],["除了最下一层的叶子节点外",{"2":{"91":1}}],["除了用于存储输入的区间列表",{"2":{"37":1}}],["压栈操作",{"2":{"227":1}}],["压入栈",{"2":{"223":2}}],["符合入栈顺序",{"2":{"224":1}}],["符合要求",{"2":{"81":6}}],["整体的入栈顺序符合",{"2":{"224":1}}],["整体入栈顺序符合",{"2":{"224":1}}],["整除",{"2":{"162":2}}],["答案",{"2":{"224":4}}],["进栈出栈",{"2":{"224":6}}],["进栈",{"2":{"224":5}}],["进栈顺序为",{"2":{"224":1}}],["进行封装",{"2":{"209":1}}],["进行删除操作",{"2":{"199":1}}],["进行越界判断",{"2":{"175":1,"183":1}}],["进行新增数据操作",{"2":{"154":1}}],["进行取余操作",{"2":{"139":1}}],["进行插入操作",{"2":{"199":1}}],["进行插入",{"2":{"84":1}}],["进行比较",{"2":{"66":1}}],["进行下一轮选择和探索",{"2":{"43":2,"44":2}}],["进行排序合并",{"2":{"54":1}}],["进行排序",{"2":{"37":1}}],["进行划分",{"2":{"12":1}}],["×",{"2":{"224":1}}],["√",{"2":{"224":3}}],["问下列哪一个不是合法的出栈顺序",{"2":{"224":1}}],["题目所说的按顺序进栈指的不是一次性全部进栈",{"2":{"224":1}}],["题目",{"2":{"224":1}}],["题目来源",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":1,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["练习",{"0":{"224":1}}],["弹出栈的顺序为",{"2":{"223":1}}],["程序中的栈结构",{"0":{"223":1}}],["仅仅返回它",{"2":{"226":1}}],["仅允许在表的一端进行插入和删除运算",{"2":{"222":1}}],["仅有小写英文字母组成",{"2":{"45":1}}],["必须对这种任意性加以限制",{"2":{"221":1}}],["栈结构的简单应用",{"0":{"229":1},"1":{"230":1,"231":1}}],["栈结构的封装",{"2":{"227":1}}],["栈结构实现",{"0":{"225":1},"1":{"226":1,"227":1,"228":1}}],["栈常见的操作",{"0":{"226":1}}],["栈顶",{"2":{"223":1}}],["栈的特点",{"2":{"222":1}}],["栈和队列就是比较常见的受限的线性结构",{"2":{"221":1}}],["栈和队列图解",{"0":{"197":1}}],["栈",{"0":{"221":1},"1":{"222":1,"223":1,"224":1,"225":1,"226":1,"227":1,"228":1,"229":1,"230":1,"231":1},"2":{"222":1,"245":1}}],["验证一个给定集合是否是另一个集合的子集",{"2":{"215":1}}],["差集的实现",{"0":{"218":1}}],["差集",{"2":{"215":1,"218":1,"220":1}}],["交集的实现",{"0":{"217":1}}],["交集",{"2":{"215":1}}],["交换节点信息",{"2":{"105":1,"106":1,"112":1}}],["交换堆顶元素",{"2":{"56":1}}],["交换",{"2":{"51":3}}],["交换数组中两个元素的位置",{"2":{"51":1}}],["交换最小元素到当前位置",{"2":{"51":1}}],["交换元素",{"2":{"50":1,"51":1}}],["清空集合中所有",{"2":{"213":1,"220":1}}],["清空字典中所有的键值对",{"2":{"189":1}}],["了解集合的底层实现",{"2":{"211":1}}],["了解这些术语有助于我们更深层次的理解图",{"2":{"117":1}}],["集合的完整实现",{"0":{"220":1}}],["集合的所有",{"2":{"216":1,"220":1}}],["集合中存在",{"2":{"217":1,"218":1,"219":1,"220":3}}],["集合间的操作",{"0":{"215":1},"1":{"216":1,"217":1,"218":1,"219":1},"2":{"220":1}}],["集合结构的封装",{"2":{"213":1,"220":1}}],["集合常见的操作",{"0":{"212":1}}],["集合是特殊的数组",{"2":{"210":1}}],["集合通常是由一组无序的",{"2":{"210":1}}],["集合特点",{"0":{"210":1}}],["集合比较常见的实现方式是哈希表",{"2":{"209":1}}],["集合",{"0":{"209":1},"1":{"210":1,"211":1,"212":1,"213":1,"214":1,"215":1,"216":1,"217":1,"218":1,"219":1,"220":1}}],["传入一组数据集合和设定的数字",{"2":{"206":1}}],["传递更新后的路径和新的起始索引",{"2":{"44":2}}],["传递更新后的路径和剩余可选择的数字",{"2":{"43":1}}],["击鼓传花",{"2":{"206":1,"208":1}}],["线程队列",{"2":{"201":1}}],["线性查找",{"2":{"156":1,"249":1}}],["线性遍历",{"2":{"155":1}}],["线性探测存在一个比较严重的问题",{"2":{"141":1}}],["线性探测存在的问题",{"2":{"141":1}}],["线性探测",{"0":{"141":1},"2":{"140":1,"142":1,"145":1}}],["打印队列",{"2":{"201":1}}],["打家劫舍",{"0":{"28":1}}],["甚至是厕所排队",{"2":{"199":1}}],["甚至子节点还有子节点",{"2":{"81":1}}],["商场",{"2":{"199":1}}],["受限之处",{"2":{"199":1}}],["认识队列",{"0":{"199":1},"1":{"200":1,"201":1}}],["认识哈希化",{"0":{"136":1}}],["认识哈希表",{"0":{"135":1},"1":{"136":1,"137":1,"138":1,"139":1,"140":1,"141":1,"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":1}}],["队列中只剩下",{"2":{"207":1}}],["队列的应用",{"0":{"206":1},"1":{"207":1,"208":1}}],["队列的实现和栈一样",{"2":{"202":1}}],["队列的实现",{"0":{"202":1},"1":{"203":1,"204":1,"205":1}}],["队列不做任何变动",{"2":{"203":1}}],["队列不为空时一直持续",{"2":{"132":1}}],["队列常见的操作",{"0":{"203":1}}],["队列在程序中的应用",{"0":{"201":1}}],["队列图解",{"0":{"200":1}}],["队列",{"0":{"198":1},"1":{"199":1,"200":1,"201":1,"202":1,"203":1,"204":1,"205":1,"206":1,"207":1,"208":1},"2":{"199":1,"245":1}}],["值",{"2":{"213":1,"220":1}}],["值越小",{"2":{"195":1}}],["值与之比较",{"2":{"77":1}}],["买票",{"2":{"192":1,"199":1}}],["场景",{"0":{"192":1}}],["反之则返回",{"2":{"187":1}}],["主要特点是一一对应",{"2":{"185":1}}],["主函数调用",{"2":{"45":1}}],["主函数",{"2":{"19":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["赋值到",{"2":{"179":1,"183":1}}],["赋值为",{"2":{"175":1,"183":1}}],["痛过循环遍历",{"2":{"178":1,"183":1}}],["涉及到",{"2":{"178":1,"183":1}}],["原来的第一个节点",{"2":{"175":1,"183":1}}],["原有的相对顺序可能会被打破",{"2":{"51":1}}],["循序依次找最后一个节点",{"2":{"173":1,"183":1}}],["循环",{"2":{"230":1}}],["循环遍历数组内元素",{"2":{"206":1}}],["循环使",{"2":{"173":1}}],["循环查找",{"2":{"82":1,"83":1}}],["循环查找到要删除的节点",{"2":{"78":1,"83":1}}],["循环实现",{"2":{"77":1}}],["循环从",{"2":{"52":1}}],["追加完新节点后",{"2":{"173":1,"183":1}}],["追加新节点",{"2":{"173":1,"183":1}}],["追加元素",{"2":{"104":1,"112":1}}],["火车头会连接一个节点",{"2":{"169":1}}],["访问任何一个位置的元素时",{"2":{"168":1}}],["内部类",{"2":{"172":1,"183":1}}],["内存空间不必是连续的",{"2":{"168":1}}],["内层循环",{"2":{"51":1}}],["倍",{"2":{"167":1}}],["倍扩容后长度为",{"2":{"163":1}}],["倍扩容或压缩之后",{"2":{"163":1}}],["语法来访问数组元素",{"2":{"167":1}}],["语言中的自带的排序",{"2":{"49":1}}],["语言中的自带的搜索",{"2":{"46":1}}],["停止循环",{"2":{"163":1}}],["针对质数的特点",{"2":{"162":1}}],["针对部分有序数组的优化",{"2":{"50":1}}],["质数判断",{"0":{"162":1}}],["质数即可",{"2":{"151":1}}],["扩容或压缩",{"2":{"160":1,"164":1}}],["扩容之后所有的数据项都要进行同步修改",{"2":{"159":1}}],["扩大已排序部分",{"2":{"51":1}}],["关于质数",{"2":{"159":1}}],["什么是算法",{"0":{"246":1},"1":{"247":1,"248":1,"249":1}}],["什么是数据结构",{"0":{"242":1},"1":{"243":1,"244":1,"245":1}}],["什么是栈",{"0":{"222":1}}],["什么是图呢",{"2":{"116":1}}],["什么是图",{"0":{"116":1}}],["什么情况下需要扩容",{"2":{"159":1}}],["寻找对应的数据",{"2":{"156":1}}],["仍然没有找到对应的",{"2":{"155":1}}],["仍然是初始值",{"2":{"29":1}}],["格式为",{"2":{"154":1,"164":1}}],["新进一本",{"2":{"244":1}}],["新书怎么插入",{"2":{"244":1}}],["新的项",{"2":{"203":1}}],["新插入节点的位置",{"2":{"175":1,"183":1}}],["新增数据",{"2":{"154":1,"164":1}}],["新添加",{"2":{"103":2}}],["终止",{"2":{"164":1}}],["终止不再往下执行",{"2":{"154":1}}],["终止条件",{"2":{"43":2}}],["随便放",{"2":{"244":1}}],["随后",{"2":{"155":1,"156":1,"223":1}}],["随后放置在该索引值的位置",{"2":{"154":1}}],["随着数据量的增多",{"2":{"159":1}}],["随着装填因子的变大",{"2":{"145":1}}],["随着装填因子的增大",{"2":{"145":1}}],["随着装填因子变小",{"2":{"145":1}}],["随着填装因子变大",{"2":{"143":1}}],["随着排序的进行",{"2":{"53":1}}],["封装集合",{"0":{"211":1},"1":{"212":1,"213":1,"214":1}}],["封装的哈希表的数据结构模型",{"2":{"153":1}}],["封装哈希表",{"0":{"149":1},"1":{"150":1,"151":1,"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":1}}],["秦九韶算法",{"2":{"151":1}}],["自己采用的一个质数",{"2":{"151":1}}],["此外",{"2":{"185":1}}],["此处先简单地指定数组的大小",{"2":{"151":1}}],["此时要求很大容量的数组",{"2":{"136":1}}],["此时的时间复杂度也是接近",{"2":{"84":1}}],["此时通过",{"2":{"80":6}}],["此时基准元素处于其正确的位置",{"2":{"55":1}}],["此时需要进行",{"2":{"50":1}}],["此时",{"2":{"4":1,"5":1,"50":1,"52":2,"79":1}}],["尽量使用质数",{"2":{"148":1}}],["均匀分布",{"0":{"148":1}}],["均匀的分布",{"2":{"146":1}}],["降到了",{"2":{"147":1}}],["乘法次数",{"2":{"147":2}}],["变换之后",{"2":{"147":1}}],["变换之前",{"2":{"147":1}}],["变量",{"2":{"78":2}}],["霍纳法则",{"2":{"147":1}}],["提高代码效率",{"2":{"250":1}}],["提高编程能力",{"2":{"250":1}}],["提高速度的一个方法是在哈希函数中尽量减少乘法和除法",{"2":{"146":1}}],["提供了一个便利的",{"2":{"167":1}}],["提示",{"2":{"18":1,"43":1,"44":1,"45":1}}],["较为平缓",{"2":{"145":1}}],["性能高的哈希函数应具备以下两个优点",{"2":{"146":1}}],["性能不高",{"2":{"145":1}}],["性能较差",{"2":{"145":1}}],["性能优于",{"2":{"84":1}}],["装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值",{"2":{"144":1}}],["装填因子",{"0":{"144":1},"2":{"144":1,"159":1,"160":1,"164":1}}],["探测长度会越来越长",{"2":{"143":1}}],["且小于数组的容量",{"2":{"143":1}}],["聚集会影响哈希表的性能",{"2":{"141":1}}],["查看栈顶元素",{"2":{"227":1}}],["查看队列的队头元素",{"2":{"204":1}}],["查看队列的前端元素",{"2":{"195":1}}],["查看队列中元素的个数",{"2":{"195":1,"204":1}}],["查看队列是否为空",{"2":{"195":1,"204":1}}],["查询",{"2":{"141":1,"235":1}}],["查询过程中不会遍历整个哈希表",{"2":{"141":1}}],["查找对应的问题后",{"2":{"249":1}}],["查找",{"2":{"135":1}}],["查找效率高",{"2":{"235":1}}],["查找效率低",{"2":{"235":1}}],["查找效率变成了",{"2":{"84":1}}],["查找效率非常高",{"2":{"66":1}}],["查找等操作的效率是",{"2":{"84":1}}],["查找前驱的原理相同",{"2":{"82":1}}],["查找前驱时",{"2":{"82":1}}],["查找需要被删除的节点",{"2":{"82":1}}],["查找二叉搜索树中是否有相同的",{"2":{"77":1}}],["查找二叉搜索树当中的特定值效率也非常高",{"2":{"77":1}}],["查找特定值",{"0":{"77":1}}],["查找最大值或最小值",{"0":{"76":1}}],["查找数据时需要先对数据进行排序",{"2":{"235":1}}],["查找数据",{"0":{"75":1},"1":{"76":1,"77":1}}],["查找一篇英文文章中出现频率最高的单词",{"0":{"9":1}}],["产生输出",{"2":{"247":1}}],["产生一种依赖关键字",{"2":{"143":1}}],["产生冲突的元素一般不会太多",{"2":{"139":1}}],["产生的数组下标又太多",{"2":{"136":1}}],["产生的数组下标太少",{"2":{"136":1}}],["之后",{"2":{"240":1}}],["之后应该",{"2":{"224":1}}],["之后讨论",{"2":{"159":1}}],["之后得到的下标值",{"2":{"141":1}}],["之后继续在数组或链表中查找就可以了",{"2":{"139":1}}],["之间遍历",{"2":{"175":1,"183":1}}],["之间有边",{"2":{"117":1}}],["之间的关系",{"2":{"116":1}}],["之间",{"2":{"53":1}}],["拉链法可以无限延伸下去",{"2":{"144":1}}],["拉链法",{"0":{"139":1},"2":{"138":1}}],["链地址法或者开放地址法",{"2":{"148":1}}],["链地址法的性能",{"2":{"145":1}}],["链地址法的装填因子可以大于",{"2":{"144":1}}],["链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据",{"2":{"139":1}}],["链地址法",{"0":{"139":1},"2":{"138":1}}],["链表数据以字符串形式返回",{"2":{"183":1}}],["链表数据从后往前以字符串形式返回",{"2":{"110":1,"112":1}}],["链表数据从前往后以字符串形式返回",{"2":{"109":1,"112":1}}],["链表长度",{"2":{"173":1,"183":1}}],["链表长度大于",{"2":{"173":1,"183":1}}],["链表长度为",{"2":{"173":1,"183":1}}],["链表里的节点",{"2":{"172":1,"183":1}}],["链表中的常见操作",{"0":{"170":1}}],["链表中的最后一个节点指向",{"2":{"169":1}}],["链表中的元素在内存中不必是连续的空间",{"2":{"168":1}}],["链表缺点",{"2":{"168":1}}],["链表在插入和删除数据时",{"2":{"168":1}}],["链表不必在创建时就确定大小",{"2":{"168":1}}],["链表优点",{"2":{"168":1}}],["链表的数据结构",{"2":{"169":1}}],["链表的火车结构",{"2":{"169":1}}],["链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用",{"2":{"168":1}}],["链表的常见操作",{"2":{"112":1,"183":1}}],["链表和数组一样",{"2":{"166":1}}],["链表和数组",{"0":{"166":1},"1":{"167":1,"168":1}}],["链表和树等可通过图形的形式表示其结构和原理",{"2":{"135":1}}],["链表",{"0":{"168":1},"2":{"122":2,"159":1,"235":2,"245":1}}],["链表内有多个节点的情况",{"2":{"107":1,"112":1}}],["链表内只有一个节点的情况",{"2":{"107":1,"112":1}}],["链表相连的过程是双向的",{"2":{"99":1}}],["链表相连的过程是单向的",{"2":{"98":1}}],["冲突是不可避免的",{"2":{"138":1}}],["地址的冲突",{"0":{"138":1},"1":{"139":1,"140":1,"141":1,"142":1,"143":1,"144":1,"145":1}}],["得到的就是哈希表",{"2":{"137":1}}],["得到有序数组",{"2":{"57":1,"58":1}}],["把书架划分成几块区域",{"2":{"244":1}}],["把另一端称为栈底",{"2":{"222":1}}],["把",{"2":{"207":1}}],["把关键字用另一个哈希函数",{"2":{"143":1}}],["把大数字进行哈希化的代码实现放在一个函数中",{"2":{"137":1}}],["把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中",{"2":{"136":1}}],["称之为哈希化",{"2":{"137":1}}],["称为原来树的子树",{"2":{"235":1}}],["称为空树",{"2":{"235":1}}],["称为",{"2":{"82":2}}],["称为增量序列",{"2":{"53":1}}],["哈希函数的简单实现",{"0":{"151":1}}],["哈希函数",{"0":{"146":1},"1":{"147":1,"148":1},"2":{"137":1}}],["哈希化采用的是公式为",{"2":{"148":1}}],["哈希化的效率",{"2":{"143":1}}],["哈希化",{"2":{"137":1}}],["哈希表有哪些优势呢",{"2":{"235":1}}],["哈希表完整实现",{"0":{"164":1}}],["哈希表存储数据的变量",{"2":{"153":1,"164":1}}],["哈希表常见操作",{"0":{"150":1}}],["哈希表长度",{"2":{"144":1,"153":1,"160":1,"164":1}}],["哈希表中数据",{"2":{"160":1}}],["哈希表中执行插入和搜索操作效率是非常高的",{"2":{"143":1}}],["哈希表中的",{"2":{"135":1}}],["哈希表中的数据是没有顺序的",{"2":{"135":1}}],["哈希表最后还是基于数组来实现的",{"2":{"135":1}}],["哈希表的插入",{"2":{"235":1}}],["哈希表的插入和修改操作是同一个函数",{"2":{"154":1}}],["哈希表的扩容与压缩",{"0":{"159":1},"1":{"160":1,"161":1,"162":1,"163":1}}],["哈希表的实现",{"0":{"152":1},"1":{"153":1,"154":1,"155":1,"156":1,"157":1,"158":1}}],["哈希表的长度",{"2":{"148":1}}],["哈希表的优势在于它的速度",{"2":{"146":1}}],["哈希表的一些概念",{"0":{"137":1}}],["哈希表的结构就是数组",{"2":{"135":1}}],["哈希表的速度比树还要快",{"2":{"135":1}}],["哈希表并不好理解",{"2":{"135":1}}],["哈希表是什么",{"2":{"135":1}}],["哈希表是一种非常重要的数据结构",{"2":{"135":1}}],["哈希表同样存在不足之处",{"2":{"135":1}}],["哈希表相对于树来说编码要简单得多",{"2":{"135":1}}],["哈希表可以提供非常快速的",{"2":{"135":1}}],["哈希表通常是基于数组实现的",{"2":{"135":1}}],["哈希表",{"0":{"134":1},"1":{"135":1,"136":1,"137":1,"138":1,"139":1,"140":1,"141":1,"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1,"150":1,"151":1,"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":1,"159":1,"160":1,"161":1,"162":1,"163":1,"164":1},"2":{"122":1,"137":1,"235":1}}],["让新插入的元素进行优先级比较",{"2":{"195":1}}],["让新节点的",{"2":{"175":1,"183":1}}],["让上一节点的",{"2":{"179":1,"183":1}}],["让最后一个节点指向新节点",{"2":{"173":1}}],["让",{"2":{"159":1}}],["让数字相加求和",{"2":{"136":1}}],["让其只输出元素的值",{"2":{"101":1,"170":1}}],["造成了数组空间的浪费",{"2":{"136":1}}],["幂的连乘",{"2":{"136":1}}],["幂集",{"2":{"44":1}}],["很多的单词按照该方式转化为数字后都是",{"2":{"136":1}}],["作为数组的下标值",{"2":{"139":1}}],["作为",{"2":{"136":1}}],["转成字符串形式",{"2":{"203":1}}],["转化为数字",{"2":{"136":1}}],["转换回数组",{"2":{"2":1}}],["案例二",{"2":{"135":1}}],["案例一",{"2":{"135":1}}],["没有顺序意味着不能通过下标值进行访问",{"2":{"210":1}}],["没有用到的",{"2":{"117":1}}],["没错此时就可以使用哈希表的哈希函数来实现",{"2":{"135":1}}],["公司想要存储",{"2":{"135":1}}],["公司的组织架构等等",{"2":{"116":1}}],["操作系统",{"2":{"250":1}}],["操作",{"2":{"135":1,"244":8}}],["沿着路径知道这条路径最后被访问了",{"2":{"133":1}}],["拿与该点相邻的点",{"2":{"133":1}}],["拿到队头所关联",{"2":{"132":1}}],["拿到队头",{"2":{"132":1}}],["拿起来第一张",{"2":{"52":1}}],["执行完之后",{"2":{"223":1}}],["执行时也会被压入栈",{"2":{"223":1}}],["执行时",{"2":{"223":1}}],["执行的过程中会将",{"2":{"223":1}}],["执行相应的回调",{"2":{"133":1}}],["执行下面的步骤",{"2":{"132":1}}],["执行排序过程",{"2":{"50":1}}],["标志为黑色",{"2":{"132":1}}],["标注为被发现的灰色",{"2":{"132":1}}],["标注为被发现的",{"2":{"132":1}}],["标记路径",{"2":{"40":1}}],["qadj",{"2":{"132":3}}],["qval",{"2":{"132":5}}],["q",{"2":{"132":4,"244":1}}],["queueelement",{"2":{"195":8,"196":8}}],["queue",{"2":{"132":6,"195":6,"199":1,"204":1,"205":14,"207":9,"245":1}}],["quicksort",{"2":{"55":4}}],["quickselect",{"2":{"12":2,"21":5}}],["quick",{"2":{"55":1}}],["quot",{"2":{"45":46,"55":2,"185":10}}],["换句话说",{"2":{"132":1}}],["换成了",{"2":{"53":1}}],["黑色",{"2":{"131":1}}],["黑色表示该顶点被访问过且被完全探索过",{"2":{"131":1}}],["灰色",{"2":{"131":1,"132":2}}],["灰色表示该顶点被访问过",{"2":{"131":1}}],["白色",{"2":{"131":1,"132":1}}],["白色表示该顶点还没有被访问",{"2":{"131":1}}],["入栈或压栈",{"2":{"222":1}}],["入队",{"2":{"195":1,"196":1,"204":1}}],["入队列的顶点先被探索",{"2":{"131":1}}],["入度",{"2":{"122":3}}],["两种数据结构查找的效率相当",{"2":{"139":1}}],["两种方案总结",{"2":{"136":1}}],["两种算法的思想",{"2":{"131":1}}],["两个指针都移动到下一个",{"2":{"34":1}}],["简称",{"2":{"131":2}}],["简单的扩容可以直接扩大两倍",{"2":{"159":1}}],["简单路径要求不包含重复的顶点",{"2":{"117":1}}],["简单路径",{"2":{"117":1}}],["简单来说",{"2":{"49":1}}],["简单",{"2":{"18":1,"26":1,"34":1,"35":1}}],["逆邻接表",{"2":{"122":1}}],["出栈操作",{"2":{"227":1}}],["出栈而不是",{"2":{"224":1}}],["出栈",{"2":{"224":14}}],["出队",{"2":{"195":1,"196":1,"204":1}}],["出度",{"2":{"122":2}}],["出现次数较多的元素即为多数元素",{"2":{"18":1}}],["字节跳动",{"2":{"250":1}}],["字典结构的封装",{"2":{"189":1}}],["字典封装",{"0":{"188":1},"1":{"189":1,"190":1}}],["字典常见的操作",{"0":{"187":1}}],["字典和映射的关系",{"0":{"186":1}}],["字典形式",{"2":{"185":1}}],["字典存储的是键值对",{"2":{"185":1}}],["字典特点",{"0":{"185":1}}],["字典",{"0":{"184":1},"1":{"185":1,"186":1,"187":1,"188":1,"189":1,"190":1},"2":{"122":2}}],["字符串的全排列等问题",{"2":{"41":1}}],["邻接的意思",{"2":{"124":1}}],["邻接表如果需要计算有向图的",{"2":{"122":1}}],["邻接表计算",{"2":{"122":1}}],["邻接表的问题",{"2":{"122":1}}],["邻接表由图中每个顶点以及和顶点相邻的顶点列表组成",{"2":{"122":1}}],["邻接表",{"0":{"122":1}}],["邻接矩阵展示出来的二维数组",{"2":{"121":1}}],["邻接矩阵的问题",{"2":{"121":1}}],["邻接矩阵让每个节点和一个整数向关联",{"2":{"121":1}}],["邻接矩阵",{"0":{"121":1}}],["概述",{"2":{"121":1,"122":1}}],["另外一个选择就是使用链表",{"2":{"168":1}}],["另外",{"2":{"121":1,"126":1}}],["另外包含顶点和顶点之间的连线",{"2":{"119":1}}],["另一部分的所有元素都大于基准",{"2":{"55":1}}],["另一个指向饼干尺寸数组",{"2":{"34":1}}],["​",{"2":{"118":1}}],["航空公司可以用图来为其飞行系统建模",{"2":{"118":1}}],["建立字符串和下标值的映射关系",{"2":{"135":1}}],["建立数学模型",{"2":{"31":1}}],["建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本",{"2":{"118":1}}],["建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道",{"2":{"118":1}}],["加法次数",{"2":{"147":2}}],["加入到队列中",{"2":{"132":1}}],["加入到它的数组中",{"2":{"127":2}}],["加权的边可以表示从一个机场到另一个机场的航班成本",{"2":{"118":1}}],["加权的边可以表示限速或者车道的数量或者街道的距离",{"2":{"118":1}}],["加上一个",{"2":{"29":1}}],["现实生活中很多结构都是树的抽象",{"2":{"234":1}}],["现实建模",{"0":{"118":1}}],["现在需要一种方法",{"2":{"143":1}}],["现在需要一种压缩方法",{"2":{"136":1}}],["现在要求输入一个整数",{"2":{"10":1}}],["带权图表示边有一定的权重",{"2":{"117":1}}],["带权图",{"2":{"117":1}}],["路径所包含边的个数称为路径长度",{"2":{"236":1}}],["路径指的是一个节点到另一节点的通道",{"2":{"236":1}}],["路径和路径长度",{"2":{"236":1}}],["路径是顶点",{"2":{"117":1}}],["路径",{"2":{"117":1}}],["路径有其他的概念",{"2":{"117":1}}],["度不为",{"2":{"236":1}}],["度为",{"2":{"236":1}}],["度",{"2":{"117":1}}],["由此我们可以得出结论",{"2":{"240":1}}],["由此得到质数",{"2":{"163":1}}],["由",{"2":{"235":1}}],["由下图可知",{"2":{"145":1}}],["由一条边连接在一起的顶点称为相邻顶点",{"2":{"117":1}}],["由于队列没有像数组一样的下标值不能直接取到某一元素",{"2":{"207":1}}],["由于使用的是链地址法",{"2":{"159":1}}],["由于不知道存储张三数据对象的下标值",{"2":{"135":1}}],["由于不是每位顾客都得到了正确的找零",{"2":{"35":1}}],["由于链表项使用了",{"2":{"101":1,"170":1}}],["由于树结构不是线性结构",{"2":{"70":1}}],["由于",{"2":{"66":4,"84":1,"92":1}}],["由于增量序列的选择对希尔排序的时间复杂度有很大的影响",{"2":{"53":1}}],["由于其时间复杂度和空间复杂度均为线性",{"2":{"58":1}}],["由于其",{"2":{"51":1,"52":1}}],["由于选择排序每一趟排序所需的比较次数固定",{"2":{"51":1}}],["由于所有客户都得到了正确的找零",{"2":{"35":1}}],["由于他们的尺寸都是",{"2":{"34":1}}],["由于一次只能够跳",{"2":{"11":1}}],["人际关系中的人",{"2":{"117":1}}],["人与人之间的关系网",{"2":{"116":1}}],["多个村庄中的某个村庄",{"2":{"117":1}}],["多数元素是指在数组中出现次数大于",{"2":{"18":1}}],["多数元素",{"0":{"18":1}}],["顶点是沿着路径被探索的",{"2":{"131":1}}],["顶点有关联的顶点",{"2":{"122":1}}],["顶点的表示相对简单",{"2":{"120":1}}],["顶点的度是",{"2":{"117":2}}],["顶点表示",{"0":{"120":1}}],["顶点可以表示街道的十字路口",{"2":{"118":1}}],["顶点和其他四个顶点相连",{"2":{"117":1}}],["顶点和其他两个顶点相连",{"2":{"117":1}}],["顶点刚才我们已经介绍过了",{"2":{"117":1}}],["顶点",{"2":{"117":1,"121":1}}],["某些术语后面用到的时候",{"2":{"117":1}}],["边不可能单独存在",{"2":{"127":2}}],["边的表示略微复杂",{"2":{"120":1}}],["边可以表示街道",{"2":{"118":1}}],["边可以是有向的",{"2":{"116":1}}],["边没有携带权重",{"2":{"117":1}}],["边表示顶点和顶点之间的连线",{"2":{"117":1}}],["边",{"2":{"117":1,"119":1,"122":1}}],["边是顶点和顶点之间的连线",{"2":{"116":1}}],["几乎每种编程语言中",{"2":{"209":1}}],["几乎每一种编程语言都有默认实现数组结构",{"2":{"167":1}}],["几乎所有的编程语言都直接或者间接应用这种数据结构",{"2":{"135":1}}],["几乎所有的编程语言都原生支持数组类型",{"2":{"59":1}}],["几叉树都不可以",{"2":{"116":1}}],["vn",{"2":{"117":1}}],["v2",{"2":{"117":1}}],["v1",{"2":{"117":1}}],["v",{"2":{"116":1,"127":2,"132":8,"133":2}}],["vertexes",{"2":{"124":2,"126":1,"128":3,"131":2,"132":2,"133":3}}],["vertex",{"2":{"116":2}}],["values",{"2":{"187":1,"189":2,"190":2,"212":1,"213":2,"214":3,"216":2,"217":1,"218":1,"219":1,"220":7}}],["value",{"0":{"154":1},"2":{"150":2,"154":7,"155":2,"164":7,"185":2,"187":1,"189":5,"212":3,"213":19,"216":6,"217":4,"218":4,"219":3,"220":36}}],["valueof",{"2":{"8":5}}],["val2",{"2":{"127":3}}],["val1",{"2":{"127":3}}],["val",{"2":{"126":3,"133":5}}],["var",{"2":{"2":1}}],["上一节点为",{"2":{"175":1,"183":1}}],["上文所说的线性探测存在的问题",{"2":{"142":1}}],["上图中的边是没有任何意义的",{"2":{"117":1}}],["上图分别表示",{"2":{"88":1}}],["上面的顶点",{"2":{"120":1}}],["上面的图就是一张无向图",{"2":{"117":1}}],["上面的结点",{"2":{"116":1}}],["广度优先算法会从指定的第一个顶点开始遍历图",{"2":{"132":1}}],["广度优先搜索算法我们使用的是队列",{"2":{"133":1}}],["广度优先搜索算法的思路",{"2":{"132":1}}],["广度优先搜索的代码",{"2":{"132":1}}],["广度优先搜索的实现",{"2":{"132":1}}],["广度优先搜索",{"0":{"132":1},"2":{"131":1,"132":1}}],["广州地铁图",{"2":{"116":1}}],["广泛应用于各种排序任务",{"2":{"55":1}}],["家谱",{"2":{"116":1}}],["图书各种摆放方式",{"2":{"244":1}}],["图书摆放要使得两个相关操作方便实现",{"2":{"244":1}}],["图解",{"2":{"132":1,"133":1}}],["图片解析",{"2":{"121":1,"122":1}}],["图的遍历算法的思想在于必须访问每个第一次访问的节点",{"2":{"131":1}}],["图的遍历",{"0":{"130":1},"1":{"131":1,"132":1,"133":1}}],["图的封装",{"0":{"123":1},"1":{"124":1,"125":1,"126":1,"127":1,"128":1,"129":1}}],["图的表示",{"0":{"119":1},"1":{"120":1,"121":1,"122":1}}],["图的术语也非常多",{"2":{"117":1}}],["图的术语",{"0":{"117":1}}],["图的概念",{"0":{"115":1},"1":{"116":1,"117":1,"118":1}}],["图通常有什么特点呢",{"2":{"116":1}}],["图长什么样子呢",{"2":{"116":1}}],["图是一种与树有些相似的数据结构",{"2":{"116":1}}],["图论是一个非常大的话题",{"2":{"115":1}}],["图论问题",{"2":{"32":1}}],["图也是一种非常常见的数据结构",{"2":{"115":1}}],["图",{"0":{"114":1},"1":{"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1,"122":1,"123":1,"124":1,"125":1,"126":1,"127":1,"128":1,"129":1,"130":1,"131":1,"132":1,"133":1},"2":{"245":1}}],["代码测试",{"0":{"113":1,"190":1,"214":1},"2":{"173":1}}],["代码实现栈结构",{"0":{"227":1}}],["代码实现",{"0":{"189":1,"195":1,"204":1,"207":1,"213":1,"230":1},"2":{"10":1,"11":1,"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":1,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1,"47":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"57":1,"58":1,"69":2,"71":1,"72":1,"73":1,"76":1,"77":1,"79":1,"80":1,"82":1,"154":1,"155":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1}}],["拼接为字符串",{"2":{"109":1,"110":1,"112":2,"174":1,"183":1}}],["~",{"2":{"105":1,"106":1,"107":1,"112":2,"162":3,"175":1,"183":1}}],["留个",{"2":{"105":1,"106":1,"112":1}}],["越界判断",{"2":{"105":1,"106":1,"107":1,"112":2,"176":1,"178":1,"179":1,"183":3}}],["巧妙之处",{"2":{"104":1,"105":1,"106":1,"112":2,"179":1,"183":1}}],["跟单向链表不同",{"2":{"104":1,"112":1}}],["继承",{"2":{"195":5}}],["继承单向链表",{"2":{"112":3}}],["继承单向链表的节点类",{"2":{"103":1}}],["继续比较下一个分组内的元素",{"2":{"53":1}}],["继续重复上述步骤",{"2":{"52":1}}],["继续拿",{"2":{"52":1}}],["该方法不会移除栈顶的元素",{"2":{"226":1}}],["该方法性能较好",{"2":{"162":1}}],["该函数就称为哈希函数",{"2":{"137":1}}],["该数组用于存储顶点连接的所有的边",{"2":{"126":1}}],["该整数作为数组的下标值",{"2":{"121":1}}],["该属性指向末尾的节点",{"2":{"103":1}}],["该属性用于指向上一个节点",{"2":{"103":1}}],["该算法通过重复将搜索范围缩小为一半来找到目标值",{"2":{"48":1}}],["类别中按照字母顺序",{"2":{"244":1}}],["类似于自动餐托盘",{"2":{"222":1}}],["类似于归并排序",{"2":{"18":1,"20":1}}],["类的",{"2":{"195":4,"203":1}}],["类添加判断质数的",{"2":{"163":1}}],["类继承",{"2":{"103":1}}],["类继承单向链表的",{"2":{"103":1}}],["类",{"2":{"101":1,"103":2,"124":1,"170":1,"195":1,"211":1}}],["属性指向链表的第一个节点",{"2":{"169":1}}],["属性",{"2":{"103":2}}],["属性类似",{"2":{"101":1,"170":1,"187":1,"203":1,"212":1,"226":1}}],["属性外",{"2":{"67":1}}],["update",{"0":{"108":1,"178":1},"2":{"101":1,"108":3,"112":3,"113":2,"170":1,"178":4,"183":2}}],["unionset",{"2":{"216":6,"220":6}}],["union",{"2":{"216":2,"220":2}}],["unique",{"2":{"2":4}}],["undefined",{"2":{"45":1,"154":1,"155":1,"156":1,"164":3,"189":2}}],["unshift",{"2":{"12":1,"62":1}}],["储存数据",{"2":{"100":1}}],["指向到当前的节点的",{"2":{"179":1,"183":1}}],["指向最后一个节点",{"2":{"173":1}}],["指向第一个节点",{"2":{"173":1}}],["指向新节点",{"2":{"173":1,"183":1}}],["指向链表的第一个节点",{"2":{"172":1,"183":1}}],["指向的新数组中",{"2":{"159":1}}],["指向它",{"2":{"159":1}}],["指向原来的",{"2":{"159":1}}],["指向自己的数量",{"2":{"122":1}}],["指向别人的数量",{"2":{"122":1}}],["指向",{"2":{"100":2,"175":1,"183":1}}],["指向后一个节点",{"2":{"100":1}}],["指向前一个节点",{"2":{"100":1}}],["指向节点的根",{"2":{"67":1}}],["指针指向最后一个节点",{"2":{"100":1}}],["指针指向第一个节点",{"2":{"100":1}}],["既可以实现哈希表的扩容",{"2":{"160":1}}],["既可以从头遍历到尾",{"2":{"99":1}}],["既从左到右比较交换",{"2":{"50":1}}],["经过哈希化得到",{"2":{"141":1}}],["经过哈希化",{"2":{"141":1}}],["经过哈希函数哈希化过后得到的下标值可能有重复",{"2":{"138":1}}],["经常会遇到需要回到上一个节点的情况",{"2":{"98":1}}],["经典算法真题",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1}}],["单词的下标值储存在数组中",{"2":{"136":1}}],["单词拆分",{"0":{"45":1}}],["单向链表的封装",{"0":{"171":1},"1":{"172":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"183":1}}],["单向链表类似于火车",{"2":{"169":1}}],["单向链表有一个比较明显的缺点",{"2":{"98":1}}],["单向链表",{"0":{"98":1,"165":1,"169":1},"1":{"166":1,"167":1,"168":1,"169":1,"170":2,"171":2,"172":2,"173":2,"174":2,"175":2,"176":2,"177":2,"178":2,"179":2,"180":2,"181":2,"182":2,"183":2}}],["单向链表和双向链表",{"0":{"97":1},"1":{"98":1,"99":1}}],["双向链表类继承单向链表类",{"2":{"103":1}}],["双向链表常见的操作",{"0":{"101":1}}],["双向链表的其他方法通过继承单向链表来实现",{"2":{"111":1}}],["双向链表的节点类",{"2":{"103":1}}],["双向链表的封装",{"0":{"102":1},"1":{"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1}}],["双向链表的最后一个节点的",{"2":{"100":1}}],["双向链表的第一个节点的",{"2":{"100":1}}],["双向链表不仅有",{"2":{"100":1}}],["双向链表结构",{"0":{"100":1}}],["双向链表缺点",{"2":{"99":1}}],["双向链表可以有效的解决单向链表存在的问题",{"2":{"99":1}}],["双向链表",{"0":{"96":1,"99":1},"1":{"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1}}],["双向冒泡排序",{"2":{"50":1}}],["取出",{"2":{"185":1}}],["取出所有数据",{"2":{"160":1,"164":1}}],["取出对应的",{"2":{"154":1,"164":1}}],["取出对应的数组",{"2":{"127":2}}],["取决于填装因子",{"2":{"143":1}}],["取余",{"2":{"141":1,"151":1}}],["取余后的结果作为新的参数",{"2":{"4":1,"5":1}}],["取数据的时候也十分方便",{"2":{"94":1}}],["序号",{"2":{"94":2}}],["序列问题",{"2":{"24":1}}],["缺点",{"2":{"235":3}}],["缺点是改变了元素的类型",{"2":{"1":1}}],["缺失了右子节点",{"2":{"92":1}}],["特点",{"2":{"199":1}}],["特殊之处在于里面的元素没有顺序",{"2":{"210":1}}],["特殊情况",{"2":{"192":1}}],["特殊的二叉树",{"0":{"90":1},"1":{"91":1,"92":1}}],["特别是在数据规模较大时",{"2":{"53":1}}],["特别是在解决递归问题时很常见",{"2":{"14":1}}],["满足需求",{"2":{"143":1}}],["满足",{"2":{"89":1}}],["满足的孩子数量",{"2":{"34":1}}],["深度为",{"2":{"89":1}}],["深度优先搜索算法的代码",{"2":{"133":1}}],["深度优先搜索算法的实现",{"2":{"133":1}}],["深度优先搜索算法将会从第一个指定的顶点开始遍历图",{"2":{"133":1}}],["深度优先搜索的思路",{"2":{"133":1}}],["深度优先搜索",{"0":{"133":1},"2":{"40":1,"131":1,"133":1}}],["^",{"2":{"89":1,"94":8}}],["^a",{"2":{"7":1}}],["空格为",{"2":{"136":1}}],["空间利用率高",{"2":{"235":1}}],["空间利用率不高",{"2":{"235":1}}],["空间",{"2":{"105":1,"106":1,"112":1}}],["空间复杂度及其稳定性的详细分析",{"2":{"56":1}}],["空间复杂度",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":2,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1}}],["空间复杂度为",{"2":{"10":1}}],["空的二叉树",{"2":{"88":1}}],["红黑树",{"2":{"84":1}}],["开放地址法的装填因子最大为",{"2":{"144":1}}],["开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项",{"2":{"140":1}}],["开放地址法",{"0":{"140":1},"1":{"141":1,"142":1,"143":1}}],["开发中比较少用",{"2":{"84":1}}],["开始数数",{"2":{"207":1}}],["开始探测",{"2":{"142":1}}],["开始向后一个一个来查找合适的位置来放置",{"2":{"141":1}}],["开始访问",{"2":{"133":2}}],["开始",{"2":{"52":1,"57":1,"142":1}}],["应该尽可能地等于右边的子孙节点的个数",{"2":{"84":1}}],["起码大部分是平衡的",{"2":{"84":1}}],["非完全二叉树需要转换成完全二叉树才能按照上面的方案存储",{"2":{"94":1}}],["非完全二叉树",{"2":{"94":1}}],["非平衡树",{"2":{"84":1}}],["非空",{"2":{"132":1}}],["非空右子树的所有键值大于其根节点的键值",{"2":{"65":1}}],["非空左子树的所有键值小于其根节点的键值",{"2":{"65":1}}],["会弹出栈被释放",{"2":{"223":1}}],["会发现只是术语就可以占据一个章节",{"2":{"117":1}}],["会严重影响二叉搜索树的性能",{"2":{"84":1}}],["会被提前",{"2":{"51":1}}],["组织数据的方式",{"2":{"243":1}}],["组成",{"2":{"84":1,"168":1}}],["组合结果",{"2":{"45":1}}],["组合总和",{"2":{"41":1}}],["组合问题",{"2":{"41":1}}],["平衡树",{"0":{"84":1}}],["平均需要",{"2":{"249":1}}],["平均探测长度呈线性增长",{"2":{"145":1}}],["平均探测长度呈指数形式增长",{"2":{"145":2}}],["平均探测长度以及平均存取时间",{"2":{"143":1}}],["平均空间复杂度",{"2":{"55":1}}],["平均时间复杂度",{"2":{"50":1,"51":1,"52":1,"54":1,"55":1,"56":1,"57":1,"58":1}}],["平均情况为",{"2":{"21":1}}],["完全探索一个顶点要求我们便查看该顶点的每一条边",{"2":{"131":1}}],["完全二叉树",{"0":{"92":1},"2":{"92":1,"94":1}}],["完美二叉树是特殊的完全二叉树",{"2":{"92":1}}],["完美二叉树",{"0":{"91":1},"2":{"91":1}}],["完整实现",{"0":{"83":1,"112":1,"183":1}}],["完成排序过程",{"2":{"53":1}}],["讨论这样的问题",{"2":{"81":1}}],["小一点点的节点",{"2":{"81":1,"82":1}}],["小于",{"2":{"78":1,"83":1}}],["小的元素",{"2":{"21":1}}],["小的值",{"2":{"12":1}}],["小的数字了",{"2":{"12":1}}],["存取时间就依赖后来的探测长度",{"2":{"143":1}}],["存储和组织数据的方式",{"2":{"243":1}}],["存储数据",{"2":{"239":1}}],["存储多个元素",{"2":{"167":1,"168":1}}],["存储元组",{"2":{"154":1,"164":1}}],["存储效率下降",{"2":{"145":1}}],["存储联系人和对应的电话号码",{"2":{"135":1}}],["存储边信息",{"2":{"124":1}}],["存储顶点",{"2":{"124":1}}],["存储所有的顶点",{"2":{"120":1}}],["存储在一个辅助数组中",{"2":{"58":1}}],["存在新的相邻顶点就去访问",{"2":{"131":1}}],["存在右子节点时",{"2":{"80":1}}],["存在左子节点时",{"2":{"80":1}}],["存在返回",{"2":{"77":1,"213":1,"220":1}}],["过程图解",{"2":{"72":1,"73":1}}],["父节点的设置只是为了方便指向子节点",{"2":{"240":1}}],["父节点",{"2":{"236":1}}],["父",{"2":{"72":1,"73":1,"74":1}}],["根左右",{"2":{"71":1,"74":1}}],["根据数据的组织方式有关",{"2":{"244":1}}],["根据每个父节点子节点数量的不同",{"2":{"238":1}}],["根据优先级放入到正确位置",{"2":{"193":1}}],["根据传入的元素",{"2":{"195":1}}],["根据传入的",{"2":{"163":1,"164":1}}],["根据装填因子的大小",{"2":{"156":1,"160":1,"163":1,"164":1}}],["根据索引值获取对应的",{"2":{"155":1,"156":1}}],["根据索引值取出",{"2":{"154":1}}],["根据",{"2":{"154":3,"155":2,"156":1,"164":3}}],["根据探测空白单元格位置方式的不同",{"2":{"140":1}}],["根据顶点",{"2":{"127":2}}],["根据不同情况删除元素",{"2":{"107":1,"112":1}}],["根据比较传入的两个节点",{"2":{"69":1}}],["根据累加统计次数",{"2":{"58":1}}],["根据统计信息对元素进行排序",{"2":{"58":1}}],["根据统计信息排序",{"2":{"58":2}}],["根据统计数组中的信息",{"2":{"58":1}}],["根据选择的步骤",{"2":{"31":1}}],["根据问题的限制条件",{"2":{"40":1}}],["根据问题的特性",{"2":{"31":1}}],["根据问题的要求",{"2":{"23":1}}],["根据子问题的定义",{"2":{"23":1}}],["往栈里面添加元素",{"2":{"227":1}}],["往往先被拿出去使用",{"2":{"222":1}}],["往集合中添加",{"2":{"213":1,"220":1}}],["往链表尾部追加数据",{"2":{"173":1,"183":1}}],["往哈希表里添加数据",{"2":{"154":1,"164":1}}],["往双向链表尾部追加一个新的元素",{"2":{"104":1,"112":1}}],["往左查找",{"2":{"78":1,"83":1}}],["往左边查找插入",{"2":{"69":1}}],["往右边查找插入",{"2":{"69":1}}],["依然没有找到",{"2":{"156":1}}],["依然递归调用",{"2":{"69":1}}],["依赖队列的先进先出的特点",{"2":{"132":1}}],["依赖队列操作数据",{"2":{"132":1}}],["依次对更高位进行排序",{"2":{"57":1}}],["依次遍历未排序部分的元素",{"2":{"52":1}}],["依次遍历排序后的区间",{"2":{"37":1}}],["依次把牌拿完",{"2":{"52":1}}],["依次类推",{"2":{"51":1,"143":1}}],["依次尝试用当前最小的饼干去满足当前最小的胃口",{"2":{"34":1}}],["情况",{"2":{"69":4,"80":6}}],["向下取整",{"2":{"230":1}}],["向一个栈插入新元素又称作进栈",{"2":{"222":1}}],["向集合添加一个新的项",{"2":{"212":1}}],["向队列尾部添加一个",{"2":{"203":1}}],["向字典中添加新元素",{"2":{"187":1}}],["向图中添加一些顶点",{"2":{"126":1}}],["向链表的特定位置插入一个新的项",{"2":{"170":1}}],["向链表的指定位置插入一个新元素",{"2":{"101":1}}],["向链表尾部添加一个新的项",{"2":{"170":1}}],["向链表尾部追加一个新元素",{"2":{"101":1}}],["向右查找",{"2":{"69":1}}],["向左查找",{"2":{"69":1}}],["向树中插入一个新的键",{"2":{"68":1}}],["首先让",{"2":{"173":1}}],["首先需要为",{"2":{"163":1}}],["首先创建哈希表类",{"2":{"153":1}}],["首先使用霍纳法则计算",{"2":{"151":1}}],["首先计算最内层括号内一次多项式的值",{"2":{"147":1}}],["首先依据以下二叉搜索树",{"2":{"81":1}}],["首先定义变量",{"2":{"78":1}}],["首先",{"2":{"71":1,"72":1,"73":1,"141":1,"154":1,"155":1,"156":1,"159":1}}],["首先根据传入的",{"2":{"69":1}}],["首先将区间按照结束时间",{"2":{"37":1}}],["键",{"2":{"68":2}}],["节点由于没有子节点",{"2":{"238":1}}],["节点需要",{"2":{"238":1}}],["节点上有乘客",{"2":{"169":1}}],["节点的层次为",{"2":{"236":1}}],["节点的层次",{"2":{"236":1}}],["节点的子树个数",{"2":{"236":1}}],["节点的度",{"2":{"236":1}}],["节点的",{"2":{"176":1,"183":1}}],["节点的后继",{"2":{"82":1}}],["节点的前驱",{"2":{"82":1}}],["节点的顺序来区分三种遍历方式",{"2":{"74":1}}],["节点",{"2":{"72":1,"73":1,"94":2,"179":1,"183":1,"239":3}}],["节点类",{"2":{"67":1}}],["节点中的键",{"2":{"67":1}}],["三个属性",{"2":{"67":1}}],["三数取中",{"2":{"55":2}}],["下面只讨论查找",{"2":{"82":1}}],["下面是一个二叉搜索树",{"2":{"66":1}}],["下一步与父节点",{"2":{"66":2}}],["下一步与根节点",{"2":{"66":1}}],["次就可以找到出问题的地方",{"2":{"249":1}}],["次幂的底数等",{"2":{"148":1}}],["次多项式",{"2":{"147":1}}],["次",{"2":{"66":6,"147":4,"249":2}}],["次比较",{"2":{"51":2}}],["树种所有节点中的最大层次是这棵树的深度",{"2":{"236":1}}],["树结构的组成方式类似于链表",{"2":{"238":1}}],["树结构的表示方式",{"0":{"237":1},"1":{"238":1,"239":1,"240":1}}],["树结构的优势",{"0":{"235":1}}],["树结构综合了上述三种结构的优点",{"2":{"235":1}}],["树结构",{"2":{"235":2}}],["树结构对比于数组",{"2":{"235":1}}],["树枝的最后是叶子",{"2":{"234":1}}],["树枝会继续分化成更小的树枝",{"2":{"234":1}}],["树干会发生分叉",{"2":{"234":1}}],["树一般都有一个根",{"2":{"234":1}}],["树一不满足条件",{"2":{"65":1}}],["树的深度",{"2":{"236":1}}],["树的所有节点中最大的度数",{"2":{"236":1}}],["树的度",{"2":{"236":1}}],["树的常用术语",{"0":{"236":1}}],["树的特点",{"0":{"234":1}}],["树的平衡性",{"2":{"84":1}}],["树有很多的其他术语",{"2":{"117":1}}],["树是图的一种",{"2":{"116":1}}],["树是平衡树",{"2":{"84":1}}],["树",{"0":{"232":1},"1":{"233":1,"234":1,"235":1,"236":1,"237":1,"238":1,"239":1,"240":1},"2":{"84":2,"235":1,"245":1}}],["树二和树三符合",{"2":{"65":1}}],["条件",{"2":{"65":3}}],["二分查找",{"2":{"249":1}}],["二分查找确定位置",{"2":{"244":1}}],["二分查找法",{"2":{"244":1}}],["二分搜索",{"0":{"48":1},"2":{"48":1}}],["二次探测和再哈希法性能相当",{"2":{"145":1}}],["二次探测和再哈希化的性能",{"2":{"145":1}}],["二次探测的步长是固定的",{"2":{"143":1}}],["二次探测存在的问题",{"2":{"142":1}}],["二次探测是在线性探测的基础上进行了优化",{"2":{"142":1}}],["二次探测法可以解决该问题",{"2":{"141":1}}],["二次探测",{"0":{"142":1},"2":{"140":1,"142":1}}],["二叉树最常见的存储方式为链表",{"2":{"95":1}}],["二叉树可以为空",{"2":{"87":1}}],["二叉树的数据存储",{"0":{"93":1},"1":{"94":1,"95":1}}],["二叉树的特性",{"0":{"89":1}}],["二叉树的五种形态",{"0":{"88":1}}],["二叉树的组成",{"0":{"87":1}}],["二叉树的概念",{"0":{"86":1}}],["二叉树的节点遍历顺序为",{"2":{"71":1}}],["二叉树",{"0":{"85":1},"1":{"86":1,"87":1,"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1,"95":1}}],["二叉搜索树中的数据分布就变得不均匀了",{"2":{"84":1}}],["二叉搜索树中除了定义",{"2":{"67":1}}],["二叉搜索树有四个最基本的属性",{"2":{"67":1}}],["二叉搜索树的缺陷",{"2":{"84":1}}],["二叉搜索树的常见操作",{"0":{"68":1},"1":{"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1,"83":1}}],["二叉搜索树的封装",{"0":{"67":1}}],["二叉搜索树的特点主要是较小的值总是保存在左节点上",{"2":{"65":1}}],["二叉搜索树应用举例",{"0":{"66":1}}],["二叉搜索树是一棵二叉树",{"2":{"65":1}}],["二叉搜索树",{"0":{"65":1},"1":{"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1,"83":1},"2":{"65":1}}],["修改节点",{"2":{"178":1,"183":1}}],["修改某个位置的元素",{"2":{"170":1}}],["修改添加元素的",{"2":{"163":1}}],["修改完",{"2":{"154":1,"164":1}}],["修改指定位置节点的",{"2":{"178":1,"183":1}}],["修改指定位置的节点",{"2":{"108":1,"112":1}}],["修改指定位置上的元素",{"2":{"101":1}}],["修改指定索引位置的几个元素",{"2":{"64":1}}],["修改指定索引位置的元素",{"2":{"64":1}}],["修改两个元素为",{"2":{"64":1}}],["修改索引",{"2":{"64":1}}],["修改元素",{"0":{"64":1}}],["里数据",{"2":{"154":1,"164":1}}],["里面的每一个元素入队",{"2":{"207":1}}],["里面的",{"2":{"154":1,"164":1}}],["里面节点的情况",{"2":{"107":1,"112":1}}],["里面包含每个节点中的",{"2":{"67":1}}],["里",{"2":{"59":1}}],["而",{"2":{"185":1}}],["而速度上升",{"2":{"145":1}}],["而线性探测就是从",{"2":{"141":1}}],["而是有进有出",{"2":{"224":1}}],["而是一条链条",{"2":{"139":1}}],["而是存储由经过取余操作后得到相同余数的数字组成的数组或链表",{"2":{"139":1}}],["而是适用于所有的二叉树",{"2":{"70":1}}],["而在数组中一个下标值只能储存一个数据",{"2":{"136":1}}],["而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值",{"2":{"135":1}}],["而临街矩阵会非常简单",{"2":{"122":1}}],["而且不能快速找出哈希表中最大值或最小值这些特殊值",{"2":{"235":1}}],["而且",{"2":{"139":1}}],["而且即使只有一个边",{"2":{"121":1}}],["而且有",{"2":{"100":1}}],["而不是取余运算",{"2":{"148":1}}],["而不是每个关键字探测步长都一样",{"2":{"143":1}}],["而不是两个",{"2":{"99":1}}],["而不是第",{"2":{"21":1}}],["而对于一棵非平衡二叉树来说",{"2":{"84":1}}],["而与元素的个数无关",{"2":{"58":1}}],["长度为",{"2":{"58":1}}],["累加统计次数",{"2":{"58":2}}],["累加函数",{"0":{"8":1}}],["创建新节点",{"2":{"173":1,"175":1,"183":2}}],["创建新的双向链表节点",{"2":{"105":1,"106":1,"112":1}}],["创建单向链表类",{"0":{"172":1}}],["创建哈希表类",{"0":{"153":1}}],["创建队列",{"2":{"132":1}}],["创建图类",{"0":{"124":1}}],["创建双向链表节点",{"2":{"104":1,"112":1}}],["创建双向链表类",{"0":{"103":1}}],["创建节点对象",{"2":{"69":1}}],["创建数组",{"2":{"60":2}}],["创建和初始化数组",{"0":{"60":1}}],["创建统计数组",{"2":{"58":1}}],["创建",{"2":{"57":1,"195":1}}],["创建一个新集合",{"2":{"216":1,"217":1,"218":1,"220":3}}],["创建一个新的容量更大的数组",{"2":{"159":1}}],["创建一个队列",{"2":{"132":1}}],["创建一个空数组",{"2":{"43":1,"44":1}}],["创建一个结果数组",{"2":{"43":1,"44":1}}],["创建一个数组",{"2":{"38":1}}],["创建一个",{"2":{"26":1,"29":1}}],["创建一个对象来存储每个单词的出现频率",{"2":{"9":1}}],["本例中没有",{"2":{"57":1}}],["右节点>的情况",{"2":{"80":1,"83":1}}],["右查找就能得到最值",{"2":{"76":1}}],["右指针",{"2":{"67":1}}],["右子树中的最小值",{"2":{"81":1}}],["右子树中比",{"2":{"81":1}}],["右子树本身也都是二叉搜索树",{"2":{"65":1}}],["右子节点的序号等于父节点序号",{"2":{"94":1}}],["右子节点",{"2":{"56":1}}],["右边的元素都大于主元",{"2":{"21":1}}],["左节点的引用和右节点的引用",{"2":{"95":1}}],["左节点>的情况",{"2":{"80":1,"83":1}}],["左子树中的最大值",{"2":{"81":1}}],["左子树中比",{"2":{"81":1}}],["左子节点的序号等于父节点序号",{"2":{"94":1}}],["左子节点",{"2":{"56":1}}],["左右根",{"2":{"73":1,"74":1}}],["左右两个数组的元素依次比较",{"2":{"54":1}}],["左根右",{"2":{"72":1,"74":1}}],["左指针",{"2":{"67":1}}],["左",{"2":{"65":1}}],["维护堆的性质",{"2":{"56":1}}],["维护当前能够到达的最远位置",{"2":{"36":1}}],["堆",{"2":{"245":1}}],["堆化函数",{"2":{"56":1}}],["堆排序由于其高效性和原地排序的特性",{"2":{"56":1}}],["堆排序不是稳定排序算法",{"2":{"56":1}}],["堆排序是一种原地排序算法",{"2":{"56":1}}],["堆排序的时间复杂度也是",{"2":{"56":1}}],["堆排序的时间复杂度为",{"2":{"56":1}}],["堆排序可以分为两个阶段",{"2":{"56":1}}],["堆排序",{"0":{"56":1},"2":{"56":1}}],["逐一从堆中取出元素",{"2":{"56":1}}],["逐步缩小增量值",{"2":{"53":1}}],["逐步缩小增量",{"2":{"53":1}}],["逐步计算每个子问题的值",{"2":{"23":1}}],["height",{"2":{"185":1}}],["head",{"2":{"100":1,"104":2,"105":7,"106":7,"107":5,"109":1,"112":15,"169":2,"172":3,"173":3,"174":1,"175":8,"176":1,"177":1,"178":1,"179":3,"183":21}}],["heapify",{"2":{"56":4}}],["heapsort",{"2":{"56":2}}],["heap",{"2":{"56":3,"245":1}}],["hasownproperty",{"2":{"189":1,"213":1,"220":1}}],["has",{"2":{"187":1,"189":4,"190":3,"212":1,"213":4,"214":3,"217":1,"218":1,"219":1,"220":7}}],["hash",{"2":{"245":1}}],["hashtable",{"2":{"153":2,"160":1,"163":1,"164":1}}],["hashfn",{"2":{"151":2,"154":1,"155":1,"156":1,"164":3}}],["hashmap",{"2":{"145":1,"148":1,"186":1}}],["hashcode",{"2":{"135":1,"148":1,"151":8}}],["handle",{"2":{"132":3,"133":6}}],["h",{"2":{"71":1,"89":1,"92":1,"94":1,"129":2,"132":1,"133":1,"236":2}}],["hibbard",{"2":{"53":2}}],["hillsort",{"2":{"53":2}}],["high",{"2":{"48":4}}],["避免了数据聚集带来的影响",{"2":{"142":1}}],["避免最坏情况的发生",{"2":{"55":1}}],["避免重复探索",{"2":{"40":1}}],["避免重复计算",{"2":{"22":1,"45":2}}],["期望时间复杂度为",{"2":{"55":1}}],["基于链表实现",{"2":{"202":1}}],["基于数组实现",{"2":{"202":1}}],["基于栈",{"2":{"131":1}}],["基于队列",{"2":{"131":1}}],["基于分治法",{"2":{"55":1}}],["基数排序适用于处理整数或字符串等具有固定位数的元素集合",{"2":{"57":1}}],["基数排序适用于元素都是整数的数组",{"2":{"57":1}}],["基数排序是一种稳定排序算法",{"2":{"57":1}}],["基数排序的空间复杂度取决于辅助存储空间的使用",{"2":{"57":1}}],["基数排序的平均时间复杂度也为",{"2":{"57":1}}],["基数排序的时间复杂度主要取决于关键字的位数和元素个数",{"2":{"57":1}}],["基数排序的时间复杂度仍然为",{"2":{"57":1}}],["基数排序的时间复杂度为",{"2":{"57":1}}],["基数排序",{"0":{"57":1},"2":{"57":1}}],["基准",{"2":{"55":1}}],["基本可以瞬间查找到想要的元素",{"2":{"135":1}}],["基本思想是将待排序的元素按照位数进行分组",{"2":{"57":1}}],["基本思想是采用辗转相除的方法",{"2":{"4":1}}],["基本情况",{"2":{"18":1,"19":1,"20":1}}],["基本步骤",{"0":{"15":1,"23":1,"31":1,"40":1}}],["快速计算",{"0":{"147":1}}],["快速的计算",{"2":{"146":1}}],["快速排序因其高效性和较好的平均性能",{"2":{"55":1}}],["快速排序不是稳定排序",{"2":{"55":1}}],["快速排序的空间复杂度主要取决于递归调用栈的深度",{"2":{"55":1}}],["快速排序的平均性能通常很好",{"2":{"55":1}}],["快速排序",{"0":{"55":1},"2":{"55":1}}],["快速选择算法是快速排序的变种",{"2":{"21":1}}],["尤其是在需要稳定排序的情况下",{"2":{"54":1}}],["还能提高代码的可读性和可维护性",{"2":{"250":1}}],["还应该在合适的时候能够取出来",{"2":{"244":1}}],["还应定义一个节点内部类",{"2":{"67":1}}],["还有其他的方法",{"2":{"212":1}}],["还有层序遍历",{"2":{"70":1}}],["还包含优先级",{"2":{"193":1}}],["还需要考虑递归调用的栈空间",{"2":{"54":1}}],["还是大数据处理",{"2":{"250":1}}],["还是中间到杭州的位置",{"2":{"249":1}}],["还是",{"2":{"29":1}}],["截取右半部分",{"2":{"54":1}}],["截取左半部分",{"2":{"54":1}}],["更易于理解和修改",{"2":{"250":1}}],["更可管理的问题",{"2":{"250":1}}],["更多",{"2":{"244":1}}],["更优的增量序列",{"2":{"53":1}}],["更新链表长度",{"2":{"175":1,"179":1,"183":2}}],["更新缓存",{"2":{"45":2}}],["更新结束时间",{"2":{"37":1}}],["更新能到达的最远位置",{"2":{"36":1}}],["更新最远可达位置",{"2":{"36":1}}],["更新指针",{"2":{"34":1}}],["更新",{"2":{"29":1,"36":2}}],["更新前一个数",{"2":{"10":1}}],["更新前前一个数",{"2":{"10":1}}],["希尔增量序列",{"2":{"53":1}}],["希尔排序由于其高效性和相对简单的实现",{"2":{"53":1}}],["希尔排序不是稳定排序",{"2":{"53":1}}],["希尔排序是一种原地排序算法",{"2":{"53":1}}],["希尔排序的时间复杂度较为复杂",{"2":{"53":1}}],["希尔排序",{"0":{"53":1},"2":{"53":1}}],["常见的编程语言都有直接或间接的使用上述常见的数据结构",{"2":{"245":1}}],["常见的数据结构",{"0":{"245":1}}],["常见的情况是",{"2":{"159":1}}],["常见的二叉树存储方式为数组和链表",{"2":{"93":1}}],["常见的平衡树",{"2":{"84":1}}],["常见的三种二叉树遍历方式为",{"2":{"70":1}}],["常见的增量序列有希尔增量序列",{"2":{"53":1}}],["常用于需要稳定且较高性能的排序任务",{"2":{"56":1}}],["常用于处理大规模数据集",{"2":{"54":1}}],["常用于对小型数组进行排序或在其他更复杂的排序算法",{"2":{"52":1}}],["常用于教学和小规模数据集的排序",{"2":{"50":1}}],["与",{"2":{"136":1}}],["与数组的",{"2":{"101":1,"170":1,"187":1,"203":1,"212":1}}],["与先序遍历原理相同",{"2":{"72":1,"73":1}}],["与向左查找类似",{"2":{"69":1}}],["与根节点",{"2":{"66":1}}],["与元素的大小范围无关",{"2":{"57":1}}],["与所选的增量序列",{"2":{"53":1}}],["与第一个",{"2":{"51":1}}],["与第一个元素",{"2":{"51":1}}],["与第二个元素",{"2":{"51":1}}],["相等",{"2":{"154":1,"164":1}}],["相等的元素可以放在任一侧",{"2":{"55":1}}],["相连",{"2":{"132":1}}],["相邻顶点",{"2":{"117":1}}],["相邻两个孩子评分更高的孩子会获得更多的糖果",{"2":{"38":1}}],["相处腾出",{"2":{"105":1,"106":1,"112":1}}],["相对地",{"2":{"222":1}}],["相对数组效率高很多",{"2":{"168":1}}],["相对于双向链表的便利性而言",{"2":{"99":1}}],["相对于单向链表",{"2":{"99":1}}],["相对较大的值总是保存在右节点上",{"2":{"65":1}}],["相当于删除了当前节点",{"2":{"179":1,"183":1}}],["相当于编写了一个链表",{"2":{"84":1}}],["相当于将插入排序的",{"2":{"53":1}}],["相信你已经发现其中的规律了",{"2":{"81":1}}],["相同",{"2":{"141":1}}],["相同元素的相对顺序不会改变",{"2":{"58":1}}],["相同位数的元素根据其原始顺序进行排序",{"2":{"57":1}}],["间隔",{"2":{"53":1}}],["增强面试表现",{"2":{"250":1}}],["增量序列等",{"2":{"53":1}}],["增量序列",{"2":{"53":3}}],["增量序列逐渐缩小",{"2":{"53":1}}],["增加和删除数据时比较麻烦",{"2":{"135":1}}],["增加",{"2":{"37":1}}],["缩小增量排序",{"2":{"53":1}}],["归并排序由于其稳定性和",{"2":{"54":1}}],["归并排序是一种稳定排序算法",{"2":{"54":1}}],["归并排序是一种稳定的排序算法",{"2":{"19":1}}],["归并排序的空间复杂度为",{"2":{"54":1}}],["归并排序在最优",{"2":{"54":1}}],["归并排序",{"0":{"54":1},"2":{"52":1,"54":1}}],["保存余数",{"2":{"230":1}}],["保存旧的",{"2":{"160":1,"164":1}}],["保存要找到的后续",{"2":{"82":1,"83":1}}],["保存",{"2":{"78":1}}],["保存当前元素",{"2":{"53":1}}],["保存当前需要排序的元素",{"2":{"52":1}}],["保证左边孩子评分高的糖果更多",{"2":{"38":1}}],["保证右边孩子评分高的糖果更多",{"2":{"38":1}}],["位底",{"2":{"249":1}}],["位置开始一个一个位置地查找数据",{"2":{"141":1}}],["位置",{"2":{"141":1}}],["位置插入元素",{"2":{"108":1,"112":1}}],["位置的节点",{"2":{"108":1,"112":1}}],["位置中间插入",{"2":{"105":1,"106":1,"112":1}}],["位置起的",{"2":{"63":1}}],["位置为默认的已排序的序列",{"2":{"52":1}}],["位顾客",{"2":{"35":1}}],["位顾客那里",{"2":{"35":4}}],["位顾客付的账",{"2":{"35":1}}],["已有个数",{"2":{"164":1}}],["已排序部分的长度增加",{"2":{"52":1}}],["已经有重复判断",{"2":{"216":1,"220":1}}],["已经大于或等于数组的最后一个下标",{"2":{"36":1}}],["已经在最后一个下标",{"2":{"36":1}}],["插入或删除的效率都不高",{"2":{"235":1}}],["插入或修改操作",{"2":{"150":1}}],["插入节点",{"2":{"175":2,"183":2}}],["插入和删除值都只需接近常量的时间",{"2":{"135":1}}],["插入元素",{"2":{"105":1,"106":1,"112":1}}],["插入元素到正确的位置",{"2":{"53":1}}],["插入数据",{"0":{"69":1},"2":{"69":1}}],["插入",{"2":{"62":1,"84":1,"135":1,"141":1,"244":1}}],["插入到已排序部分",{"2":{"52":1}}],["插入排序在处理大规模数据集时效率较低",{"2":{"52":1}}],["插入排序由于其简单性和对小规模数据集的高效性",{"2":{"52":1}}],["插入排序会将待插入的元素放在相等元素的后面",{"2":{"52":1}}],["插入排序是一种稳定排序算法",{"2":{"52":1}}],["插入排序是一种原地排序算法",{"2":{"52":1}}],["插入排序的比较和移动操作次数与输入数据的初始排列状态有关",{"2":{"52":1}}],["插入排序需要进行大量的比较和移动操作",{"2":{"52":1}}],["插入排序每次只需要比较一次即可确定元素的位置",{"2":{"52":1}}],["插入排序类似扑克牌思想",{"2":{"52":1}}],["插入排序",{"0":{"52":1},"2":{"52":1}}],["就将新插入的元素插入到最后",{"2":{"195":1}}],["就执行后续操作",{"2":{"154":1}}],["就修改该值",{"2":{"154":1}}],["就知道要继续查找",{"2":{"141":1}}],["就停止",{"2":{"141":1}}],["就直接返回",{"2":{"141":1}}],["就像一次访问图的一层",{"2":{"132":1}}],["就需要重写继承自",{"2":{"101":1,"170":1}}],["就会越来越长",{"2":{"159":1}}],["就会变成深度过大的搜索二叉树",{"2":{"84":1}}],["就会造成二叉搜索树的深度过大",{"2":{"84":1}}],["就是",{"2":{"236":1}}],["就是聚集",{"2":{"141":1}}],["就是用幂的连乘来表示它的唯一性的",{"2":{"136":1}}],["就是先宽后深的访问顶点",{"2":{"132":1}}],["就是拿出二维数组的每一项",{"2":{"128":1}}],["就是一个集合类",{"2":{"211":1}}],["就是一个边",{"2":{"117":1}}],["就是一条路径",{"2":{"117":1}}],["就是节点",{"2":{"82":2}}],["就是最大公约数",{"2":{"4":1,"5":1}}],["就向右查找",{"2":{"77":1}}],["就依次往后移动位置",{"2":{"52":1}}],["就插在中间",{"2":{"52":1}}],["可通过下标值取出信息",{"2":{"185":1}}],["可分为三种方法",{"2":{"140":1}}],["可知节点",{"2":{"81":6}}],["可能是最常用的数据结构",{"2":{"167":1}}],["可能是中间数",{"2":{"52":1}}],["可能会破坏相同元素的相对顺序",{"2":{"56":1}}],["可以显著提升程序的性能和效率",{"2":{"250":1}}],["可以帮助你编写更高效的代码",{"2":{"250":1}}],["可以更深入地理解计算机的工作原理和计算理论",{"2":{"250":1}}],["可以更容易理解和学习这些高级技术",{"2":{"250":1}}],["可以教会你如何系统地思考和解决复杂问题",{"2":{"250":1}}],["可以快速定位到处问题的地方",{"2":{"249":1}}],["可以在数组的任意位置插入和删除元素",{"2":{"221":1}}],["可以在某些特定情况下提升效率",{"2":{"50":1}}],["可以直接使用",{"2":{"207":1}}],["可以直接到达最后一个下标",{"2":{"36":1}}],["可以重复",{"2":{"185":1}}],["可以充分利用计算机的内存",{"2":{"168":1}}],["可以用于存储一系列的元素",{"2":{"166":1}}],["可以大于",{"2":{"159":1}}],["可以看到随着装填因子的增加",{"2":{"145":1}}],["可以看到",{"2":{"145":1}}],["可以指定顶点和顶点之间的边",{"2":{"127":1}}],["可以另外创建一个数组",{"2":{"120":1}}],["可以轻松到达下一个节点",{"2":{"98":1}}],["可以通过下标值访问",{"2":{"235":1}}],["可以通过取余操作来实现",{"2":{"136":1}}],["可以通过",{"2":{"79":2,"185":1}}],["可以通过二分查找",{"2":{"66":1}}],["可以通过分解质因数并计算两数的最大公约数",{"2":{"5":1}}],["可以为空",{"2":{"65":1}}],["可以有效地改善其性能",{"2":{"55":1}}],["可以记录下每轮排序中最后一次交换的位置",{"2":{"50":1}}],["可以提前结束排序过程",{"2":{"50":1}}],["可以观察到最后一次交换发生的位置之后的元素已经是有序的",{"2":{"50":1}}],["可以先跳",{"2":{"36":1}}],["可以偷窃到的最高金额",{"2":{"28":1}}],["可以从第",{"2":{"26":1}}],["放入栈中",{"2":{"230":1}}],["放左边",{"2":{"52":1}}],["放哪里无所谓",{"2":{"52":1}}],["想象在打扑克牌",{"2":{"52":1}}],["想要给你的孩子们一些小饼干",{"2":{"34":1}}],["适用于待排序元素都属于一个有限范围的整数",{"2":{"58":1}}],["适用于对内存空间要求较高但对时间效率要求不高的场景",{"2":{"51":1}}],["适用于有序数组",{"2":{"48":1}}],["导致顺序改变",{"2":{"51":1}}],["虽然效率不一定都比它们高",{"2":{"235":1}}],["虽然可以轻松地到达下一个节点",{"2":{"168":1}}],["虽然这种情况出现的概率较线性探测的聚集要小",{"2":{"142":1}}],["虽然这个例子没有改变相同元素的相对顺序",{"2":{"51":1}}],["虽然取余操作得到的结构也有可能重复",{"2":{"136":1}}],["虽然该方式可以保证字符的唯一性",{"2":{"136":1}}],["虽然堆排序的实现相对复杂",{"2":{"56":1}}],["虽然归并排序的空间复杂度较高",{"2":{"54":1}}],["虽然你有两块小饼干",{"2":{"34":1}}],["元素的相对顺序可能会被改变",{"2":{"55":1}}],["元素",{"2":{"55":1}}],["元素可能会跨越多个位置进行交换",{"2":{"53":1}}],["元素并将其与未排序部分的第一个元素交换时",{"2":{"51":1}}],["元素与未排序部分的第一个元素交换位置",{"2":{"51":1}}],["同样会影响性能",{"2":{"142":1}}],["同样通过一些特性来保持树的平衡",{"2":{"84":1}}],["同样有两种方式",{"2":{"81":1}}],["同样是",{"2":{"66":1}}],["同样地",{"2":{"51":1}}],["同时也弥补了它们存在的缺点",{"2":{"235":1}}],["同时返回被移除的元素",{"2":{"226":1}}],["同时使用缓存来存储已经计算过的结果",{"2":{"45":1}}],["同时更新",{"2":{"37":1}}],["同时确保左边的元素都小于等于主元",{"2":{"21":1}}],["设置当前循环最小元素索引",{"2":{"51":1}}],["外层循环",{"2":{"51":1}}],["未排序部分的长度减少",{"2":{"51":1,"52":1}}],["稳定性",{"2":{"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1}}],["稳定性等指标来衡量",{"2":{"49":1}}],["趟排序",{"2":{"50":1}}],["又从右到左比较交换",{"2":{"50":1}}],["鸡尾酒排序",{"2":{"50":1}}],["发生了交换",{"2":{"50":1}}],["记录最后一次交换的位置",{"2":{"50":1}}],["记录最后一次交换元素的位置",{"2":{"50":1}}],["记录已经探索过的路径",{"2":{"40":1}}],["若装填因子",{"2":{"154":1,"160":1,"163":1,"164":1}}],["若使用数组",{"2":{"135":2}}],["若二叉树不为空",{"2":{"87":1}}],["若用",{"2":{"81":1}}],["若没找到",{"2":{"78":1}}],["若",{"2":{"77":2,"79":2,"89":1,"236":1}}],["若存在根节点则重新定义一个内部方法",{"2":{"69":1}}],["若想在其中查找数据",{"2":{"66":1}}],["若当前元素大于其后面的元素",{"2":{"50":1}}],["若本轮未发生交换",{"2":{"50":2}}],["若不满足条件",{"2":{"50":1}}],["比",{"2":{"82":2,"117":1}}],["比第一张小",{"2":{"52":1}}],["比如上图的",{"2":{"236":1}}],["比如上图中",{"2":{"117":1}}],["比如节点",{"2":{"236":1,"238":1}}],["比如树结构中数据都是有序的",{"2":{"235":1}}],["比如树三中节点",{"2":{"65":2}}],["比如函数",{"2":{"223":1}}],["比如在电影院",{"2":{"199":1}}],["比如保存一个人的信息",{"2":{"185":1}}],["比如原长度",{"2":{"163":1}}],["比如原二叉搜索树由",{"2":{"84":1}}],["比如从下标值",{"2":{"142":1}}],["比如从下表值",{"2":{"142":1}}],["比如从小到大",{"2":{"135":1}}],["比如插入",{"2":{"141":1}}],["比如设置为",{"2":{"141":1}}],["比如不存在",{"2":{"136":1}}],["比如我们要表示和",{"2":{"122":1}}],["比如村庄的名字",{"2":{"120":1}}],["比如距离或者花费的时间或者票价",{"2":{"117":1}}],["比如地铁站中两个站点之间的直接连线",{"2":{"117":1}}],["比如地铁站中某个站",{"2":{"117":1}}],["比如下图中的节点",{"2":{"82":2}}],["比如",{"2":{"50":1,"116":2,"117":7,"121":1,"136":3,"142":1,"145":1,"148":1,"159":1,"167":1,"186":1,"236":1,"239":1}}],["比较好的二叉搜索树",{"2":{"84":1}}],["比较",{"2":{"66":3}}],["比较相邻元素",{"2":{"50":1}}],["比较相邻的两个元素",{"2":{"50":1}}],["比较清理后的字符串和它的反转版",{"2":{"7":1}}],["到",{"2":{"57":2,"160":1,"164":1}}],["到顶端",{"2":{"50":1}}],["到达下标",{"2":{"36":1}}],["到达第",{"2":{"26":2}}],["冒泡",{"2":{"50":1}}],["冒泡排序由于其简单易懂的特性",{"2":{"50":1}}],["冒泡排序是一种稳定排序算法",{"2":{"50":1}}],["冒泡排序是一种原地排序算法",{"2":{"50":1}}],["冒泡排序的比较和交换操作的次数与输入数据的初始排列状态有关",{"2":{"50":1}}],["冒泡排序可以通过设置一个标志变量来检测是否发生了交换操作",{"2":{"50":1}}],["冒泡排序",{"0":{"50":1},"2":{"50":1}}],["它具备以下性质",{"2":{"235":1}}],["它是把栈顶元素删除掉",{"2":{"222":1}}],["它是把新元素放到栈顶元素的上面",{"2":{"222":1}}],["它们的性能比线性探测略好",{"2":{"145":1}}],["它们不会交换位置",{"2":{"50":1}}],["它存在更多优势",{"2":{"135":1}}],["它必须构造一个",{"2":{"122":1}}],["它根据关键字的每个位的值来排序",{"2":{"57":1}}],["它只需要常数级别的额外空间来存储堆的数据结构",{"2":{"56":1}}],["它通过在每个节点多存储一个额外的数据来保持树的平衡",{"2":{"84":1}}],["它通过选择一个",{"2":{"55":1}}],["它通过对插入排序的改进",{"2":{"53":1}}],["它的数据应该是左右均匀分布的",{"2":{"84":1}}],["它的时间复杂度相对较低",{"2":{"57":1}}],["它的基本思想是通过定义一个间隔序列",{"2":{"53":1}}],["它的基本思想是将待排序数组分成已排序和未排序两部分",{"2":{"52":1}}],["它的基本思想是在未排序数组中找到最小",{"2":{"51":1}}],["它的交换次数较少",{"2":{"51":1}}],["它在排序过程中只需要常数级的额外空间",{"2":{"50":1,"52":1}}],["它重复地遍历待排序数组",{"2":{"50":1}}],["它按顺序检查列表中的每个元素",{"2":{"47":1}}],["调整搜索范围的最高索引",{"2":{"48":1}}],["调整搜索范围的最低索引",{"2":{"48":1}}],["调用",{"2":{"223":2}}],["调用深度优先算法",{"2":{"133":1}}],["调用广度优先算法",{"2":{"132":1}}],["调用归并排序函数",{"2":{"19":1}}],["调用递归函数",{"2":{"18":1}}],["目标元素未找到",{"2":{"48":1}}],["目标元素在左半部分",{"2":{"48":1}}],["目标元素在右半部分",{"2":{"48":1}}],["目标是找到第",{"2":{"21":1}}],["顺序搜索",{"0":{"47":1},"2":{"47":1}}],["缓存查询",{"2":{"45":1}}],["处理",{"2":{"201":1}}],["处理完后设置为访问过点",{"2":{"133":1}}],["处理当前子字符串",{"2":{"45":1}}],["处理账单",{"2":{"35":1}}],["要根据方向来定",{"2":{"117":1}}],["要解决这个问题",{"2":{"45":1}}],["要将一个整数数组进行排序",{"2":{"19":1}}],["词典中的同一个单词可能在分段中被重复使用多次",{"2":{"45":1}}],["添加一个新元素到栈顶位置",{"2":{"226":1}}],["添加一个元素到数组的最后位置",{"2":{"62":1}}],["添加到新集合",{"2":{"216":2,"220":2}}],["添加到堆顶",{"2":{"12":1}}],["添加基本属性",{"2":{"172":1}}],["添加边需要传入两个顶点",{"2":{"127":2}}],["添加边",{"0":{"127":1},"2":{"127":1,"129":1}}],["添加点的关系",{"2":{"126":1}}],["添加点",{"2":{"126":1}}],["添加顶点",{"0":{"126":1},"2":{"126":1,"129":1}}],["添加元素",{"0":{"62":1}}],["添加标志位",{"2":{"50":1}}],["添加当前路径到结果集",{"2":{"44":2}}],["种情况",{"2":{"78":1}}],["种排列",{"2":{"43":1}}],["种跳法",{"2":{"11":2}}],["总的来说",{"2":{"235":1}}],["总个数",{"2":{"164":1}}],["总数据项",{"2":{"144":1}}],["总数为",{"2":{"89":2}}],["总结",{"0":{"74":1},"2":{"65":1,"139":1}}],["总比较次数为",{"2":{"50":1}}],["总共有",{"2":{"43":1,"44":1}}],["总会到达下标为",{"2":{"36":1}}],["参数为当前子字符串",{"2":{"45":1}}],["参数为当前路径",{"2":{"43":1,"44":1}}],["参数",{"2":{"43":1,"44":1}}],["构建最大堆",{"2":{"56":2}}],["构建初始堆和在堆上进行排序操作",{"2":{"56":1}}],["构建子集",{"2":{"44":1}}],["构建排列",{"2":{"43":1}}],["构造出问题的解",{"2":{"31":1}}],["构造解",{"2":{"31":1}}],["接着",{"2":{"154":1,"155":1,"156":1}}],["接着原路回退并探索下一条路径",{"2":{"133":1}}],["接着在剩余的未排序部分中继续寻找最小",{"2":{"51":1}}],["接着偷窃",{"2":{"28":1}}],["接收一些输入",{"2":{"247":1}}],["接收字符串",{"2":{"45":1}}],["接收输入数组",{"2":{"43":1,"44":1}}],["表明我们找到了一种排列",{"2":{"43":1}}],["表示就是后进入的元素",{"2":{"222":1}}],["表示新插入后是第二个节点",{"2":{"175":1,"183":1}}],["表示新插入后是第一个节点",{"2":{"175":1,"183":1}}],["表示时间复杂度的话",{"2":{"147":1}}],["表示该顶点被访问过且被完全探索过",{"2":{"131":1}}],["表示该顶点被访问过",{"2":{"131":1}}],["表示该顶点还没有被访问",{"2":{"131":1}}],["表示有连线",{"2":{"121":1}}],["表示没有连线",{"2":{"121":1}}],["表示图中的一个结点",{"2":{"117":1}}],["表示边的集合",{"2":{"116":1}}],["表示顶点的集合",{"2":{"116":1}}],["表示叶子节点的个数",{"2":{"89":1}}],["表示需要删除的节点",{"2":{"81":1}}],["表示插入数据",{"2":{"62":1}}],["表示小于等于每个元素的个数",{"2":{"58":1}}],["表示起始索引",{"2":{"44":1}}],["表示当前剩余的可选择数字",{"2":{"43":1}}],["表示当前路径",{"2":{"43":1,"44":1}}],["表示当前能够到达的最远位置",{"2":{"36":3}}],["表示每个孩子至少有一个糖果",{"2":{"38":1}}],["表示每个孩子的评分",{"2":{"38":1}}],["表示不能到达该位置",{"2":{"36":1}}],["表示不同面额的硬币",{"2":{"29":1}}],["表示无法凑成该金额",{"2":{"29":1}}],["表示从金额",{"2":{"29":1}}],["表示还没有计算出结果",{"2":{"29":1}}],["表示凑成金额",{"2":{"29":1}}],["表示总金额",{"2":{"29":1}}],["表示到达第",{"2":{"28":1}}],["表示在",{"2":{"27":1}}],["表示以",{"2":{"27":1}}],["表示达到第",{"2":{"26":2}}],["表示",{"2":{"5":2,"121":1,"235":1}}],["全排列",{"0":{"43":1}}],["皇后问题等",{"2":{"41":1}}],["搜索",{"2":{"65":1}}],["搜索范围的最高索引",{"2":{"48":1}}],["搜索范围的最低索引",{"2":{"48":1}}],["搜索问题",{"2":{"41":1}}],["搜索算法简单来说就是用于找出数组中某个元素的下标",{"2":{"46":1}}],["搜索算法",{"0":{"46":1},"1":{"47":1,"48":1},"2":{"6":1,"16":1}}],["排队",{"2":{"199":1}}],["排队中",{"2":{"192":1}}],["排列问题",{"2":{"41":1}}],["排序完成",{"2":{"57":1}}],["排序",{"2":{"34":1,"37":2,"54":1,"56":1}}],["排序数组",{"0":{"19":1}}],["排序算法的性能通常通过其时间复杂度",{"2":{"49":1}}],["排序算法用于将一组乱序的元素按照升序或降序的顺序重新排列",{"2":{"49":1}}],["排序算法",{"0":{"49":1},"1":{"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1},"2":{"16":1}}],["排序后再取最小的",{"2":{"12":1}}],["撤销上一步选择",{"2":{"43":2,"44":3}}],["撤销当前节点的选择",{"2":{"40":1}}],["撤销选择",{"2":{"40":1}}],["做出一个选择",{"2":{"40":1}}],["做出选择",{"2":{"40":1}}],["采用的是链地址法",{"2":{"148":1}}],["采用邻接矩阵法",{"2":{"126":1}}],["采用深度优先搜索的方式探索决策树的所有分支",{"2":{"40":1}}],["采取局部最优的选择",{"2":{"31":1}}],["回顾邻接表的实现方式",{"2":{"126":1}}],["回路",{"2":{"117":1}}],["回溯",{"2":{"43":2,"44":3}}],["回溯函数",{"2":{"43":1,"44":1}}],["回溯算法的应用",{"0":{"42":1},"1":{"43":1,"44":1,"45":1}}],["回溯算法通常用于以下几类问题",{"2":{"41":1}}],["回溯算法通常通过深度优先搜索的方式实现",{"2":{"39":1}}],["回溯算法会回退到上一步",{"2":{"39":1}}],["回溯算法是一种通过逐步构建解决方案的方法",{"2":{"39":1}}],["回溯算法",{"0":{"39":1},"1":{"40":1,"41":1,"42":1,"43":1,"44":1,"45":1}}],["回到上一层继续探索其他分支",{"2":{"40":1}}],["回文字符串是一个正读和反读都一样的字符串",{"2":{"7":1}}],["再从中间位置分开",{"2":{"249":1}}],["再从右到左扫描数组",{"2":{"38":1}}],["再二分查找",{"2":{"244":1}}],["再逐步实现单向链表的常用方法",{"2":{"172":1}}],["再进行其他方法的实现",{"2":{"153":1}}],["再做一次哈希化",{"2":{"143":1}}],["再哈希法的做法为",{"2":{"143":1}}],["再哈希法",{"0":{"143":1},"2":{"140":1}}],["再通过下标值查找效率就非常高了",{"2":{"135":1}}],["再根据工号查找该员工的完整信息呢",{"2":{"135":1}}],["再取出其中的内容",{"2":{"122":1}}],["再了解",{"2":{"117":1}}],["再合并结果",{"2":{"54":1}}],["再拿起来一张",{"2":{"52":1}}],["再使用",{"2":{"35":1}}],["颗糖果",{"2":{"38":3}}],["困难",{"2":{"38":1,"45":1}}],["贪心选择",{"2":{"37":1}}],["贪心算法的应用",{"0":{"33":1},"1":{"34":1,"35":1,"36":1,"37":1,"38":1}}],["贪心算法的核心是贪心选择性质",{"2":{"30":1}}],["贪心算法通常用于以下几类问题",{"2":{"32":1}}],["贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择",{"2":{"30":1}}],["贪心算法",{"0":{"30":1},"1":{"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1}}],["剩下的区间没有重叠",{"2":{"37":1}}],["后进先出",{"2":{"222":1}}],["后面会区分",{"2":{"117":1}}],["后面每项的值等于前面两项的和",{"2":{"11":1}}],["后继的情况",{"2":{"82":1}}],["后继",{"0":{"82":1}}],["后原树二叉树仍为二叉搜索树的前提下",{"2":{"81":1}}],["后原二叉树仍为二叉搜索树的前提下",{"2":{"81":2}}],["后分",{"2":{"78":1}}],["后续遍历最后遍历根节点",{"2":{"74":1}}],["后序遍历",{"0":{"73":1},"2":{"70":1,"73":1}}],["后",{"2":{"37":1,"69":1,"155":1}}],["说明数组已经有序",{"2":{"50":1}}],["说明数组已经是有序的",{"2":{"50":1}}],["说明这个区间可以保留",{"2":{"37":2}}],["说明不能到达当前位置",{"2":{"36":1}}],["说明最小的",{"2":{"12":1}}],["但需要注意的是",{"2":{"141":1}}],["但它神奇之处在于对下标值的一种变换",{"2":{"135":1}}],["但它的时间复杂度稳定在",{"2":{"56":1}}],["但并未被探索过",{"2":{"131":2}}],["但回到前一个节点很难",{"2":{"98":1}}],["但在",{"2":{"59":1}}],["但在某些情况下",{"2":{"51":1}}],["但其分治策略使其在许多应用中表现出色",{"2":{"54":1}}],["但总的额外空间仍然是",{"2":{"54":1}}],["但总体而言",{"2":{"52":1}}],["但总体而言其时间复杂度仍为",{"2":{"50":1}}],["但通常在",{"2":{"53":1}}],["但由于其较低的效率",{"2":{"50":1}}],["但该下标的最大跳跃长度是",{"2":{"36":1}}],["但是好的算法对比于差的算法",{"2":{"249":1}}],["但是如果线段在另一头",{"2":{"249":1}}],["但是如果是较长的字符",{"2":{"136":1}}],["但是这样父节点不是变了吗",{"2":{"240":1}}],["但是这种方式会存在这样的问题",{"2":{"136":1}}],["但是有时候",{"2":{"221":1}}],["但是计算机中集合的元素不能重复",{"2":{"210":1}}],["但是回到前一个节点是很难的",{"2":{"168":1}}],["但是链表和数组的实现机制完全不同",{"2":{"166":1}}],["但是效率不高",{"2":{"162":1}}],["但是该位置已经放置了数据",{"2":{"141":1}}],["但是可以通过其他方式解决",{"2":{"136":1}}],["但是相对于数组",{"2":{"135":1}}],["但是它的整体效率不如红黑树",{"2":{"84":1}}],["但是插入连续数据后",{"2":{"84":1}}],["但是",{"2":{"34":1,"99":1,"148":2,"159":1}}],["步骤逻辑",{"2":{"248":1}}],["步骤",{"2":{"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1}}],["步到达最后一个下标",{"2":{"36":1}}],["步",{"2":{"36":1}}],["无法通过下标值直接访问元素",{"2":{"168":1}}],["无法跳过第一个元素访问任何一个元素",{"2":{"168":1}}],["无法找零",{"2":{"35":2}}],["无强制要求",{"2":{"151":1}}],["无权图",{"2":{"117":1}}],["无向图",{"2":{"117":1}}],["无右子节点成功插入",{"2":{"69":1}}],["无右子节点时",{"2":{"69":1}}],["无左子节点时",{"2":{"69":1}}],["无需进行交换操作",{"2":{"52":1}}],["无重叠区间",{"0":{"37":1}}],["无论是人工智能",{"2":{"250":1}}],["无论是插入",{"2":{"141":1}}],["无论是否满足",{"2":{"34":1}}],["无论多少数据",{"2":{"135":1}}],["无论输入数据的顺序如何",{"2":{"56":1}}],["无论输入数据的初始排列状态如何",{"2":{"51":1}}],["无论怎样",{"2":{"36":1}}],["顾客付",{"2":{"35":3}}],["顾客排队购买你的产品",{"2":{"35":1}}],["来遍历其中的元素",{"2":{"135":1}}],["来赋值",{"2":{"105":1,"106":1,"112":1}}],["来操作一棵树",{"2":{"84":1}}],["来替换当前的节点",{"2":{"81":1}}],["来存储小于和大于基准的元素",{"2":{"55":1}}],["来存储已经计算过的子问题的结果",{"2":{"45":1}}],["来存储所有的子集结果",{"2":{"44":1}}],["来存储所有的子集",{"2":{"44":1}}],["来存储所有的排列结果",{"2":{"43":1}}],["来存储所有的排列",{"2":{"43":1}}],["来存储每个孩子的糖果数",{"2":{"38":1}}],["来存储子问题的解",{"2":{"23":1}}],["来记录上一个选择的区间的结束时间",{"2":{"37":1}}],["来使剩下的区间没有重叠",{"2":{"37":1}}],["来分别表示手中拥有的",{"2":{"35":1}}],["优秀的算法和数据结构设计能够显著减少程序的运行时间和内存消耗",{"2":{"250":1}}],["优秀的哈希函数",{"2":{"143":1}}],["优点",{"2":{"235":4}}],["优先级都大于新插入的元素",{"2":{"195":1}}],["优先级越大",{"2":{"195":1}}],["优先级队列主要考虑的问题",{"2":{"193":1}}],["优先处理",{"2":{"192":1,"199":1}}],["优先排队的人",{"2":{"192":1,"199":1}}],["优先队列类",{"2":{"195":1}}],["优先队列内部的元素类",{"2":{"195":1}}],["优先队列的实现",{"0":{"194":1},"1":{"195":1,"196":1}}],["优先队列",{"0":{"191":1,"193":1},"1":{"192":1,"193":1,"194":1,"195":1,"196":1,"197":1}}],["优先使用",{"2":{"35":3}}],["优先使用手中的大额钞票找零",{"2":{"35":1}}],["优化遍历范围",{"2":{"50":1}}],["优化后的代码在空间复杂度上更高效",{"2":{"28":1}}],["优化空间复杂度",{"2":{"28":1}}],["张",{"2":{"35":2}}],["前言",{"0":{"241":1},"1":{"242":1,"243":1,"244":1,"245":1,"246":1,"247":1,"248":1,"249":1,"250":1}}],["前面的",{"2":{"207":1}}],["前面我们在哈希表中使用的是长度为",{"2":{"159":1}}],["前驱",{"0":{"82":1}}],["前一个元素大于后一个元素",{"2":{"50":1}}],["前",{"2":{"35":2}}],["注意你可以重复使用字典中的单词",{"2":{"45":1}}],["注意",{"2":{"35":1,"45":1,"117":1}}],["注意到我们在状态转移时",{"2":{"28":1}}],["也称为叶子节点",{"2":{"236":1}}],["也称为二叉排序树和二叉查找树",{"2":{"65":1}}],["也被压入栈",{"2":{"223":1}}],["也被称为",{"2":{"53":1}}],["也不能重复",{"2":{"210":1}}],["也将是最先被移除的元素",{"2":{"203":1}}],["也浪费很多时间",{"2":{"121":1}}],["也有一个向后连接的引用",{"2":{"99":1}}],["也有两种方式",{"2":{"81":1}}],["也成为满二叉树",{"2":{"91":1}}],["也可以实现哈希表容量的压缩",{"2":{"160":1}}],["也可以使用不同的探测序列",{"2":{"143":1}}],["也可以使用递归",{"2":{"133":1}}],["也可以抽象成",{"2":{"120":1}}],["也可以保证",{"2":{"117":1}}],["也可以是无向的",{"2":{"116":1}}],["也可以从尾遍历到头",{"2":{"99":1}}],["也可以采用循环来实现",{"2":{"77":1}}],["也可以跳上",{"2":{"11":1}}],["也就是说",{"2":{"135":1}}],["也就是说净交易是每位顾客向你支付",{"2":{"35":1}}],["也就是",{"2":{"121":1}}],["也就是顶点到自己的连线",{"2":{"121":1}}],["也就是没有节点",{"2":{"87":1}}],["也就不再调用",{"2":{"69":1}}],["按顺序进栈",{"2":{"224":1}}],["按从上到下",{"2":{"94":1}}],["按照类别存放",{"2":{"244":1}}],["按照字母顺序找到位置",{"2":{"244":1}}],["按照书名的拼音字母顺序排放",{"2":{"244":1}}],["按照百位进行排序",{"2":{"57":1}}],["按照十位进行排序",{"2":{"57":1}}],["按照个位进行排序",{"2":{"57":1}}],["按照最低有效位进行排序",{"2":{"57":1}}],["按照贪心策略逐步推进",{"2":{"31":1}}],["按区间的结束时间进行排序",{"2":{"37":1}}],["按账单",{"2":{"35":1}}],["美元找零",{"2":{"35":6}}],["美元的数量",{"2":{"35":2}}],["美元的钞票和一张",{"2":{"35":1}}],["美元的钞票",{"2":{"35":6}}],["美元和",{"2":{"35":2}}],["美元或",{"2":{"35":1}}],["美元",{"2":{"35":13}}],["柠檬水找零",{"0":{"35":1}}],["都离不开高效的算法设计",{"2":{"250":1}}],["都会考察应聘者对数据结构和算法的掌握情况",{"2":{"250":1}}],["都基于基础的数据结构和算法知识",{"2":{"250":1}}],["都是由一个个节点连接构成",{"2":{"238":1}}],["都有集合结构",{"2":{"209":1}}],["都有一个尺寸",{"2":{"34":1}}],["都有一个胃口值",{"2":{"34":1}}],["都要进行越界判断",{"2":{"178":1,"183":1}}],["都不允许插入数据",{"2":{"141":1}}],["都可以",{"2":{"122":1}}],["都需要明确指定第一个被访问的顶点",{"2":{"131":1}}],["都需要处理四个引用",{"2":{"99":1}}],["都需要将数据构建成最大堆",{"2":{"56":1}}],["都尝试下一个饼干",{"2":{"34":1}}],["饼干的指针",{"2":{"34":1}}],["孩子的指针",{"2":{"34":1}}],["尝试其他的选择",{"2":{"39":1}}],["尝试找零",{"2":{"35":2}}],["尝试用下一个较大的饼干去满足当前孩子的胃口",{"2":{"34":1}}],["尝试使用每种硬币",{"2":{"29":1}}],["匹配结束",{"2":{"34":1}}],["匹配",{"2":{"34":1}}],["先定类别",{"2":{"244":2}}],["先进后出",{"2":{"222":1}}],["先进先出",{"2":{"199":1}}],["先创建单向链表类",{"2":{"172":1}}],["先创建",{"2":{"154":1}}],["先访问其所有的相邻点",{"2":{"132":1}}],["先来创建",{"2":{"124":1}}],["先找到需要删除的节点",{"2":{"78":1}}],["先序遍历先遍历根节点",{"2":{"74":1}}],["先序遍历的过程为",{"2":{"71":1}}],["先序遍历",{"0":{"71":1},"2":{"70":1,"71":1}}],["先将前一个数组的元素放入结果数组中",{"2":{"54":1}}],["先将数组逆序",{"2":{"12":1}}],["先从左到右扫描数组",{"2":{"38":1}}],["先按照区间的结束时间排序",{"2":{"37":1}}],["先对孩子的满足度和饼干的大小排序",{"2":{"34":1}}],["算法案例",{"0":{"249":1}}],["算法通俗理解",{"0":{"248":1}}],["算法",{"0":{"247":1}}],["算法与应用",{"2":{"243":1}}],["算法是一种简单的搜索算法",{"2":{"47":1}}],["算法求最小生成树",{"2":{"32":1}}],["算法求最短路径",{"2":{"32":1}}],["算法和",{"2":{"32":1}}],["算法设计思想",{"0":{"13":1},"1":{"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1}}],["资源分配问题",{"2":{"32":1}}],["活动选择问题",{"2":{"32":1}}],["实际情况中",{"2":{"145":1}}],["实际上",{"2":{"116":1,"135":1}}],["实施贪心算法",{"2":{"31":1}}],["实现灵活的内存动态管理",{"2":{"168":1}}],["实现扩容或压缩后的哈希表容量为质数",{"0":{"163":1}}],["实现哈希化时采用取余运算",{"2":{"148":1}}],["实现起来会困难些",{"2":{"99":1}}],["实现原理是一个节点既有向前连接的引用",{"2":{"99":1}}],["实现原理是上一个节点中有指向下一个节点的引用",{"2":{"98":1}}],["实现思路",{"2":{"69":1,"72":1,"73":1,"78":1,"154":1,"155":1,"156":1,"159":1,"163":1}}],["实现",{"0":{"6":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1},"2":{"5":1}}],["证明所选的贪心策略能够得到问题的最优解",{"2":{"31":1}}],["证明贪心选择的正确性",{"2":{"31":1}}],["选择合适的数据结构不仅能提高代码的效率",{"2":{"250":1}}],["选择质数作为哈希表容量",{"0":{"161":1},"1":{"162":1,"163":1}}],["选择基准",{"2":{"55":2}}],["选择增量序列",{"2":{"53":1}}],["选择最小元素",{"2":{"51":2}}],["选择排序在处理大规模数据集时效率较低",{"2":{"51":1}}],["选择排序由于其简单性和恒定的空间复杂度",{"2":{"51":1}}],["选择排序通常不是稳定排序",{"2":{"51":1}}],["选择排序是一种原地排序算法",{"2":{"51":1}}],["选择排序仍需要进行",{"2":{"51":1}}],["选择排序总是需要进行",{"2":{"51":1}}],["选择排序的特点是每次遍历都只进行一次交换操作",{"2":{"51":1}}],["选择排序",{"0":{"51":1},"2":{"51":1}}],["选择和探索",{"2":{"43":2,"44":2}}],["选择决策树",{"2":{"40":1}}],["选择一个贪心策略",{"2":{"31":1}}],["选择一个主元",{"2":{"21":1}}],["选择贪心策略",{"2":{"31":1}}],["明确所需的解和约束条件",{"2":{"31":1}}],["所谓合适的位置指的是空的位置",{"2":{"141":1}}],["所表示的数字就非常大",{"2":{"136":1}}],["所有的未被访问过的邻接点",{"2":{"132":1}}],["所有大于基准的元素在基准的右边",{"2":{"55":1}}],["所在的节点",{"2":{"112":1,"180":1}}],["所占内存空间更大一些",{"2":{"99":1}}],["所需的硬币数是",{"2":{"29":1}}],["所需的最少硬币个数",{"2":{"29":1}}],["所以错误",{"2":{"224":1}}],["所以当前栈的顺序为",{"2":{"223":1}}],["所以采用",{"2":{"207":1}}],["所以这个哈希表可以无限制地插入新数据",{"2":{"159":1}}],["所以这里不考虑方向问题",{"2":{"127":1}}],["所以我们使用",{"2":{"148":1}}],["所以我们输出",{"2":{"35":1}}],["所以哈希函数不能采用消耗性能较高的复杂算法",{"2":{"146":1}}],["所以该方式不合理",{"2":{"136":1}}],["所以查找起来十分麻烦",{"2":{"135":1}}],["所以不需要引用",{"2":{"238":1}}],["所以不能以一种固定的方式",{"2":{"135":1}}],["所以不是二叉树",{"2":{"65":1}}],["所以边是可以双向的",{"2":{"127":1}}],["所以表示起来会稍微麻烦一些",{"2":{"120":1}}],["所以平衡树的应用基本都是红黑树",{"2":{"84":1}}],["所以它不是完全二叉树",{"2":{"92":1}}],["所以它的时间复杂度也是",{"2":{"84":1}}],["所以它们是有序的",{"2":{"54":1}}],["所以遍历方式有多种选择",{"2":{"70":1}}],["所以最优时间复杂度为",{"2":{"55":1}}],["所以最坏时间复杂度为",{"2":{"51":1}}],["所以具体的时间复杂度因实现而异",{"2":{"53":1}}],["所以永远不可能到达最后一个下标",{"2":{"36":1}}],["所以答案是",{"2":{"35":1}}],["所以你应该输出",{"2":{"34":2}}],["所以可以将空间复杂度优化为",{"2":{"28":1}}],["所以",{"2":{"26":1,"66":3,"67":1}}],["零钱兑换",{"0":{"29":1}}],["填充",{"2":{"28":1,"29":1}}],["填表计算",{"2":{"23":1}}],["房子的最高金额",{"2":{"28":2}}],["金额",{"2":{"28":5}}],["号房屋",{"2":{"28":5}}],["偷窃该房子",{"2":{"28":1}}],["偷窃到的最高金额",{"2":{"28":2}}],["偷窃",{"2":{"28":3}}],["系统会自动报警",{"2":{"28":1}}],["影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统",{"2":{"28":1}}],["≤",{"2":{"27":1}}],["结论",{"2":{"244":1,"249":1}}],["结账",{"2":{"192":1,"199":1}}],["结构用",{"2":{"126":1}}],["结果",{"2":{"51":2}}],["结果与前一个结果合并",{"2":{"1":1}}],["结束条件",{"2":{"34":1}}],["结尾的最长递增子序列的长度",{"2":{"27":1}}],["是计算机中存储",{"2":{"243":1}}],["是节点",{"2":{"236":1}}],["是否等于传入的",{"2":{"155":1}}],["是否为",{"2":{"78":1,"155":1,"156":1}}],["是质数",{"2":{"143":1,"163":1}}],["是比较简单的",{"2":{"122":1}}],["是",{"2":{"121":1,"124":1,"207":1,"236":1}}],["是一条简单路径",{"2":{"117":1}}],["是一种运算受限的线性表",{"2":{"199":1,"222":1}}],["是一种非比较性的排序算法",{"2":{"57":1,"58":1}}],["是一种基于二叉堆数据结构的比较排序算法",{"2":{"56":1}}],["是一种基于分治法",{"2":{"54":1}}],["是一种高效的排序算法",{"2":{"55":1,"56":1}}],["是一种高效的搜索算法",{"2":{"48":1}}],["是一种改进的插入排序算法",{"2":{"53":1}}],["是一种简单的比较排序算法",{"2":{"50":1,"51":1,"52":1}}],["是一种常见的算法设计思想",{"2":{"14":1}}],["是不能重复且无序的",{"2":{"185":1}}],["是不能使用树来表示",{"2":{"116":1}}],["是不允许重复的",{"2":{"135":1}}],["是不相邻的",{"2":{"117":1}}],["是相邻的",{"2":{"117":2}}],["是最早的一种平衡树",{"2":{"84":1}}],["是最大或最小元素",{"2":{"55":1}}],["是元素的范围",{"2":{"58":2}}],["是元素个数",{"2":{"57":2,"58":2}}],["是关键字的范围",{"2":{"57":1}}],["是关键字的位数",{"2":{"57":1}}],["是列表的长度",{"2":{"47":1}}],["是词典",{"2":{"45":1}}],["是字符串",{"2":{"45":1}}],["是输入数组的长度",{"2":{"43":1,"44":1}}],["是账单的数量",{"2":{"35":1}}],["是第",{"2":{"35":1}}],["是饼干数组的长度",{"2":{"34":1}}],["是孩子数组的长度",{"2":{"34":1}}],["是硬币种类数",{"2":{"29":1}}],["是金额",{"2":{"29":1}}],["是数组的长度",{"2":{"48":1}}],["是数组",{"2":{"27":1}}],["删除效率都非常高",{"2":{"235":1}}],["删除集合中指定的",{"2":{"213":1,"220":1}}],["删除对应位置的数组项",{"2":{"156":1,"164":1}}],["删除哈希表中特定位置的元素",{"2":{"150":1}}],["删除都会影响",{"2":{"141":1}}],["删除一个数据项时",{"2":{"141":1}}],["删除操作和上述两种情况类似",{"2":{"141":1}}],["删除最后一个节点的情况",{"2":{"107":1,"112":1}}],["删除第一个节点的情况",{"2":{"107":1,"112":1}}],["删除指定",{"2":{"112":1,"156":1,"164":1,"179":1,"180":1,"183":2}}],["删除指定位置的节点",{"2":{"107":1,"112":1,"179":1,"183":1}}],["删除指定索引位置的元素",{"2":{"63":1}}],["删除等操作时",{"2":{"84":1}}],["删除节点",{"2":{"79":2,"80":4,"81":3,"83":1}}],["删除根节点",{"2":{"79":1,"80":2}}],["删除的是有两个子节点的节点",{"0":{"81":1},"1":{"82":1},"2":{"78":1,"82":1,"83":1}}],["删除的是只有一个子节点的节点",{"0":{"80":1},"2":{"78":1,"79":1,"80":1,"83":1}}],["删除的是叶子节点的情况",{"2":{"79":1,"83":1}}],["删除的是叶子节点分两种情况",{"2":{"79":1}}],["删除的是叶子节点",{"0":{"79":1},"2":{"78":1}}],["删除找到的指定节点",{"2":{"78":1}}],["删除数据",{"0":{"78":1},"1":{"79":1,"80":1,"81":1,"82":1,"83":1}}],["删除数组首位的元素",{"2":{"63":1}}],["删除数组最后的元素",{"2":{"63":1}}],["删除索引",{"2":{"63":1}}],["删除元素",{"0":{"63":1}}],["删除",{"2":{"27":1,"107":1,"108":1,"112":2,"135":1}}],["子节点",{"2":{"236":1}}],["子集的实现",{"0":{"219":1}}],["子集",{"0":{"44":1},"2":{"41":1,"215":1,"219":1,"220":1}}],["子集问题",{"2":{"41":1}}],["子序列是由数组派生而来的序列",{"2":{"27":1}}],["子数组是数组中的一个连续部分",{"2":{"20":1}}],["子数组最少包含一个元素",{"2":{"20":1}}],["状态转移方程为",{"2":{"28":1}}],["状态转移方程",{"2":{"26":1,"27":1,"28":1,"29":1}}],["知道",{"2":{"26":1}}],["其余节点可分为",{"2":{"235":1}}],["其余元素视为未排序部分",{"2":{"52":1}}],["其实是一个对称图",{"2":{"121":1}}],["其实图中叫顶点",{"2":{"116":1}}],["其实",{"2":{"66":1,"240":1}}],["其基本思想是将数组分成更小的子数组",{"2":{"54":1}}],["其空间复杂度为",{"2":{"53":1,"57":1,"58":1}}],["其平均时间复杂度为",{"2":{"52":1}}],["其他任一节点的层数是其父节点的层数加",{"2":{"236":1}}],["其他方法的实现",{"0":{"111":1}}],["其他各层的节点数都达到了最大值",{"2":{"92":1}}],["其他",{"2":{"29":1}}],["其中每个集合本身又是一棵树",{"2":{"235":1}}],["其中每个元素都有相同的位数或范围",{"2":{"57":1}}],["其中每个节点的值都大于或等于其子节点的值",{"2":{"56":1}}],["其中一部分的所有元素都小于基准",{"2":{"55":1}}],["其中",{"2":{"26":1,"27":1,"28":1,"29":2,"34":1,"35":2,"37":1,"43":1,"44":1,"45":1,"47":1,"48":1,"57":3,"58":2,"143":1}}],["其核心是将一个大问题分解成小的子问题",{"2":{"14":1}}],["阶迈两步",{"2":{"26":1}}],["阶迈一步或者从第",{"2":{"26":1}}],["阶的方法只有一种",{"2":{"26":1}}],["阶的方法是站在原地",{"2":{"26":1}}],["阶的方法总数",{"2":{"26":3}}],["阶",{"2":{"26":11}}],["阶你才能到达楼顶",{"2":{"26":1}}],["或多个",{"2":{"203":1}}],["或大于链表长度",{"2":{"175":1,"183":1}}],["或列表",{"2":{"167":1}}],["或两个机场间的距离",{"2":{"118":1}}],["或最大",{"2":{"51":6}}],["或最小",{"2":{"50":1}}],["或者两种颜色也可以",{"2":{"131":1}}],["或者什么样的数据使用图来模拟更合适呢",{"2":{"116":1}}],["或者不偷窃该房子",{"2":{"28":1}}],["或者数组长度是否小于等于",{"2":{"2":2}}],["或不删除",{"2":{"27":1}}],["或",{"2":{"26":2,"230":1}}],["需要多少次可以排查完呢",{"2":{"249":1}}],["需要大量的位移操作",{"2":{"235":1}}],["需要排队打印",{"2":{"201":1}}],["需要从头开始依次查找",{"2":{"235":1}}],["需要从头开始一个个访问",{"2":{"168":1}}],["需要从头开始访问",{"2":{"168":1}}],["需要进行大量元素的位移",{"2":{"167":1}}],["需要扩容",{"2":{"167":1}}],["需要探测的次数也呈指数形式增长",{"2":{"145":1}}],["需要有一套编码系统",{"2":{"136":1}}],["需要通过某种算法来遍历图结构中每一个数据",{"2":{"130":1}}],["需要在",{"2":{"82":1}}],["需要查询",{"2":{"66":1}}],["需要移除",{"2":{"37":2}}],["需要找零",{"2":{"35":2}}],["需要一个长度为",{"2":{"26":1,"27":1,"29":1}}],["需要",{"2":{"26":1,"238":1}}],["爬楼梯",{"0":{"26":1}}],["划分等问题",{"2":{"24":1}}],["划分问题",{"2":{"24":1}}],["计数排序适用于对一定范围内的整数进行排序",{"2":{"58":1}}],["计数排序是一种稳定排序算法",{"2":{"58":1}}],["计数排序的空间复杂度取决于额外的计数数组和输出数组",{"2":{"58":1}}],["计数排序的平均时间复杂度也为",{"2":{"58":1}}],["计数排序的时间复杂度主要取决于元素的范围",{"2":{"58":1}}],["计数排序的时间复杂度仍然为",{"2":{"58":1}}],["计数排序的时间复杂度为",{"2":{"58":1}}],["计数排序的基本思想是通过统计待排序数组中每个元素出现的次数",{"2":{"58":1}}],["计数排序",{"0":{"58":1},"2":{"58":1}}],["计数器",{"2":{"37":1}}],["计数问题",{"2":{"24":1}}],["计划偷窃沿街的房屋",{"2":{"28":1}}],["计算机中存储的数据量相对于图书馆的书籍来说数据量更大",{"2":{"244":1}}],["计算机中数据量非常庞大",{"2":{"244":1}}],["计算机打印多个文件的时候",{"2":{"201":1}}],["计算",{"2":{"151":1}}],["计算最少需要的糖果数",{"2":{"38":1}}],["计算总糖果数",{"2":{"38":3}}],["计算并返回需要准备的最少糖果数目",{"2":{"38":1}}],["计算并返回可以凑成总金额所需的最少的硬币个数",{"2":{"29":1}}],["计算需要移除的区间数量",{"2":{"37":2}}],["计算你不触动警报装置的情况下",{"2":{"28":1}}],["计算每个位置的最长递增子序列长度",{"2":{"27":1}}],["计算每个台阶的方法数",{"2":{"26":1}}],["计算右半部分的最大子数组和",{"2":{"20":1}}],["计算左半部分的最大子数组和",{"2":{"20":1}}],["计算跨越中间点的最大子数组和",{"2":{"20":1}}],["计算跨越中间的最大子数组和",{"2":{"20":1}}],["计算中间点",{"2":{"20":1}}],["计算中点",{"2":{"19":1}}],["计算两个数的最小公倍数",{"2":{"5":1}}],["计算两个数的最大公约数",{"2":{"5":1}}],["即把队头删除的元素",{"2":{"207":1}}],["即排在队列最前面的",{"2":{"203":1}}],["即排序后第",{"2":{"21":1}}],["即它们的改变指向",{"2":{"175":1,"183":1}}],["即节点的",{"2":{"173":1,"183":1}}],["即只有",{"2":{"173":1,"183":1}}],["即只使用了少量的辅助变量",{"2":{"50":1}}],["即可",{"2":{"155":1}}],["即将数据化为二进制进行与运算",{"2":{"148":1}}],["即从要删除的节点的右边开始查找最小的值",{"2":{"82":1,"83":1}}],["即在",{"2":{"82":2}}],["即在每一步选择中",{"2":{"31":1}}],["即完成排序",{"2":{"56":1}}],["即数组的第一个元素",{"2":{"52":1}}],["即数组已经完全排序",{"2":{"50":1}}],["即每一步的局部最优选择最终能够导致全局最优解",{"2":{"30":1}}],["即",{"2":{"28":2,"81":2,"135":1,"160":1,"175":1,"183":1,"223":1}}],["即状态转移方程",{"2":{"23":1}}],["确保左边的评分更高的孩子获得更多糖果",{"2":{"38":1}}],["确保右边的评分更高的孩子获得更多糖果",{"2":{"38":1}}],["确保结果为正数",{"2":{"5":1}}],["确定增量的大小",{"2":{"53":1}}],["确定每个增量值",{"2":{"53":1}}],["确定初始状态的值",{"2":{"23":1}}],["确定状态转移方程",{"2":{"23":1}}],["确定这些子问题的状态和状态之间的转移关系",{"2":{"23":1}}],["动态规划的应用",{"0":{"25":1},"1":{"26":1,"27":1,"28":1,"29":1}}],["动态规划的核心思想是利用已计算的结果来构建解决方案",{"2":{"22":1}}],["动态规划主要用于解决以下几类问题",{"2":{"24":1}}],["动态规划是一种解决复杂问题的方法",{"2":{"22":1}}],["动态规划",{"0":{"22":1},"1":{"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1}}],["动态规划公式",{"2":{"11":1}}],["然而其中却有许多下标值指向的是无效的数据",{"2":{"136":1}}],["然而",{"2":{"21":1,"51":1,"52":1}}],["然后逐步解决这些问题",{"2":{"250":1}}],["然后由内向外逐层计算一次多项式的值",{"2":{"147":1}}],["然后",{"2":{"71":1,"72":1,"73":1,"154":1,"155":1,"156":1,"159":1}}],["然后判断根节点是否存在",{"2":{"69":1}}],["然后根据统计信息将元素放置到正确的位置上",{"2":{"58":1}}],["然后按照每一位的顺序依次排序",{"2":{"57":1}}],["然后进行排序",{"2":{"56":1}}],["然后对堆的根节点进行调整",{"2":{"56":1}}],["然后对每一半进行排序",{"2":{"54":1}}],["然后递归地对这两部分进行排序",{"2":{"55":1}}],["然后递归地求解左右两部分的最大子数组和",{"2":{"20":1}}],["然后从未排序部分依次取出元素",{"2":{"52":1}}],["然后放到已排序的卡片堆中",{"2":{"51":1}}],["然后将原数组中的元素复制过去",{"2":{"167":1}}],["然后将其放置到数组的起始位置",{"2":{"51":1}}],["然后将子问题的解合并起来得到原问题的解",{"2":{"14":1}}],["然后下一轮排序时只需要遍历到该位置即可",{"2":{"50":1}}],["然后依次选择结束时间最早且不与前一个选择的区间重叠的区间",{"2":{"37":1}}],["然后依次为每个孩子分配满足其满足度的最小饼干",{"2":{"34":1}}],["然后再将它们合并起来",{"2":{"54":1}}],["然后再从下标",{"2":{"36":1}}],["然后再用",{"2":{"35":1}}],["然后再用小的数去除以的得到的余数",{"2":{"4":1}}],["然后返还",{"2":{"35":1}}],["然后向你付",{"2":{"35":1}}],["然后加上",{"2":{"28":1}}],["然后偷窃",{"2":{"28":1}}],["然后合并这些子问题的解来得到原问题的解",{"2":{"20":1}}],["然后调整堆",{"2":{"12":1}}],["然后使用扩展运算符将",{"2":{"2":1}}],["通常删除一个位置的数据项时",{"2":{"141":1}}],["通常情况下当装填因子",{"2":{"160":1}}],["通常情况下",{"2":{"135":1,"243":1}}],["通常使用",{"2":{"121":1}}],["通常使用一个表格",{"2":{"23":1}}],["通常表示有向",{"2":{"116":1}}],["通常表示无向",{"2":{"116":1}}],["通常用",{"2":{"116":2}}],["通常是",{"2":{"57":1}}],["通常是用于交换元素的临时变量",{"2":{"51":1}}],["通常需要一个额外的数组来存储中间结果",{"2":{"57":1}}],["通常为常数",{"2":{"57":1}}],["通常以递减的方式选择",{"2":{"53":1}}],["通常不作为首选的排序算法",{"2":{"51":1}}],["通常不适合大规模数据集的排序任务",{"2":{"50":1}}],["通常通过数学归纳法或反证法证明",{"2":{"31":1}}],["通常选择数组的最后一个元素作为主元",{"2":{"21":1}}],["通过学习它们",{"2":{"250":1}}],["通过键值查找特定的数值并返回",{"2":{"187":1}}],["通过使用键值来从字典中移除键值对应的数据值",{"2":{"187":1}}],["通过循环遍历",{"2":{"179":1,"183":1}}],["通过循环调用",{"2":{"163":1}}],["通过循环而不是递归的方式来实现",{"2":{"10":1}}],["通过哈希函数获取它在",{"2":{"155":1,"156":1}}],["通过哈希函数获取",{"2":{"154":1,"164":1}}],["通过哈希函数可以获取",{"2":{"135":1}}],["通过取余操作实现哈希化",{"2":{"151":1}}],["通过以下案例了解哈希表",{"2":{"135":1}}],["通过将顶点存入栈中",{"2":{"131":1}}],["通过将问题分解成更小的子问题",{"2":{"22":1}}],["通过这种算法来访问某个顶点的数据以及它对应的边",{"2":{"130":1}}],["通过二维数组",{"2":{"121":1}}],["通过下图来了解图的术语",{"2":{"117":1}}],["通过递归实现",{"2":{"77":1}}],["通过递归来实现",{"2":{"1":1}}],["通过后序遍历方式遍历所有节点",{"2":{"68":1}}],["通过中序遍历方式遍历所有节点",{"2":{"68":1}}],["通过先序遍历方式遍历所有节点",{"2":{"68":1}}],["通过随机选择基准或",{"2":{"55":1}}],["通过",{"2":{"43":1,"44":1,"77":1,"173":1}}],["通过遍历",{"2":{"38":1}}],["通过上述方法",{"2":{"28":1}}],["通过分而治之的方法来选择特定的第",{"2":{"21":1}}],["通过迭代计算斐波那契数列的第",{"2":{"10":1}}],["你会发现",{"2":{"249":1}}],["你不需要移除任何区间",{"2":{"37":1}}],["你需要按照以下要求",{"2":{"38":1}}],["你需要移除两个",{"2":{"37":1}}],["你需要找的是数组排序后的第",{"2":{"21":1}}],["你最初位于数组的第一个下标",{"2":{"36":1}}],["你必须给每个顾客正确找零",{"2":{"35":1}}],["你必须设计并实现时间复杂度为",{"2":{"21":1}}],["你拥有的饼干数量和尺寸都足以让所有孩子满足",{"2":{"34":1}}],["你只能让胃口值是",{"2":{"34":1}}],["你有两个孩子和三块小饼干",{"2":{"34":1}}],["你有三个孩子和两块小饼干",{"2":{"34":1}}],["你有多少种不同的方法可以爬到楼顶呢",{"2":{"26":1}}],["你的目标是尽可能满足越多数量的孩子",{"2":{"34":1}}],["你可以按任意顺序返回解集",{"2":{"44":1}}],["你可以按任意顺序返回答案",{"2":{"43":1}}],["你可以分别给第一个",{"2":{"38":2}}],["你可以认为每种硬币的数量是无限的",{"2":{"29":1}}],["你可以假设数组是非空的",{"2":{"18":1}}],["你是一个专业的小偷",{"2":{"28":1}}],["请注意",{"2":{"21":1}}],["请返回数组中第",{"2":{"21":1}}],["请你想出一种算法",{"2":{"249":1}}],["请你给每个孩子分发糖果",{"2":{"38":1}}],["请你找出一个具有最大和的连续子数组",{"2":{"20":1}}],["请你将该数组升序排列",{"2":{"19":1}}],["请你输出斐波那契数列的第",{"2":{"10":1}}],["跨越中点的最大子数组和等于左半部分的最大和加上右半部分的最大和",{"2":{"20":1}}],["包括",{"2":{"20":1}}],["wc",{"2":{"192":1,"199":1}}],["was",{"2":{"136":1}}],["white",{"2":{"131":1,"132":1,"133":2}}],["while",{"2":{"19":3,"34":1,"48":1,"50":1,"52":1,"53":1,"54":3,"58":1,"76":2,"77":2,"78":1,"82":1,"83":2,"105":1,"106":1,"107":1,"109":1,"110":1,"112":4,"132":1,"163":1,"164":1,"173":2,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"183":7,"207":1,"230":3}}],["w",{"2":{"127":2,"133":3}}],["wednesday",{"2":{"60":4}}],["wordbreak",{"2":{"45":5}}],["worddict",{"2":{"45":12}}],["word",{"2":{"9":10,"45":5}}],["wordcount",{"2":{"9":8}}],["wordset",{"2":{"45":3}}],["words",{"2":{"9":2}}],["直至数组剩下一个元素",{"2":{"206":1}}],["直接从队列中删除",{"2":{"207":1}}],["直接从变换前的",{"2":{"147":1}}],["直接添加",{"2":{"195":1}}],["直接指向",{"2":{"169":1}}],["直接",{"2":{"155":1}}],["直接通过",{"2":{"79":1}}],["直接插入",{"2":{"69":2}}],["直接把新节点作为二叉搜索树的根节点",{"2":{"69":1}}],["直接退出循环",{"2":{"50":1}}],["直接收下",{"2":{"35":2}}],["直接取",{"2":{"28":1}}],["直接返回对应的",{"2":{"155":1}}],["直接返回原数组",{"2":{"53":1}}],["直接返回缓存的结果",{"2":{"45":1}}],["直接返回缓存中的结果",{"2":{"45":2}}],["直接返回主元",{"2":{"21":1}}],["直接返回",{"2":{"19":1,"26":1,"51":1,"52":1,"54":1,"55":1,"56":1,"155":1,"156":1}}],["直到是为止",{"2":{"163":1}}],["直到节点为",{"2":{"109":1,"110":1,"112":2,"174":1,"183":1}}],["直到遇到传入",{"2":{"69":1}}],["直到遇到无左子节点成功插入",{"2":{"69":1}}],["直到成功插入新节点为止",{"2":{"69":1}}],["直到按照最高位排序完成",{"2":{"57":1}}],["直到堆中剩余元素只剩一个",{"2":{"56":1}}],["直到其中一个数组的元素全部加入完则停止",{"2":{"54":1}}],["直到所有位都被处理完毕",{"2":{"57":1}}],["直到所有的子数组被合并成一个完整的有序数组",{"2":{"54":1}}],["直到所有元素都被插入完成",{"2":{"52":2}}],["直到所有元素都已经排序完毕",{"2":{"51":1}}],["直到所有元素都排序完成",{"2":{"51":1}}],["直到增量为",{"2":{"53":2}}],["直到没有任何一对元素需要交换",{"2":{"50":1}}],["直到整个数组都排序完成",{"2":{"50":1}}],["直到找到目标数据为止",{"2":{"235":1}}],["直到找到目标元素或遍历完整个列表",{"2":{"47":1}}],["直到找到要插入的位置",{"2":{"175":1,"183":1}}],["直到找到对应的元素",{"2":{"168":1}}],["直到找到或查找到",{"2":{"77":1}}],["直到找到问题的解决方案或确定无解",{"2":{"39":1}}],["直到达到问题的约束条件或无法继续推进为止",{"2":{"31":1}}],["直到数组遍历完成",{"2":{"12":1}}],["直到第",{"2":{"11":1}}],["直到余数为",{"2":{"4":1}}],["找到指定",{"2":{"178":1,"179":1,"183":2}}],["找到对应位置的",{"2":{"156":1,"164":1}}],["找到",{"2":{"122":1}}],["找到要插入位置的节点",{"2":{"105":1,"106":1,"112":1}}],["找到后续节点",{"2":{"82":1,"83":1}}],["找到最后都没找到相等的节点",{"2":{"78":1,"83":1}}],["找到最小",{"2":{"51":1}}],["找到待排序数组中的最大值和最小值",{"2":{"58":1}}],["找到中间索引值",{"2":{"54":1}}],["找到正确的插入位置",{"2":{"52":1}}],["找到未排序部分的最小元素",{"2":{"51":1}}],["找到目标元素",{"2":{"48":1}}],["找到其中最长严格递增子序列的长度",{"2":{"27":1}}],["找到数组的中点",{"2":{"19":1,"20":1}}],["找出当前状态与之前状态的关系",{"2":{"23":1}}],["找出其中最小的",{"2":{"12":1}}],["找出出现次数最多的单词",{"2":{"9":1}}],["因为函数还没有执行完",{"2":{"223":1}}],["因为",{"2":{"154":1}}],["因为只要愿意",{"2":{"144":1}}],["因为只有空白的单元才能放入元素",{"2":{"144":1}}],["因为只需要常量空间来存储前两个状态的值",{"2":{"28":1}}],["因为只需遍历一次数组",{"2":{"26":1}}],["因为一遇到为",{"2":{"141":1}}],["因为插入",{"2":{"141":1}}],["因为链条的元素一般不会太多",{"2":{"139":1}}],["因为这里实现的是无向图",{"2":{"127":1}}],["因为边是两个顶点之间的边",{"2":{"127":2}}],["因为边是两个顶点之间的关系",{"2":{"120":1}}],["因为所有的边都没有方向",{"2":{"117":1}}],["因为构建最大堆和进行堆排序的时间复杂度都是",{"2":{"56":1}}],["因为基准元素的交换可能会使得相等的元素顺序颠倒",{"2":{"55":1}}],["因为随机选择基准或使用",{"2":{"55":1}}],["因为子数组的长度为",{"2":{"54":1}}],["因为它始终将数组分成两半",{"2":{"54":1}}],["因为它们已经是无重叠的了",{"2":{"37":1}}],["因为它已经是有序的",{"2":{"19":1}}],["因为我们需要额外的数组",{"2":{"38":1}}],["因为我们需要遍历两次数组",{"2":{"38":1}}],["因为我们需要遍历一次数组",{"2":{"36":1}}],["因为我们需要对区间进行排序",{"2":{"37":1}}],["因为我们需要嵌套循环遍历每个元素对",{"2":{"27":1}}],["因为我们现在只有两张",{"2":{"35":1}}],["因为凑成金额",{"2":{"29":1}}],["因为需要一个长度为",{"2":{"28":1}}],["因为需要遍历一次数组",{"2":{"28":2}}],["因为每个位置都至少可以是一个长度为",{"2":{"27":1}}],["因为每次分区都会将数组分成两部分",{"2":{"21":1}}],["因为快速选择是就地排序的算法",{"2":{"21":1}}],["因为归并排序需要额外的空间来存储合并后的数组",{"2":{"19":1}}],["因为数组每次都被分成两部分",{"2":{"19":1}}],["因此都需要在程序中体现出来",{"2":{"119":1}}],["因此在一些特定的排序场景中具有较好的性能表现",{"2":{"58":1}}],["因此在一些特定的排序场景中具有一定的优势",{"2":{"57":1}}],["因此是稳定的",{"2":{"57":1,"58":1}}],["因此它不是稳定的排序算法",{"2":{"56":1}}],["因此其平均时间复杂度也为",{"2":{"51":1}}],["因此其空间复杂度为",{"2":{"50":1,"51":1,"52":1,"56":1}}],["因此最优时间复杂度为",{"2":{"51":1}}],["因此最坏时间复杂度为",{"2":{"50":1,"52":1}}],["因此相同元素的相对顺序可能会被打乱",{"2":{"53":1}}],["因此相对于其他排序算法",{"2":{"51":1}}],["因此相等元素的相对位置不会改变",{"2":{"50":1}}],["因此可以提前结束排序过程",{"2":{"50":1}}],["因此可以将下一轮排序的范围限定在上一轮最后一次交换的位置之前",{"2":{"50":1}}],["因此可以通过循环的方式",{"2":{"10":1}}],["因此长度为",{"2":{"27":1}}],["因此空间复杂度为",{"2":{"18":1,"20":1,"55":2}}],["因此总时间复杂度为",{"2":{"18":1}}],["因此我们可以使用快速排序中的",{"2":{"12":1}}],["因此",{"2":{"11":1,"57":1,"58":1,"148":1}}],["因此跳上",{"2":{"11":1}}],["给火车加上数据后的结构",{"2":{"169":1}}],["给该顶点创建一个数组",{"2":{"126":1}}],["给这些孩子分发糖果",{"2":{"38":1}}],["给你一个非负整数数组",{"2":{"36":1}}],["给你一个整数数组",{"2":{"19":1,"20":1,"27":1,"29":1,"35":1,"38":1,"44":1}}],["给定一个字符串",{"2":{"45":1}}],["给定一个不含重复数字的数组",{"2":{"43":1}}],["给定一个区间的集合",{"2":{"37":1}}],["给定一个代表每个房屋存放金额的非负整数数组",{"2":{"28":1}}],["给定一个大小为",{"2":{"18":1}}],["给定整数数组",{"2":{"21":1}}],["递归",{"2":{"223":1}}],["递归的代码较难理解一些",{"2":{"133":1}}],["递归本质上就是函数栈的调用",{"2":{"133":1}}],["递归停止",{"2":{"69":1}}],["递归树的高度为",{"2":{"55":1}}],["递归分解后",{"2":{"54":1}}],["递归函数",{"2":{"43":1,"44":1,"45":2}}],["递归搜索",{"2":{"21":1}}],["递归调用回溯函数",{"2":{"44":1}}],["递归调用",{"2":{"43":1,"44":1,"69":1}}],["递归调用的栈空间为",{"2":{"21":1}}],["递归调用的深度为",{"2":{"20":1}}],["递归调用栈的深度为",{"2":{"18":1,"55":2}}],["递归求解左半部分和右半部分的最大子数组和",{"2":{"20":1}}],["递归求解",{"2":{"20":1}}],["递归排序",{"2":{"19":1,"54":1,"55":1}}],["递归终止条件",{"2":{"19":1,"20":1,"45":2}}],["递归深度为",{"2":{"18":1}}],["递归地排序左右子数组并合并",{"2":{"55":1}}],["递归地对基准左边的子数组和右边的子数组进行排序",{"2":{"55":1}}],["递归地对左右两部分进行排序",{"2":{"19":1}}],["递归地分割直到子数组的长度为",{"2":{"54":1}}],["递归地计算左半部分和右半部分的最大子数组和",{"2":{"20":1}}],["递归地在左右两部分中分别找出多数元素",{"2":{"18":1}}],["递归地解决这些子问题",{"2":{"15":1}}],["每条指令的描述不依赖于语言",{"2":{"247":1}}],["每种数据结构都有自己特定的应用场景",{"2":{"235":1}}],["每种排列需要",{"2":{"43":1}}],["每层节点都有",{"2":{"91":1}}],["每层的操作复杂度为",{"2":{"55":1}}],["每层的合并操作需要线性时间",{"2":{"18":1}}],["每步都能跳到最后",{"2":{"36":1}}],["每位顾客只买一杯柠檬水",{"2":{"35":1}}],["每一个父节点需要的引用数量也不同",{"2":{"238":1}}],["每一个工号对应一个员工的信息",{"2":{"135":1}}],["每一个节点由三部分组成",{"2":{"100":1}}],["每一个节点封装成一个",{"2":{"95":1}}],["每一趟排序中需要进行的比较次数逐渐减少",{"2":{"50":1}}],["每一轮遍历都会将最大",{"2":{"50":1}}],["每一杯柠檬水的售价为",{"2":{"35":1}}],["每一次选择一个枢纽值",{"2":{"12":1}}],["每个元素不再只是一个数据",{"2":{"193":1}}],["每个顶点至多访问两次",{"2":{"131":1}}],["每个关键字的位数相同",{"2":{"57":1}}],["每个子字符串的计算会涉及到对词典的遍历",{"2":{"45":1}}],["每个子集的平均长度为",{"2":{"44":1}}],["每个节点代表一个决策点",{"2":{"40":1}}],["每个孩子至少分配",{"2":{"38":1}}],["每个孩子至少分配到",{"2":{"38":1}}],["每个孩子最多只能给一块饼干",{"2":{"34":1}}],["每个位置初始化为",{"2":{"27":1,"28":1}}],["每个位置的初始值为",{"2":{"27":1}}],["每间房内都藏有一定的现金",{"2":{"28":1}}],["每次在插入或删除某个节点时",{"2":{"99":1}}],["每次按照位数排序后",{"2":{"57":1}}],["每次划分的子数组高度不均匀",{"2":{"55":1}}],["每次增量的大小减半",{"2":{"53":1}}],["每次插入元素时都需要将其与已经排序的部分进行比较并移动其他元素",{"2":{"52":1}}],["每次从未排序部分选择最小",{"2":{"51":1}}],["每次找到当前未排序部分的最小元素并放到已排序部分的末尾",{"2":{"51":1}}],["每次比较相邻的两个元素",{"2":{"50":2}}],["每次遍历的时间复杂度都是",{"2":{"38":1}}],["每次你可以爬",{"2":{"26":1}}],["每次合并时需要线性的时间来计算跨越中间的最大子数组和",{"2":{"20":1}}],["每次分治将问题分成两个子问题",{"2":{"20":1}}],["每次递归将数组分为两部分",{"2":{"18":1}}],["从中间位置开始排查",{"2":{"249":1}}],["从中点向右扫描的最大子数组和",{"2":{"20":1}}],["从中点向左扫描的最大子数组和",{"2":{"20":1}}],["从上海的起点开始一米一米的排查",{"2":{"249":1}}],["从自己角度认识",{"2":{"243":1}}],["从栈中取出元素",{"2":{"227":1}}],["从一个栈删除元素又称作出栈或退栈",{"2":{"222":1}}],["从集合移除一个值",{"2":{"212":1}}],["从队列中删除队头元素",{"2":{"204":1}}],["从队列中删除前端元素",{"2":{"195":1}}],["从",{"2":{"132":1,"141":1}}],["从链表中移除一项",{"2":{"170":1}}],["从链表中的删除指定位置的元素",{"2":{"101":1}}],["从链表的特定位置移除一项",{"2":{"170":1}}],["从链表删除指定的元素",{"2":{"101":1}}],["从左到右的方式存储数据",{"2":{"94":1}}],["从左到右遍历",{"2":{"38":3}}],["从节点",{"2":{"81":6}}],["从树中移除某个键",{"2":{"68":1}}],["从最低位",{"2":{"57":1}}],["从数组中选择一个元素作为基准",{"2":{"55":1}}],["从当前集合中取出每一个",{"2":{"217":1,"218":1,"219":1,"220":3}}],["从当前元素的下一个位置开始遍历",{"2":{"51":1}}],["从当前索引开始遍历",{"2":{"44":1}}],["从头到尾遍历数组",{"2":{"50":1}}],["从头到尾遍历数组的每个位置",{"2":{"36":1}}],["从起始索引开始遍历",{"2":{"44":2}}],["从根节点开始",{"2":{"40":1}}],["从右到左遍历",{"2":{"38":3}}],["从前往后遍历数组",{"2":{"36":1}}],["从下标",{"2":{"36":1}}],["从初始状态开始",{"2":{"31":1}}],["从初始状态出发",{"2":{"23":1}}],["从表格中提取最终的结果",{"2":{"23":1}}],["从而提高了排序的效率",{"2":{"53":1}}],["从而提高效率",{"2":{"22":1}}],["从而保持相等元素的相对顺序不变",{"2":{"52":1,"54":1}}],["从而保留小额钞票以应对后续的找零需求",{"2":{"35":1}}],["从而使得需要移除的区间数量最小",{"2":{"37":1}}],["从而希望导致结果是全局最优的算法",{"2":{"30":1}}],["从而减少不必要的计算",{"2":{"22":1}}],["从整个数组开始",{"2":{"18":1}}],["从第二个元素开始",{"2":{"52":1}}],["从第",{"2":{"11":1}}],["否则每次探测都是原地踏步的死循环",{"2":{"143":1}}],["否则会影响到之后其他的查询操作",{"2":{"141":1}}],["否则往右查找",{"2":{"78":1,"83":1}}],["否则回溯到上一步",{"2":{"40":1}}],["否则",{"2":{"36":2,"37":2}}],["否则无法找零",{"2":{"35":1}}],["否则返回",{"2":{"29":1,"35":2,"77":1,"203":1,"212":1,"213":1,"220":1,"226":1}}],["否则统计左右多数元素在整个区间内的出现次数",{"2":{"18":1}}],["否则递归调用函数",{"2":{"4":1,"5":1}}],["辅助函数",{"2":{"18":1}}],["解析",{"2":{"224":1}}],["解集不能包含重复的子集",{"2":{"44":1}}],["解释",{"2":{"20":1,"26":2,"27":1,"28":2,"29":1,"34":2,"35":2,"36":2,"37":3,"38":2,"45":1}}],["解题步骤",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":1,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["解决问题的能力",{"2":{"250":1}}],["解决问题的办法有很多",{"2":{"249":1}}],["解决问题方法的效率",{"2":{"244":1}}],["解决冲突常见的两种方案",{"2":{"138":1}}],["解决办法需自己去研究下",{"2":{"121":1}}],["解决最大子数组和问题",{"2":{"20":1}}],["解决子问题",{"2":{"18":1}}],["解决",{"2":{"15":1}}],["等待",{"2":{"201":1}}],["等依次探测",{"2":{"142":1}}],["等于",{"2":{"80":6,"83":6}}],["等方法",{"2":{"55":1}}],["等方法可以有效避免最坏情况",{"2":{"55":1}}],["等问题",{"2":{"41":2}}],["等",{"2":{"16":1,"186":1,"236":1}}],["如数据库系统",{"2":{"250":1}}],["如何以高效的方式组织和存储呢",{"2":{"244":1}}],["如何进行扩容",{"2":{"159":1}}],["如图",{"2":{"238":1}}],["如哈希表中还没插入任何元素时",{"2":{"141":1}}],["如哈夫曼编码",{"2":{"16":1}}],["如上图树的深度为",{"2":{"236":1}}],["如上图树的度为",{"2":{"236":1}}],["如上图节点",{"2":{"236":1}}],["如上图的",{"2":{"236":1}}],["如上图中",{"2":{"141":1}}],["如上图就是一张无权图",{"2":{"117":1}}],["如上图所示",{"2":{"65":1,"71":1}}],["如节点",{"2":{"80":6}}],["如下图所示",{"2":{"76":1,"79":2,"84":1,"89":1,"139":1}}],["如快速排序",{"2":{"52":1}}],["如处理",{"2":{"51":1}}],["如子集",{"2":{"41":1}}],["如解数独",{"2":{"41":1}}],["如全排列",{"2":{"41":1}}],["如组合总和",{"2":{"41":1}}],["如区间调度",{"2":{"32":1}}],["如背包问题的某些变种",{"2":{"32":1}}],["如背包问题",{"2":{"24":1}}],["如最小生成树",{"2":{"32":1}}],["如最长递增子序列",{"2":{"24":1}}],["如最短路径",{"2":{"24":1}}],["如统计符合某些条件的方案数量",{"2":{"24":1}}],["如",{"2":{"16":1,"29":1,"32":1,"136":1,"186":1,"236":1,"250":1}}],["如二分搜索",{"2":{"16":1}}],["如归并排序和快速排序",{"2":{"16":1}}],["如果栈里没有任何元素就返回",{"2":{"226":1}}],["如果值在集合中",{"2":{"212":1}}],["如果队列中不包含任何元素",{"2":{"203":1}}],["如果遍历完所有元素",{"2":{"195":1}}],["如果集合不存在该",{"2":{"189":1,"213":1,"220":1}}],["如果某个键值存在于这个字典中",{"2":{"187":1}}],["如果等于",{"2":{"155":1}}],["如果为空",{"2":{"195":1}}],["如果为",{"2":{"155":1,"156":1}}],["如果已经有值了",{"2":{"154":1}}],["如果原来已经存在该",{"2":{"154":1}}],["如果原来不存在该",{"2":{"154":1}}],["如果哈希表长度大于",{"2":{"150":1}}],["如果哈希表中不包含任何元素",{"2":{"150":1}}],["如果使用大",{"2":{"147":1}}],["如果发生冲突",{"2":{"143":1}}],["如果之前的数据是连续插入的",{"2":{"142":1}}],["如果相邻点未未访问状态",{"2":{"133":1}}],["如果相等元素存在",{"2":{"51":1}}],["如果图是一个稀疏图",{"2":{"121":1}}],["如果你找一本专门讲图的各个方面的书籍",{"2":{"117":1}}],["如果你能给每位顾客正确找零",{"2":{"35":1}}],["如果链表长度大于",{"2":{"101":1,"170":1}}],["如果链表中不包含任何元素",{"2":{"101":1,"170":1}}],["如果链表中没有该元素就返回",{"2":{"101":1,"170":1}}],["如果树中的每一个节点最多只能有两个子节点",{"2":{"86":1}}],["如果要删除的节点有两个子节点",{"2":{"81":1}}],["如果节点存在",{"2":{"68":1}}],["如果最大值不是当前节点",{"2":{"56":1}}],["如果右子节点大于当前节点",{"2":{"56":1}}],["如果左子节点大于当前节点",{"2":{"56":1}}],["如果左右部分的多数元素不同",{"2":{"18":1}}],["如果左右部分的多数元素相同",{"2":{"18":2}}],["如果输入不是数组或者数组长度小于等于",{"2":{"53":1}}],["如果待插入的元素与已排序部分的某个元素相等",{"2":{"52":1}}],["如果比需要排序的元素大",{"2":{"52":1}}],["如果比最大值小",{"2":{"12":1}}],["如果两个元素相等",{"2":{"54":1}}],["如果两个相等的元素相互比较",{"2":{"50":1}}],["如果两间相邻的房屋在同一晚上被小偷闯入",{"2":{"28":1}}],["如果数组在初始状态下已经接近有序",{"2":{"50":1}}],["如果数组长度小于等于",{"2":{"19":1}}],["如果它们的顺序不正确",{"2":{"50":1}}],["如果顺序相反则进行交换",{"2":{"50":1}}],["如果未找到目标元素",{"2":{"47":1}}],["如果子字符串",{"2":{"45":1}}],["如果子字符串为空",{"2":{"45":1}}],["如果子问题规模足够小",{"2":{"15":1}}],["如果满足则继续探索",{"2":{"40":1}}],["如果没有",{"2":{"154":1,"177":1,"183":1,"189":1}}],["如果没有发生冲突",{"2":{"143":1}}],["如果没有返回",{"2":{"36":1}}],["如果没有任何一种硬币组合能组成总金额",{"2":{"29":1}}],["如果能到达或超过最后一个下标",{"2":{"36":1}}],["如果能够给每个顾客正确找零",{"2":{"35":1}}],["如果在某一趟排序中没有交换操作发生",{"2":{"50":1}}],["如果在某一步能够到达或超过数组的最后一个位置",{"2":{"36":1}}],["如果在一轮排序过程中没有发生任何元素的交换",{"2":{"50":1}}],["如果在遍历过程中",{"2":{"36":1}}],["如果当前元素比最小元素索引小",{"2":{"51":1}}],["如果当前元素等于目标元素",{"2":{"47":1}}],["如果当前子字符串已经在缓存中",{"2":{"45":1}}],["如果当前子字符串",{"2":{"45":4}}],["如果当前孩子的评分高于后一个孩子且糖果数不大于后一个孩子",{"2":{"38":1}}],["如果当前孩子的评分高于前一个孩子",{"2":{"38":1}}],["如果当前孩子的评分比后一个孩子高且糖果数不大于后一个孩子",{"2":{"38":1}}],["如果当前孩子的评分比前一个孩子高",{"2":{"38":1}}],["如果当前区间的起始时间",{"2":{"37":2}}],["如果当前下标超过了能到达的最远位置",{"2":{"36":1}}],["如果当前位置在可达范围内",{"2":{"36":1}}],["如果当前位置大于",{"2":{"36":1}}],["如果当前饼干可以满足当前孩子的胃口",{"2":{"34":1}}],["如果可以",{"2":{"36":1}}],["如果都无法找零",{"2":{"35":1}}],["如果有的话",{"2":{"57":1}}],["如果有则找零",{"2":{"35":1}}],["如果有两个房子",{"2":{"28":1}}],["如果顾客付的是",{"2":{"35":3}}],["如果只有一个房子",{"2":{"28":1}}],["如果只有一个元素",{"2":{"20":1}}],["如果楼梯阶数为",{"2":{"26":1}}],["如果主元的位置小于目标位置",{"2":{"21":1}}],["如果主元的位置大于目标位置",{"2":{"21":1}}],["如果主元的位置正好是我们需要找的位置",{"2":{"21":1}}],["如果大于等于堆的最大值",{"2":{"12":1}}],["如果堆的容量还没有达到",{"2":{"12":1}}],["如果枢纽值的位置小于",{"2":{"12":1}}],["如果该枢纽值的位置为",{"2":{"12":1}}],["如果台阶数小于或等于",{"2":{"11":1}}],["如果",{"2":{"4":1,"5":1,"27":1,"29":2,"34":1,"36":1,"45":1,"53":1,"132":1,"141":1,"154":2,"164":1}}],["如果不存在",{"2":{"68":1}}],["如果不为空",{"2":{"65":1}}],["如果不能",{"2":{"34":1}}],["如果不包含",{"2":{"2":1}}],["如果不是数组或者数组长度小于等于",{"2":{"51":1,"52":1,"54":1,"55":1,"56":1}}],["如果不是数组",{"2":{"1":1}}],["如果是一个无向图",{"2":{"121":1}}],["如果是排序好的数组",{"2":{"66":1}}],["如果是右边数组还有剩余",{"2":{"54":1}}],["如果是左边数组还有剩余",{"2":{"54":1}}],["如果是",{"2":{"36":1}}],["如果是则直接返回原数组",{"2":{"2":1}}],["如果是则直接返回",{"2":{"2":1}}],["如果是数组",{"2":{"1":1}}],["合并所有桶中的数字成为新的待排序数组",{"2":{"57":1}}],["合并分组",{"2":{"57":1}}],["合并两个有序子数组以形成一个有序的整体",{"2":{"54":1}}],["合并两个有序数组",{"2":{"19":1}}],["合并两个有序的子数组成一个有序的数组",{"2":{"19":1}}],["合并排序好的左右两部分",{"2":{"19":1}}],["合并",{"2":{"15":1,"18":1,"19":1,"20":1,"54":2}}],["dfsvisit",{"2":{"133":3}}],["dfs",{"0":{"133":1},"2":{"131":2,"133":4}}],["degree",{"2":{"236":1}}],["dec",{"2":{"230":5}}],["dec2bin",{"2":{"230":1,"231":3}}],["dequeue",{"2":{"132":1,"195":4,"196":3,"203":1,"204":2,"205":3,"207":3}}],["depth",{"2":{"131":1,"236":1}}],["delete",{"2":{"189":1,"213":1,"220":1}}],["deletecount",{"2":{"63":1}}],["delnode",{"2":{"82":6,"83":6}}],["data",{"0":{"108":1},"2":{"105":1,"106":1,"107":1,"108":3,"109":1,"110":1,"112":13,"172":4,"173":2,"174":1,"175":2,"176":4,"177":5,"178":6,"180":4,"183":25,"239":6,"243":2}}],["daysofweek",{"2":{"60":2}}],["doublynode",{"2":{"103":2,"104":1,"105":1,"106":1,"112":2}}],["doublylinkedlist",{"0":{"103":1},"2":{"103":2,"112":1,"113":22}}],["dog",{"2":{"45":8}}],["dlr",{"2":{"71":1}}],["d",{"2":{"71":1,"88":1,"94":1,"120":4,"121":2,"122":1,"129":5,"132":1,"133":1,"196":4,"205":4,"223":6,"224":2,"236":4,"238":1}}],["differenceset",{"2":{"218":3,"220":3}}],["difference",{"2":{"218":2,"220":2}}],["dict",{"2":{"186":1}}],["dictonary",{"2":{"186":1}}],["dictionay",{"2":{"124":1}}],["digit",{"2":{"57":2}}],["digitbuckets",{"2":{"57":3}}],["digitcount",{"2":{"57":2}}],["dijkstra",{"2":{"32":1}}],["divideandconquer",{"2":{"20":4}}],["divide",{"2":{"15":1,"54":2,"55":1}}],["dp",{"2":{"11":6,"26":16,"27":13,"28":18,"29":19}}],["分析",{"2":{"206":1}}],["分割",{"2":{"54":2}}],["分组排序",{"2":{"53":1}}],["分发糖果",{"0":{"38":1}}],["分发饼干",{"0":{"34":1}}],["分配给孩子",{"2":{"34":1}}],["分区过程",{"2":{"55":1}}],["分区操作",{"2":{"21":1}}],["分区方案",{"2":{"21":1}}],["分区",{"2":{"21":1,"55":1}}],["分别指向子节点",{"2":{"238":2}}],["分别对这些子数组进行排序",{"2":{"54":1}}],["分别对左右两部分进行排序",{"2":{"19":1}}],["分别进行排序",{"2":{"34":1}}],["分别解决这些子问题",{"2":{"14":1,"20":1}}],["分治算法主函数",{"2":{"18":1}}],["分治法求解最大子数组和",{"2":{"20":1}}],["分治法",{"2":{"14":1}}],["分布式计算",{"2":{"16":1}}],["分解数组",{"2":{"19":1,"20":1}}],["分解",{"2":{"15":1,"18":1}}],["分而治之的基本思想是将问题分解成子问题",{"2":{"20":1}}],["分而治之的思想是一种有效的方法",{"2":{"20":1}}],["分而治之的应用",{"0":{"17":1},"1":{"18":1,"19":1,"20":1,"21":1}}],["分而治之",{"0":{"14":1},"1":{"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1},"2":{"14":1}}],["重置所有属性",{"2":{"160":1,"164":1}}],["重新锁定一般的路程",{"2":{"249":1}}],["重新加入到队列中",{"2":{"207":1}}],["重新加入到队尾",{"2":{"207":1}}],["重新",{"2":{"160":1,"164":1}}],["重新调整哈希表大小",{"2":{"160":1,"164":1}}],["重新调整堆顶元素为最大值",{"2":{"12":1}}],["重新排列数组",{"2":{"55":1}}],["重复步骤",{"2":{"57":1}}],["重复这个过程",{"2":{"54":1}}],["重复插入",{"2":{"52":1}}],["重复以上步骤",{"2":{"51":1}}],["重复",{"2":{"51":1}}],["重复上述步骤",{"2":{"50":1,"53":1,"56":1}}],["重复遍历",{"2":{"50":1}}],["重写",{"2":{"8":1,"104":1,"105":1,"106":1,"107":1,"108":1,"112":4,"195":2}}],["xpoet",{"2":{"190":6}}],["x+3^3^",{"2":{"142":1}}],["x+3",{"2":{"142":1}}],["x+2^2^",{"2":{"142":1}}],["x+2",{"2":{"142":1}}],["x+1^2^",{"2":{"142":1}}],["x+1",{"2":{"142":1}}],["x",{"2":{"142":2,"147":1}}],["xx",{"2":{"113":2}}],["x26",{"2":{"12":2,"19":2,"34":2,"35":2,"52":2,"53":2,"54":2,"56":4,"79":2,"83":2,"156":2,"160":2,"163":2,"164":2}}],["x3c",{"2":{"2":2,"10":2,"11":2,"12":8,"18":1,"19":6,"20":1,"21":3,"26":2,"27":2,"28":2,"29":1,"34":2,"36":1,"38":1,"43":1,"44":1,"47":1,"48":2,"50":2,"51":3,"52":2,"53":2,"54":6,"55":3,"56":3,"57":3,"58":4,"69":1,"77":2,"78":1,"80":2,"83":3,"105":2,"106":2,"107":2,"112":4,"128":2,"129":1,"131":1,"132":1,"133":2,"154":1,"156":2,"160":1,"162":4,"163":1,"164":3,"175":4,"176":2,"178":2,"179":2,"183":10,"195":2,"207":1}}],["方案二",{"2":{"136":1}}],["方案一",{"2":{"136":1}}],["方式",{"2":{"81":6}}],["方便模拟最大堆",{"2":{"12":1}}],["方法进行删除",{"2":{"207":1}}],["方法非常类似",{"2":{"203":1}}],["方法中添加如下代码",{"2":{"163":2}}],["方法中关于数组扩容的相关操作",{"2":{"163":1}}],["方法和删除元素的",{"2":{"163":1}}],["方法和获取质数的",{"2":{"163":1}}],["方法二",{"2":{"162":1}}],["方法一",{"2":{"162":1}}],["方法找到数组中的最小值",{"2":{"3":1}}],["方法找到数组中的最大值",{"2":{"3":1}}],["方法的参数",{"2":{"3":2}}],["方法将数组展开为",{"2":{"3":2}}],["方法",{"0":{"6":1,"125":1,"128":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1},"1":{"126":1,"127":1,"128":1},"2":{"1":1,"8":1,"46":1,"49":1,"69":1,"101":1,"160":3,"163":1,"170":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"244":3}}],["方法遍历传入的数组",{"2":{"1":1}}],["获取余数",{"2":{"230":1}}],["获取栈中元素个数",{"2":{"227":1}}],["获取集合中所有的",{"2":{"213":1,"220":1}}],["获取集合中的",{"2":{"213":1,"220":1}}],["获取最后剩下的那个人",{"2":{"207":1}}],["获取最临近的质数",{"2":{"163":1,"164":1}}],["获取字典中的键值对个数",{"2":{"189":1}}],["获取所有的",{"2":{"189":2}}],["获取指定",{"2":{"176":1,"183":1,"189":1}}],["获取指定位置的",{"2":{"183":1}}],["获取指定位置的元素",{"2":{"101":1}}],["获取指定位置",{"2":{"176":1}}],["获取对应位置的元素",{"2":{"170":1}}],["获取要映射到",{"2":{"154":1,"164":1}}],["获取索引值",{"2":{"154":1}}],["获取哈希表中特定位置的元素",{"2":{"150":1}}],["获取链表的长度",{"2":{"112":1,"182":1,"183":1}}],["获取后续节点",{"2":{"82":1,"83":1}}],["获取二叉搜索树最大值",{"2":{"76":1}}],["获取二叉搜索树最小值",{"2":{"76":1}}],["获取数据时比较麻烦",{"2":{"135":1}}],["获取数组中最大数字的位数",{"2":{"57":1}}],["获取数组长度",{"2":{"51":1}}],["获取数字的位数",{"2":{"57":1}}],["获取数字的指定位数上的数字",{"2":{"57":1}}],["获取",{"2":{"12":1,"155":1,"164":1}}],["获取清理后的字符串的反转版",{"2":{"7":1}}],["我们不仅仅要把书放进入",{"2":{"244":1}}],["我们知道",{"2":{"244":1}}],["我们知道树可以用来模拟很多现实的数据结构",{"2":{"116":1}}],["我们为了实现某些功能",{"2":{"221":1}}],["我们已经有办法处理映射到相同下标值的情况",{"2":{"148":1}}],["我们只能解决冲突",{"2":{"138":1}}],["我们通常会将单词转化成大数字",{"2":{"137":1}}],["我们平时使用的大于",{"2":{"136":1}}],["我们也必须遍历一行来找出这个边",{"2":{"121":1}}],["我们用一个二维数组来表示顶点之间的连接",{"2":{"121":1}}],["我们使用三种颜色来反应它们的状态",{"2":{"131":1}}],["我们使用",{"2":{"120":1}}],["我们抽象成了",{"2":{"120":1}}],["我们来看一张有向和带权的图",{"2":{"117":1}}],["我们在学习树的时候",{"2":{"117":1}}],["我们就可以使用图来模拟它们",{"2":{"116":1}}],["我们就还需要到后半部分去寻找后半部分",{"2":{"12":1}}],["我们会发现",{"2":{"116":1}}],["我们称这种树为非平衡树",{"2":{"84":1}}],["我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树",{"2":{"66":1}}],["我们要尽可能多地保留区间",{"2":{"37":1}}],["我们需要排查",{"2":{"249":1}}],["我们需要在使用常量的地方",{"2":{"148":1}}],["我们需要保证树总是平衡的",{"2":{"84":1}}],["我们需要递归地尝试在字符串",{"2":{"45":1}}],["我们需要遍历一次账单数组",{"2":{"35":1}}],["我们需要继续对左半部分进行划分",{"2":{"12":1}}],["我们无法退回",{"2":{"35":1}}],["我们找还一张",{"2":{"35":1}}],["我们收取一张",{"2":{"35":2}}],["我们按顺序收取",{"2":{"35":2}}],["我们可以看成是步长为",{"2":{"142":1}}],["我们可以将它进行特殊处理",{"2":{"141":1}}],["我们可以将这个饼干",{"2":{"34":1}}],["我们可以很快的找到一个顶点和哪些顶点有连线",{"2":{"121":1}}],["我们可以有效地计算出不触动警报装置的情况下",{"2":{"28":1}}],["我们可以使用一个数组来存储起来",{"2":{"120":1}}],["我们可以使用回溯算法结合动态规划进行优化",{"2":{"45":1}}],["我们可以使用快速选择算法",{"2":{"21":1}}],["我们可以使用分而治之的思想",{"2":{"19":1}}],["我们将每一个数字都对",{"2":{"139":1}}],["我们将数组分成两个部分",{"2":{"20":1}}],["我们将该元素与堆的最大值进行比较",{"2":{"12":1}}],["大海捞针",{"2":{"244":1}}],["大一点点的节点",{"2":{"81":1,"82":1}}],["大多数强类型的编程语言里面数组通常情况下都用于存储一系列同一种数据类型的值",{"2":{"59":1}}],["大大减少了数据移动的次数",{"2":{"53":1}}],["大于等于",{"2":{"37":2}}],["大于或等于数组的最后一个下标",{"2":{"36":1}}],["大的元素",{"2":{"21":1}}],["大时",{"2":{"12":1}}],["大家都知道斐波那契数列",{"2":{"10":1}}],["那么",{"2":{"236":1}}],["那么就是修改操作",{"2":{"154":1}}],["那么就是插入操作",{"2":{"154":1}}],["那么就把",{"2":{"136":1}}],["那么效率就会更高",{"2":{"143":1}}],["那么线性探测就是按照下标值",{"2":{"142":1}}],["那么新插入的一个数据可能需要探测很长的距离",{"2":{"142":1}}],["那么是一件非常麻烦的事情",{"2":{"122":1}}],["那么矩阵中将存在大量的",{"2":{"121":1}}],["那么这种情况下会造成空间的浪费",{"2":{"121":1}}],["那么这些",{"2":{"120":1}}],["那么说明这条边可以保证",{"2":{"117":1}}],["那么两者满足关系",{"2":{"89":1}}],["那么可以偷窃的最高金额就是该房子的金额",{"2":{"28":1}}],["那么我们可以通过",{"2":{"122":1}}],["那么我们则将最大值与其交换",{"2":{"12":1}}],["那么我们已经找到了前",{"2":{"12":1}}],["那么枢纽值和它前面的所有数字就是最小的",{"2":{"12":1}}],["这在处理大数据或实时系统中尤为重要",{"2":{"250":1}}],["这些联系可以通过定义相关的函数来给出",{"2":{"243":1}}],["这些缺点微不足道",{"2":{"99":1}}],["这条链条常使用的数据结构为数组或链表",{"2":{"139":1}}],["这副图来帮助理解过程",{"2":{"133":1}}],["这一端被称为栈顶",{"2":{"222":1}}],["这一步是完成bfs的关键",{"2":{"132":1}}],["这一种方法的平均时间复杂度为",{"2":{"12":2}}],["这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂度",{"2":{"12":1}}],["这两种遍历算法",{"2":{"131":1}}],["这两个都是非常重要的图信息",{"2":{"119":1}}],["这两个特殊的节点有特殊的名字",{"2":{"82":1}}],["这意味着我们浪费了计算机存储空间来表示根本不存在的边",{"2":{"121":1}}],["这里不做封装",{"2":{"212":1}}],["这里我们重新封装一个",{"2":{"211":1}}],["这里我们选择归并排序作为实现方法",{"2":{"19":1}}],["这里使用",{"2":{"209":1}}],["这里直接使用函数的调用栈",{"2":{"133":1}}],["这里实现的是无向图",{"2":{"127":1}}],["这里采用邻接表的形式",{"2":{"124":1}}],["这里的深度优先搜索算法可以使用栈完成",{"2":{"133":1}}],["这里的权重可以是任意你希望表示的数据",{"2":{"117":1}}],["这里的边不要叫做路径",{"2":{"117":1}}],["这里介绍几个比较常见的术语",{"2":{"117":1}}],["这里",{"2":{"117":1}}],["这里暂不讨论",{"2":{"82":1}}],["这里可以使用递归实现",{"2":{"77":1}}],["这里所说的树的遍历不仅仅针对二叉搜索树",{"2":{"70":1}}],["这就是数据结构需要考虑的问题",{"2":{"244":1}}],["这就是数组二分法查找效率之所以高的原因",{"2":{"66":1}}],["这就会造成哈希表效率的降低",{"2":{"159":1}}],["这就意味着下标值为",{"2":{"141":1}}],["这就构成了完美二叉树",{"2":{"91":1}}],["这就要求树中每个节点左边的子孙节点的个数",{"2":{"84":1}}],["这就相当于我们假设前",{"2":{"12":1}}],["这也就是二叉搜索树中",{"2":{"65":1}}],["这种表示方法可以完整地记录每个节点的数据",{"2":{"239":1}}],["这种方法缺点在于我们无法确定某一结点的引用数",{"2":{"238":1}}],["这种方法虽然能实现质数的判断",{"2":{"162":1}}],["这种算法把求",{"2":{"147":1}}],["这种一连串填充单元就称为聚集",{"2":{"141":1}}],["这种变换我们可以称之为哈希函数",{"2":{"135":1}}],["这种情况会造成步长不一的一种聚集",{"2":{"142":1}}],["这种情况称为冲突",{"2":{"138":1}}],["这种情况下需要从要删除节点下面的子节点中找到一个合适的节点",{"2":{"81":1}}],["这种情况十分复杂",{"2":{"81":1}}],["这种特点使得二叉搜索树的查询效率非常高",{"2":{"65":1}}],["这种思想在很多算法中都有广泛的应用",{"2":{"14":1}}],["这会导致递归树退化为链表形式",{"2":{"55":1}}],["这样就成为了一棵二叉树",{"2":{"240":1}}],["这样第",{"2":{"207":1}}],["这样计算机直接运算二进制数据",{"2":{"148":1}}],["这样一次性探测比较长的距离",{"2":{"142":1}}],["这样在查找时遇到",{"2":{"141":1}}],["这样的单词",{"2":{"136":1}}],["这样的树就称为二叉树",{"2":{"86":1}}],["这样单词也可以用该种方式来表示",{"2":{"136":1}}],["这样会浪费很大的存储空间",{"2":{"94":1}}],["这样方便之后删除节点时改变相关节点的指向",{"2":{"78":1}}],["这样可以根据下标值获取到整个数组或链表",{"2":{"139":1}}],["这样可以保证",{"2":{"130":1}}],["这样可以保证每次选择的区间结束时间尽可能早",{"2":{"37":1}}],["这样可以大大减少排序的比较次数",{"2":{"50":1}}],["这样可以减少不必要的比较和交换操作",{"2":{"50":1}}],["这样",{"2":{"50":1,"143":1}}],["这满足题面中的两个条件",{"2":{"38":1}}],["这个单词本意就是解决问题的办法",{"2":{"248":1}}],["这个方法和数组的",{"2":{"226":1}}],["这个列表有很多中方式来存储",{"2":{"122":1}}],["这个时候",{"2":{"116":1,"120":1}}],["这个过程类似于每次从一堆未排序的卡片中选出最小",{"2":{"51":1}}],["这个区间与上一个区间重叠",{"2":{"37":1}}],["这个区间需要移除",{"2":{"37":1}}],["这个孩子会得到满足",{"2":{"34":1}}],["这是最坏的情况",{"2":{"249":1}}],["这是因为归并排序在合并过程中需要一个额外的数组来暂存数据",{"2":{"54":1}}],["这是因为排序需要",{"2":{"34":1}}],["这是能让孩子们满足胃口的饼干的最小尺寸",{"2":{"34":1}}],["这",{"2":{"12":2}}],["例如每次选择的基准",{"2":{"55":1}}],["例如数组已经有序时",{"2":{"21":1}}],["例如",{"2":{"12":1,"27":1,"51":1,"57":1,"136":1,"143":1,"244":1,"250":1}}],["输入数据是逆序的",{"2":{"50":1,"52":1}}],["输入",{"2":{"12":2,"18":2,"19":2,"20":3,"21":2,"26":2,"27":3,"28":2,"29":3,"34":2,"35":2,"36":2,"37":3,"38":2,"43":3,"44":2,"45":3}}],["输出深度优先",{"2":{"133":1}}],["输出图结构",{"2":{"128":1}}],["输出节点的顺序应为",{"2":{"72":1,"73":1}}],["输出",{"2":{"4":2,"5":1,"7":2,"10":6,"11":6,"12":3,"18":6,"19":4,"20":6,"21":4,"26":6,"27":6,"28":6,"29":8,"34":6,"35":4,"36":7,"37":8,"38":7,"43":6,"44":4,"45":6}}],["输出去重后的数组",{"2":{"2":2}}],["输出扁平化后的数组",{"2":{"1":1}}],["keys",{"2":{"187":1,"189":3,"190":2,"213":2,"220":2}}],["key",{"0":{"154":1,"155":1,"156":1},"2":{"67":5,"68":3,"69":11,"71":1,"72":1,"73":1,"76":2,"77":19,"78":4,"83":5,"135":2,"143":2,"148":1,"150":3,"154":13,"155":8,"156":6,"164":18,"185":2,"187":4,"189":19}}],["k++",{"2":{"57":1}}],["kruskal",{"2":{"32":1}}],["ksmallestnums",{"2":{"12":4}}],["kthsmallest",{"2":{"12":2}}],["k",{"0":{"12":1,"21":1},"2":{"12":34,"21":12,"45":2,"50":2,"57":13,"58":9,"89":2,"238":1}}],["有一天高架线中有其中一米出现了故障",{"2":{"249":1}}],["有一个火车头",{"2":{"169":1}}],["有不存在的返回",{"2":{"219":1,"220":1}}],["有紧急情况",{"2":{"192":1}}],["有些情况下不需要输入",{"2":{"247":1}}],["有些编程语言中称这种映射关系为",{"2":{"186":1}}],["有些编程语言中称这种映射关系为字典",{"2":{"186":1}}],["有些语言称为指针",{"2":{"168":1}}],["有些优化过的增量序列可以达到",{"2":{"53":1}}],["有了编码系统后",{"2":{"136":1}}],["有没有一种数据结构",{"2":{"135":1}}],["有边",{"2":{"122":1}}],["有可能还表示其他含义的数据",{"2":{"120":1}}],["有向图表示的图中的边是有方向的",{"2":{"117":1}}],["有向图",{"2":{"117":1}}],["有左右两个子树的二叉树",{"2":{"88":1}}],["有左子节点时",{"2":{"69":1}}],["有六种情况",{"2":{"80":1}}],["有右子节点时",{"2":{"69":1}}],["有很大关系",{"2":{"53":1}}],["有三种方法可以爬到楼顶",{"2":{"26":1}}],["有两种算法可以对图进行遍历",{"2":{"131":1}}],["有两种方案",{"2":{"202":1}}],["有两种方式",{"2":{"81":1}}],["有两种方法可以爬到楼顶",{"2":{"26":1}}],["有两种选择",{"2":{"28":1}}],["有两级台阶时",{"2":{"11":1}}],["有",{"2":{"11":1,"224":1}}],["只要能正确找到对应节点即可",{"2":{"240":1}}],["只要查询到空位置",{"2":{"141":1}}],["只返回元素信息与",{"2":{"203":1}}],["只允许在表的后端",{"2":{"199":1}}],["只允许在表的前端",{"2":{"199":1}}],["只能被",{"2":{"162":1}}],["只能从头遍历到尾或者从尾遍历到头",{"2":{"98":1}}],["只不过哈希表能够通过哈希函数把字符串转化为对应的下标值",{"2":{"135":1}}],["只不过是遍历的顺序不一样了",{"2":{"72":1,"73":1}}],["只缺失右侧若干叶子节点",{"2":{"92":1}}],["只存在右节点",{"2":{"80":1,"83":1}}],["只存在",{"2":{"80":2,"83":2}}],["只存在左节点",{"2":{"80":1,"83":1}}],["只需要遍历",{"2":{"162":1}}],["只需要几个机器指令即可完成",{"2":{"135":1}}],["只需要",{"2":{"121":1}}],["只需要从根节点开始将需要查找节点的",{"2":{"77":1}}],["只需要一直向左",{"2":{"76":1}}],["只需要查找",{"2":{"66":1}}],["只需要常数级的额外空间",{"2":{"53":1}}],["只需要常数级的辅助空间",{"2":{"51":1}}],["只需要常数级别的额外空间来存储",{"2":{"35":1}}],["只需要常量级别的额外空间",{"2":{"34":1,"36":1}}],["只需要前两个状态的值",{"2":{"28":1}}],["只有右子树",{"2":{"88":1}}],["只有左子树",{"2":{"88":1}}],["只有一个节点的二叉树",{"2":{"88":1}}],["只有一个元素",{"2":{"36":1}}],["只有一个元素时",{"2":{"18":1}}],["只有一级台阶时",{"2":{"11":1}}],["只有",{"2":{"11":1}}],["只适合于数组中元素都是整数的情况",{"2":{"1":1}}],["不过",{"2":{"238":1}}],["不过初始两项的值变为了",{"2":{"11":1}}],["不对栈做任何修改",{"2":{"226":1}}],["不停地把相同的函数",{"2":{"223":1}}],["不会把函数弹出栈",{"2":{"223":1}}],["不会改变相等元素的相对位置",{"2":{"57":1}}],["不移除元素",{"2":{"203":1}}],["不用判断优先级",{"2":{"195":1}}],["不用通过循环找到最后一个节点",{"2":{"104":1,"112":1}}],["不断地从栈中取出元素",{"2":{"230":1}}],["不断地调用自己",{"2":{"223":1}}],["不断地更新",{"2":{"175":1,"183":1}}],["不断通过叠加来实现第",{"2":{"10":1}}],["不为空时",{"2":{"173":1,"183":1}}],["不再往下执行",{"2":{"164":1}}],["不再符合该情况",{"2":{"69":1}}],["不是",{"2":{"207":1}}],["不是则",{"2":{"163":1}}],["不是质数",{"2":{"162":1,"163":3}}],["不存在的即为差集",{"2":{"218":1,"220":1}}],["不存在则创建",{"2":{"154":1,"164":1}}],["不存在",{"2":{"154":1}}],["不存在时通过",{"2":{"69":1}}],["不同于数组",{"2":{"168":1}}],["不同探测方式性能的比较",{"0":{"145":1}}],["不同的关键字即使映射到相同的数组下标",{"2":{"143":1}}],["不然哈希化后的结果仍是原来位置",{"2":{"143":1}}],["不相同时",{"2":{"141":1}}],["不考虑大写情况",{"2":{"136":1}}],["不像数组",{"2":{"135":1}}],["不能按照固定顺序遍历哈希表中的元素",{"2":{"235":1}}],["不能重复意味着相同的对象在集合中只会存在一份",{"2":{"210":1}}],["不能重复的元素构成",{"2":{"210":1}}],["不能小于",{"2":{"175":1,"183":1}}],["不能被",{"2":{"162":1}}],["不能输出为",{"2":{"143":1}}],["不能将该位置下标的内容设置为",{"2":{"141":1}}],["不能放置相同的",{"2":{"135":1}}],["不能说",{"2":{"117":1}}],["不能保证一定可以",{"2":{"117":1}}],["不做赘述",{"2":{"117":1}}],["不需要排序",{"2":{"51":1,"52":1,"53":1,"54":1,"55":1,"56":1}}],["不需要额外的空间",{"2":{"37":1}}],["不需要额外的空间来存储数组",{"2":{"21":1}}],["不包括输入和输出所占用的空间",{"2":{"18":1,"20":1}}],["跳",{"2":{"36":1}}],["跳跃游戏",{"0":{"36":1}}],["跳上",{"2":{"11":1}}],["跳台阶的问题是一个动态规划的问题",{"2":{"11":1}}],["跳台阶",{"0":{"11":1}}],["级跳上",{"2":{"11":1}}],["级或者",{"2":{"11":1}}],["级的台阶总共有多少种跳法",{"2":{"11":1}}],["级",{"2":{"11":2}}],["级台阶的跳法数",{"2":{"11":1}}],["级台阶开始计算",{"2":{"11":1}}],["级台阶一共有两种方案",{"2":{"11":1}}],["级台阶",{"2":{"11":2}}],["一定在有限步骤之后终止",{"2":{"247":1}}],["一定也是",{"2":{"121":1}}],["一般情况下是申请一个更大的数组",{"2":{"167":1}}],["一般从头到尾",{"2":{"98":1}}],["一整块内存",{"2":{"167":1}}],["一组边",{"2":{"116":1}}],["一组顶点",{"2":{"116":1}}],["一个有限指令集",{"2":{"247":1}}],["一个庞大的图书馆中存放了大量的书籍",{"2":{"244":1}}],["一个",{"2":{"207":1,"230":1}}],["一个图包含很多顶点",{"2":{"119":1}}],["一个顶点的度是相邻顶点的数量",{"2":{"117":1}}],["一个二叉树的第",{"2":{"89":1}}],["一个指向孩子的胃口数组",{"2":{"34":1}}],["一直查找新节点适合插入的位置",{"2":{"69":1}}],["一直这样递归下去",{"2":{"4":1}}],["一种较为复杂的序列",{"2":{"53":1}}],["一种是从",{"2":{"11":2}}],["一部分是已排序的",{"2":{"51":1}}],["一部分是未排序的",{"2":{"51":1}}],["一开始你手头没有任何零钱",{"2":{"35":1}}],["一次购买一杯",{"2":{"35":1}}],["一夜之内能够偷窃到的最高金额",{"2":{"28":1}}],["一步一级或一步两级",{"2":{"11":1}}],["一只青蛙一次可以跳上",{"2":{"11":1}}],["个引用",{"2":{"238":2}}],["个互不相交的有限集合",{"2":{"235":1}}],["个节点构成的有限集合",{"2":{"235":1}}],["个一次多项式的值",{"2":{"147":1}}],["个人的信息",{"2":{"135":1}}],["个子节点",{"2":{"91":1}}],["个子集",{"2":{"44":1}}],["个条件属于二叉树",{"2":{"65":1}}],["个桶",{"2":{"57":1}}],["个位置插入",{"2":{"105":1,"106":1,"112":1}}],["个位",{"2":{"57":1}}],["个糖果",{"2":{"38":2}}],["个孩子站成一排",{"2":{"38":1}}],["个孩子的胃口值分别是",{"2":{"34":2}}],["个房子时可以偷窃到的最高金额",{"2":{"28":1}}],["个台阶",{"2":{"26":1}}],["个元素就排到了队列的最前面",{"2":{"207":1}}],["个元素先删除后添加到队列末尾",{"2":{"207":1}}],["个元素时就停止数数",{"2":{"207":1}}],["个元素",{"2":{"21":1,"63":1,"224":1}}],["个不同的元素",{"2":{"21":1}}],["个最大的元素",{"2":{"21":2}}],["个最大元素",{"0":{"21":1},"2":{"21":1}}],["个最小数",{"2":{"12":1}}],["个值还在左半部分",{"2":{"12":1}}],["个整数",{"2":{"12":1}}],["个斐波那契数",{"2":{"10":1}}],["个数据",{"2":{"66":1}}],["个数就是最小的",{"2":{"12":1}}],["个数不一定是按序排序的",{"2":{"12":1}}],["个数字是",{"2":{"12":1}}],["个数字",{"2":{"12":1}}],["个数",{"0":{"12":1},"2":{"10":1,"12":5,"213":1,"220":1}}],["当需要在链表中间位置插入或删除数据时",{"2":{"235":1}}],["当不确定循环次数时",{"2":{"230":1}}],["当新开启的线程所需的资源不足时就先放入线程队列",{"2":{"201":1}}],["当开启多线程时",{"2":{"201":1}}],["当链表中一个节点也没有的时候",{"2":{"169":1}}],["当装填因子",{"2":{"160":1}}],["当使用者传入一个",{"2":{"154":1}}],["当删除",{"2":{"141":1}}],["当查询",{"2":{"141":1}}],["当要查找张三的号码时",{"2":{"135":1}}],["当然",{"2":{"120":1}}],["当插入数据分布性较大的一组数据时",{"2":{"142":1}}],["当插入",{"2":{"141":1}}],["当插入一组有序数据",{"2":{"84":1}}],["当插入的数据是有序的数据",{"2":{"84":1}}],["当该叶子节点不为根节点时也有两种情况",{"2":{"79":1}}],["当该叶子节点为根节点时",{"2":{"79":1}}],["当该枢纽值的位置比",{"2":{"12":1}}],["当",{"2":{"69":6,"80":2,"173":1,"183":1,"235":1}}],["当每次划分的子数组都比较均匀时",{"2":{"55":1}}],["当增量为",{"2":{"53":1}}],["当输入数据已经有序时",{"2":{"52":1}}],["当输入数据已经是有序时",{"2":{"50":1}}],["当还有未排序的元素时",{"2":{"50":1}}],["当路径长度等于输入数组长度时",{"2":{"43":2}}],["当到达叶子节点或者无法继续探索时",{"2":{"40":1}}],["当遇到某一步无法继续前进时",{"2":{"39":1}}],["当前节点初始化为",{"2":{"175":1,"183":1}}],["当前数组不能满足容量需求时",{"2":{"167":1}}],["当前存放的元素个数",{"2":{"153":1,"164":1}}],["当前区间与上一个区间重叠",{"2":{"37":1}}],["当前区间可以保留",{"2":{"37":1}}],["当前饼干可以满足当前孩子",{"2":{"34":1}}],["当前斐波那契数是前两个数之和",{"2":{"10":1}}],["当孩子和饼干都没有处理完时进行匹配",{"2":{"34":1}}],["当两个指针都到达数组末尾时",{"2":{"34":1}}],["当数组长度为",{"2":{"20":1}}],["当数组长度小于等于",{"2":{"19":1}}],["当元素为数组时递归调用",{"2":{"1":1}}],["overflow",{"2":{"223":1}}],["otherset",{"2":{"216":3,"217":3,"218":3,"219":3,"220":12}}],["out",{"2":{"199":1,"222":1}}],["output",{"2":{"196":2}}],["object",{"2":{"189":2,"209":1,"213":2,"220":2}}],["oldstorage",{"2":{"159":2,"160":3,"164":3}}],["of",{"2":{"29":1,"35":1,"37":1,"45":2,"151":1,"155":1,"160":2,"164":3,"195":1,"204":1,"207":1,"216":2,"217":1,"218":1,"219":1,"220":5,"227":1}}],["o",{"2":{"10":2,"12":3,"18":4,"19":3,"20":3,"21":6,"26":2,"27":2,"28":5,"29":2,"34":4,"35":2,"36":2,"37":2,"38":3,"43":3,"44":2,"45":2,"47":1,"48":1,"50":7,"51":8,"52":8,"53":7,"54":7,"55":11,"56":8,"57":7,"58":7,"84":6,"135":1,"147":3,"168":1}}],["only",{"2":{"9":1}}],["第",{"2":{"35":2,"66":4}}],["第三次找",{"2":{"66":1}}],["第三个孩子只得到",{"2":{"38":1}}],["第三个孩子分发",{"2":{"38":2}}],["第三种方法是维护一个容量为",{"2":{"12":1}}],["第三项以后的值都等于前面两项的和",{"2":{"10":1}}],["第二种方案",{"2":{"136":1}}],["第二种思路是由于我们只需要获得最小的",{"2":{"12":1}}],["第二次哈希化需要满足以下两点",{"2":{"143":1}}],["第二次找",{"2":{"66":1}}],["第二次选择",{"2":{"51":1}}],["第二层循环",{"2":{"53":1}}],["第二个参数为",{"2":{"62":1}}],["第二个",{"2":{"38":2,"51":1}}],["第二项为",{"2":{"10":1}}],["第一个弹出栈空间",{"2":{"222":1}}],["第一个顶点和最后一个顶点相同的路径称为回路",{"2":{"117":1}}],["第一种方案",{"2":{"136":1}}],["第一种思路是首先将数组排序",{"2":{"12":1}}],["第一步",{"2":{"78":1,"163":1}}],["第一次找",{"2":{"66":1}}],["第一次选择",{"2":{"51":1}}],["第一层循环",{"2":{"53":1}}],["第一项为",{"2":{"10":1}}],["思路",{"2":{"10":1,"11":1,"12":1}}],["项值的构建",{"2":{"10":1}}],["项",{"2":{"10":1,"203":1}}],["斐波那契数列的第二个数",{"2":{"10":1}}],["斐波那契数列的第一个数",{"2":{"10":1}}],["斐波那契数列的规律是",{"2":{"10":1}}],["斐波那契数列",{"0":{"10":1}}],["示例测试",{"2":{"19":1,"20":1,"21":1,"26":1,"27":1,"28":2,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["示例",{"2":{"18":2,"19":2,"20":3,"21":2,"26":2,"27":3,"28":2,"29":3,"34":2,"35":2,"36":2,"37":3,"38":2,"43":3,"44":2,"45":3,"57":1,"58":1}}],["示例使用",{"2":{"9":1,"10":1,"11":1}}],["示例用法",{"2":{"7":1}}],[">>",{"2":{"53":2,"54":1}}],[">=",{"2":{"20":1,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"52":1,"53":3,"56":1,"176":1,"178":1,"179":1,"183":3}}],[">",{"2":{"9":1,"18":1,"20":2,"27":1,"35":2,"36":1,"38":2,"50":2,"51":1,"52":1,"53":1,"56":3,"58":2,"62":1,"63":1,"64":2,"77":2,"105":1,"106":1,"107":1,"112":2,"113":2,"128":1,"151":2,"154":2,"156":1,"160":3,"163":3,"164":3,"174":1,"175":2,"176":2,"177":2,"178":2,"179":2,"180":1,"181":1,"182":1,"183":2,"190":6,"196":5,"205":6,"207":1,"208":1,"214":7,"228":6,"230":1,"231":2}}],["export",{"2":{"195":1}}],["extends",{"2":{"103":2,"112":1,"195":1}}],["email",{"2":{"190":4}}],["enqueue",{"2":{"132":2,"195":3,"196":6,"203":1,"204":2,"205":5,"207":2}}],["endname",{"2":{"207":2}}],["end",{"2":{"37":12}}],["endi",{"2":{"37":1}}],["edge",{"2":{"116":1}}],["element",{"0":{"104":1,"105":1,"106":1},"2":{"101":5,"103":2,"104":3,"105":2,"106":2,"112":5,"170":5,"195":7,"196":8,"203":1}}],["else",{"2":{"9":1,"19":1,"21":2,"35":4,"37":1,"48":1,"54":1,"55":1,"69":4,"77":4,"78":1,"79":2,"80":6,"82":3,"83":12,"104":1,"105":3,"106":3,"107":3,"112":7,"173":1,"175":1,"179":1,"183":3,"195":1}}],["e",{"2":{"71":1,"88":1,"89":1,"94":1,"116":1,"129":3,"132":1,"133":1,"196":4,"236":2,"238":1,"239":1}}],["eraseoverlapintervals",{"2":{"37":7}}],["es6",{"2":{"211":1}}],["es6+",{"2":{"2":1}}],["es5",{"2":{"2":1}}],["遍历到的元素为指定数字",{"2":{"206":1}}],["遍历完所有的",{"2":{"219":1,"220":1}}],["遍历完",{"2":{"155":1}}],["遍历所有顶点",{"2":{"133":1}}],["遍历所有的节点",{"2":{"109":1,"110":1,"112":2,"174":1,"183":1}}],["遍历的注意点",{"2":{"131":1}}],["遍历的方式",{"0":{"131":1}}],["遍历第一行即可",{"2":{"121":1}}],["遍历根",{"2":{"72":1,"73":1}}],["遍历根节点",{"2":{"71":1}}],["遍历其右子树",{"2":{"71":1,"72":1,"73":1}}],["遍历其左子树",{"2":{"71":1,"72":1,"73":1}}],["遍历其之前的元素",{"2":{"27":1}}],["遍历数据",{"0":{"70":1},"1":{"71":1,"72":1,"73":1,"74":1}}],["遍历数组中的每个元素",{"2":{"47":1}}],["遍历数组",{"2":{"36":2,"50":1}}],["遍历待排序数组",{"2":{"58":2}}],["遍历整个数组",{"2":{"51":1}}],["遍历未排序部分",{"2":{"51":2,"52":1}}],["遍历未排序部分的元素",{"2":{"50":1}}],["遍历词典",{"2":{"45":1}}],["遍历词典中的每个单词",{"2":{"45":1}}],["遍历词典中的单词",{"2":{"45":1}}],["遍历匹配",{"2":{"45":1}}],["遍历剩余可选择的数字",{"2":{"43":2}}],["遍历区间",{"2":{"37":2}}],["遍历结束后",{"2":{"35":1,"36":1,"37":2}}],["遍历顾客付的每一张账单",{"2":{"35":1}}],["遍历顾客给的钱",{"2":{"35":1}}],["遍历账单",{"2":{"35":1}}],["遍历",{"2":{"9":1,"38":1,"156":1,"160":1,"162":1,"164":2}}],["遍历单词数组",{"2":{"9":1}}],["遍历传入的数组",{"2":{"2":1}}],["75",{"2":{"57":6,"154":1,"159":1,"160":2,"163":1,"164":2}}],["78",{"2":{"44":1}}],["70",{"2":{"26":1}}],["7",{"2":{"8":1,"12":4,"20":2,"27":19,"28":3,"29":1,"34":2,"38":1,"58":1,"64":2,"72":1,"73":1,"81":6,"82":2,"84":1,"94":2,"141":1,"151":1,"153":2,"156":1,"159":1,"160":1,"163":2,"164":3}}],["使之成为新的栈顶元素",{"2":{"222":1}}],["使其相邻的元素成为新的栈顶元素",{"2":{"222":1}}],["使其重新成为最大堆",{"2":{"56":1}}],["使其在被转换为原始值时返回",{"2":{"8":1}}],["使得每个位置存储的值表示小于等于该值的元素的个数",{"2":{"58":1}}],["使得每次选择的区间结束时间尽可能早",{"2":{"37":1}}],["使得所有小于基准的元素在基准的左边",{"2":{"55":1}}],["使得找到的最小元素成为已排序部分的最后一个元素",{"2":{"51":1}}],["使得句子中所有的单词都在词典中",{"2":{"45":1}}],["使得主元的位置是其最终位置",{"2":{"21":1}}],["使剩余区间互不重叠",{"2":{"37":1}}],["使用队列实现小游戏",{"2":{"206":1}}],["使用霍纳法则",{"2":{"151":1}}],["使用链表时也同样麻烦",{"2":{"135":1}}],["使用链表",{"0":{"95":1},"2":{"135":1}}],["使用数组存储时",{"2":{"94":1}}],["使用数组",{"0":{"94":1}}],["使用较少",{"2":{"70":1}}],["使用计数排序对其进行排序",{"2":{"58":1}}],["使用基数排序对其进行排序",{"2":{"57":1}}],["使用一个数组来保存",{"2":{"124":1}}],["使用一个对象",{"2":{"45":1}}],["使用一个变量",{"2":{"37":1}}],["使用两个数组",{"2":{"55":1}}],["使用两个变量",{"2":{"35":1}}],["使用两个指针",{"2":{"34":1}}],["使用场景",{"0":{"16":1,"24":1,"32":1,"41":1}}],["使用正则表达式去除文本中的标点符号",{"2":{"9":1}}],["使用示例",{"2":{"8":1}}],["使用绝对值函数",{"2":{"5":1}}],["使用递归方式实现欧几里得算法",{"2":{"4":1,"5":1}}],["使用",{"2":{"1":1,"2":1,"3":2,"8":1,"21":1,"60":2,"230":1}}],["以",{"2":{"249":1}}],["以什么样的方式来存储和组织我们的数据",{"2":{"244":1}}],["以下为儿子",{"2":{"240":1}}],["以下是堆排序的时间复杂度",{"2":{"56":1}}],["以下是几种常见增量序列的时间复杂度分析",{"2":{"53":1}}],["以下是使用欧几里得算法计算最大公约数进而求最小公倍数的",{"2":{"5":1}}],["以此类推",{"2":{"136":1,"169":1,"175":1,"183":1}}],["以及存在于该对象的实例和组成实例的数据元素之间的各种联系",{"2":{"243":1}}],["以及它的",{"2":{"78":1,"83":1}}],["以及一个整数",{"2":{"29":1}}],["以遍历根",{"2":{"74":1}}],["以得到一个有序的数组",{"2":{"54":1}}],["以该单词开头",{"2":{"45":2}}],["以任意顺序返回所有这些可能的句子",{"2":{"45":1}}],["以后的元素遍历时",{"2":{"12":1}}],["以便留出更多的空间给后面的区间",{"2":{"37":1}}],["以便存储所有结果",{"2":{"11":1}}],["以便忽略大小写差异",{"2":{"9":1}}],["以便外部可以继续累加",{"2":{"8":1}}],["以便实现链式调用",{"2":{"8":1}}],["+1",{"2":{"141":1,"163":1}}],["+=",{"2":{"20":2,"109":1,"110":1,"112":2,"128":3,"132":1,"133":1,"174":1,"183":1,"195":1,"204":1,"227":1,"230":1}}],["++",{"2":{"9":1,"58":1}}],["+",{"2":{"8":2,"10":1,"11":3,"12":3,"18":2,"20":4,"21":1,"26":8,"27":2,"28":6,"29":10,"34":1,"36":3,"38":9,"43":1,"44":2,"45":2,"48":2,"50":3,"51":1,"56":2,"57":2,"58":10,"89":2,"94":1,"109":1,"110":1,"112":2,"128":2,"132":1,"133":1,"136":9,"151":1,"163":3,"173":1,"174":1,"183":2,"195":3,"204":1,"227":1}}],["+item",{"2":{"1":1}}],["并拼接到一起",{"2":{"230":1}}],["并集的实现",{"0":{"216":1}}],["并集",{"2":{"215":1}}],["并添加必要的属性和上面实现的哈希函数",{"2":{"153":1}}],["并添加到结果集中",{"2":{"45":1}}],["并按照顺序重新排列",{"2":{"57":3}}],["并按空格分割成单词数组",{"2":{"9":1}}],["并对剩余元素重新堆化",{"2":{"56":1}}],["并返回取出的那个元素",{"2":{"227":1}}],["并返回被移除的元素",{"2":{"203":1}}],["并返回",{"2":{"151":1}}],["并返回该结果",{"2":{"45":1}}],["并返还",{"2":{"35":1}}],["并将",{"2":{"132":1}}],["并将其加进待访问顶点列表中",{"2":{"131":1}}],["并将堆的大小减少",{"2":{"56":1}}],["并将数组分成两部分",{"2":{"55":1}}],["并将结果组合起来",{"2":{"45":1}}],["并将字符串转换为小写",{"2":{"7":1}}],["并传递更新后的路径和新的起始索引",{"2":{"44":1}}],["并传递更新后的路径和剩余可选择的数字",{"2":{"43":1}}],["并递归调用回溯函数",{"2":{"43":1,"44":1}}],["并更新",{"2":{"37":1}}],["并输出这个最大数值",{"2":{"34":1}}],["并利用子问题的重叠性",{"2":{"22":1}}],["并合并两部分的结果",{"2":{"20":1}}],["并且可以快速获取最大值和最小值等",{"2":{"235":1}}],["并且哈希表中的元素是无序的",{"2":{"235":1}}],["并且在插入和删除元素时",{"2":{"235":1}}],["并且在插入的过程中需要经历多次这种情况",{"2":{"141":1}}],["并且这个节点会连接下一个节点",{"2":{"169":1}}],["并且大小可以无限延伸下去",{"2":{"168":1}}],["并且大小是固定的",{"2":{"167":1}}],["并且删除",{"2":{"156":1}}],["并且结果不可能为",{"2":{"143":1}}],["并且追踪有哪些顶点还没有被访问到",{"2":{"131":1}}],["并且",{"2":{"92":1,"139":1}}],["并且适合于元素范围不是很大的情况下",{"2":{"58":1}}],["并且是稳定排序算法",{"2":{"57":1}}],["并且前一个元素大于当前元素",{"2":{"53":1}}],["并且需要组合结果",{"2":{"45":1}}],["并且每块饼干",{"2":{"34":1}}],["并且每次合并操作的时间复杂度为",{"2":{"19":1}}],["并且实现时间复杂度为",{"2":{"21":1}}],["并且给定的数组总是存在多数元素",{"2":{"18":1}}],["并赋值给",{"2":{"8":1}}],["初始",{"2":{"172":1,"183":1}}],["初始链表长度为",{"2":{"172":1,"183":1}}],["初始设为质数",{"2":{"153":1,"164":1}}],["初始设置为未排序部分的末尾",{"2":{"50":1}}],["初始时",{"2":{"52":1}}],["初始时已排序部分只有一个元素",{"2":{"52":1}}],["初始时已排序部分为空",{"2":{"51":1}}],["初始已排序部分",{"2":{"52":1}}],["初始数组",{"2":{"51":1}}],["初始状态",{"2":{"51":1}}],["初始值为",{"2":{"35":1,"36":2}}],["初始值为空数组",{"2":{"1":1}}],["初始条件",{"2":{"26":2,"28":2}}],["初始化一些变量",{"2":{"175":1,"183":1}}],["初始化颜色",{"2":{"132":1,"133":1}}],["初始化顶点的颜色",{"2":{"131":1}}],["初始化交换标志为",{"2":{"50":1}}],["初始化最后一个未排序元素的索引",{"2":{"50":1}}],["初始化回溯",{"2":{"44":1}}],["初始化结果集",{"2":{"43":2,"44":2}}],["初始化结果变量为",{"2":{"8":1}}],["初始化每个孩子的糖果数为",{"2":{"38":1}}],["初始化变量",{"2":{"37":1}}],["初始化钱箱",{"2":{"35":1}}],["初始化金额为",{"2":{"29":1}}],["初始化为负无穷大",{"2":{"37":1}}],["初始化为",{"2":{"29":1}}],["初始化为一个较大的值",{"2":{"29":1}}],["初始化",{"2":{"23":1,"27":1,"29":1,"36":2,"37":1,"38":2,"45":1}}],["初始化前两项",{"2":{"11":1}}],["初始化前两个斐波那契数",{"2":{"10":1}}],["初始化两个变量",{"2":{"9":1}}],["r",{"2":{"235":1}}],["root",{"2":{"67":2,"69":13,"71":1,"72":1,"73":1,"76":4,"77":4,"78":1,"79":4,"80":10,"82":2,"83":11,"235":1}}],["rob",{"2":{"28":6}}],["radixsort",{"2":{"57":2}}],["radix",{"2":{"57":1}}],["ratings",{"2":{"38":9}}],["random",{"2":{"12":1}}],["race",{"2":{"7":1}}],["rightsibling",{"2":{"239":3}}],["rightsum",{"2":{"20":4}}],["rightlength",{"2":{"54":3}}],["rightarray",{"2":{"54":5}}],["rightmax",{"2":{"20":2}}],["rightmajority",{"2":{"18":4}}],["rightcount",{"2":{"18":2}}],["right",{"2":{"12":11,"18":8,"19":8,"20":7,"21":9,"51":3,"54":2,"55":4,"56":4,"67":4,"69":3,"71":1,"72":1,"73":1,"76":2,"77":2,"78":1,"79":3,"80":14,"82":7,"83":18}}],["rear",{"2":{"199":1}}],["resize",{"0":{"160":1},"2":{"150":1,"154":1,"156":1,"160":4,"163":2,"164":3}}],["res",{"2":{"128":5}}],["result",{"2":{"1":3,"2":4,"8":8,"12":7,"43":5,"44":7,"45":4,"54":6,"71":8,"72":8,"73":8,"108":2,"109":3,"110":3,"112":8,"132":3,"133":3,"174":3,"183":3,"195":3,"204":3,"227":3}}],["removeat",{"0":{"107":1,"179":1},"2":{"101":1,"107":3,"108":1,"112":4,"113":3,"170":1,"179":3,"180":1,"183":3}}],["remove",{"0":{"156":1,"180":1},"2":{"68":1,"83":1,"101":1,"112":3,"113":3,"150":1,"156":2,"160":1,"163":2,"164":2,"170":1,"180":3,"183":2,"187":1,"189":2,"190":2,"212":1,"213":2,"214":2,"220":2}}],["reverse",{"2":{"7":1}}],["reversedstr",{"2":{"7":2}}],["replace",{"2":{"7":1,"9":1}}],["reduce",{"2":{"1":2,"8":3,"38":1}}],["return",{"2":{"1":6,"2":4,"4":2,"5":3,"7":1,"8":4,"9":1,"10":4,"11":4,"12":8,"18":5,"19":4,"20":4,"21":6,"26":2,"27":2,"28":6,"29":1,"34":1,"35":3,"36":3,"37":2,"38":1,"43":2,"44":1,"45":4,"47":2,"48":2,"50":2,"51":2,"52":2,"53":2,"54":3,"55":2,"56":2,"57":5,"58":1,"71":2,"72":2,"73":2,"76":4,"77":7,"78":1,"82":1,"83":2,"105":2,"106":2,"107":2,"108":1,"109":1,"110":1,"112":12,"128":1,"131":1,"151":1,"154":2,"155":4,"156":2,"157":1,"158":1,"162":6,"163":1,"164":10,"174":1,"175":2,"176":2,"177":2,"178":2,"179":2,"181":1,"182":1,"183":13,"189":6,"195":5,"204":5,"207":1,"213":6,"216":1,"217":1,"218":1,"219":2,"220":11,"227":5,"230":1}}],["type",{"2":{"243":1}}],["tm",{"2":{"235":1}}],["t2",{"2":{"235":1}}],["t1",{"2":{"235":1}}],["tuple",{"2":{"154":6,"155":3,"156":4,"164":13}}],["tuesday",{"2":{"60":4}}],["tail",{"2":{"100":1,"103":2,"104":4,"105":4,"106":4,"107":5,"110":1,"112":15}}],["target",{"2":{"47":2,"48":3}}],["targetindex++",{"2":{"105":1,"106":1,"107":1,"112":2}}],["targetindex",{"2":{"21":7,"105":1,"106":1,"107":1,"112":2,"208":2}}],["tl",{"2":{"87":1,"88":1}}],["trun",{"2":{"101":1,"150":1,"170":1}}],["true",{"2":{"7":1,"35":6,"36":11,"50":2,"68":1,"77":3,"78":2,"80":2,"83":2,"105":1,"106":1,"112":1,"162":2,"187":1,"190":1,"195":1,"203":1,"212":1,"213":2,"214":1,"219":2,"220":4,"226":1}}],["tr",{"2":{"87":1,"88":1}}],["treemap",{"2":{"186":1}}],["tree",{"2":{"65":1,"91":2,"92":1,"235":1,"245":1}}],["thursday",{"2":{"60":4}}],["than",{"2":{"10":2}}],["the",{"2":{"10":2}}],["this",{"2":{"9":2,"67":3,"69":7,"71":4,"72":4,"73":4,"76":4,"77":5,"78":1,"79":4,"80":8,"82":3,"83":10,"103":4,"104":7,"105":15,"106":15,"107":15,"108":2,"109":1,"110":1,"112":42,"124":2,"126":2,"127":2,"128":4,"131":2,"132":3,"133":7,"153":3,"154":10,"155":2,"156":10,"157":1,"158":1,"159":2,"160":19,"163":13,"164":35,"172":1,"173":5,"174":1,"175":6,"176":2,"177":1,"178":2,"179":5,"180":2,"181":1,"182":1,"183":27,"189":11,"195":9,"204":7,"213":9,"216":2,"217":1,"218":1,"219":1,"220":14,"227":8,"239":9}}],["temp",{"2":{"51":2,"52":3,"53":3,"162":2}}],["ten++",{"2":{"35":1}}],["ten",{"2":{"35":4}}],["test",{"2":{"9":4}}],["text",{"2":{"9":4}}],["tony",{"2":{"208":1}}],["tom",{"2":{"185":2,"208":1}}],["tolowercase",{"2":{"7":1,"9":1}}],["tostring",{"0":{"128":1,"174":1},"2":{"1":2,"101":2,"128":1,"170":2,"174":2,"175":1,"178":2,"179":1,"180":1,"183":2,"195":3,"196":2,"203":1,"204":2,"205":2,"226":1,"227":2,"228":2}}],["90",{"2":{"57":6}}],["912",{"2":{"19":1}}],["9",{"2":{"7":1,"8":1,"27":2,"28":5,"34":1,"57":2,"66":4,"72":1,"73":1,"80":4,"81":6,"94":2,"117":3,"143":1}}],["zxc",{"2":{"214":6}}],["zxcvvv",{"2":{"136":1}}],["z",{"2":{"136":1}}],["zz",{"2":{"113":2}}],["z0",{"2":{"7":1}}],["za",{"2":{"7":1}}],["cpu",{"2":{"201":1}}],["cn",{"2":{"190":4}}],["ceil",{"2":{"162":1}}],["child",{"2":{"236":1}}],["charcodeat",{"2":{"151":1}}],["choices",{"2":{"43":7}}],["cc",{"2":{"113":1,"174":1,"175":1,"178":2,"179":1,"180":1}}],["c",{"2":{"71":1,"88":1,"89":1,"94":2,"120":4,"122":1,"129":4,"132":1,"133":1,"136":1,"173":1,"196":2,"205":5,"223":6,"224":2,"236":2,"238":1,"239":1}}],["clear",{"2":{"187":1,"189":2,"212":1,"213":2,"214":2,"220":2}}],["cleanedstr",{"2":{"7":3}}],["class",{"2":{"67":1,"103":2,"172":1,"183":1,"189":1,"195":2,"213":1,"220":1,"227":1}}],["climbstairs",{"2":{"26":5}}],["crossmax",{"2":{"20":2}}],["currentnode",{"2":{"78":10,"79":3,"80":20,"82":3,"83":36,"105":6,"106":6,"107":8,"109":5,"110":5,"112":24,"173":9,"174":5,"175":6,"176":4,"177":5,"178":5,"179":7,"183":38}}],["current",{"2":{"10":2,"28":2,"78":2,"79":3,"80":18,"81":7,"82":16,"83":6}}],["color",{"2":{"132":5,"133":8}}],["colors",{"2":{"131":3}}],["complete",{"2":{"92":1}}],["combine",{"2":{"15":1,"54":1}}],["coinchange",{"2":{"29":6}}],["coin",{"2":{"29":7}}],["coins",{"2":{"29":6}}],["countarray",{"2":{"58":5}}],["countingsort",{"2":{"58":2}}],["counting",{"2":{"58":1}}],["countinrange",{"2":{"18":3}}],["count++",{"2":{"18":1,"34":1,"37":1,"154":1,"164":1}}],["count",{"2":{"9":2,"18":2,"34":2,"37":5,"153":1,"154":1,"156":2,"157":1,"158":1,"160":4,"163":2,"164":7}}],["conquer",{"2":{"15":1,"54":2,"55":1}}],["constant",{"2":{"143":3}}],["constructor",{"2":{"67":1,"103":2,"112":1,"124":1,"153":1,"164":1,"172":1,"183":1,"189":1,"195":2,"204":1,"213":1,"220":1,"227":1}}],["const",{"2":{"3":1,"7":2,"8":1,"9":3,"10":1,"11":1,"12":13,"18":5,"19":4,"20":4,"21":3,"26":1,"27":1,"28":4,"29":2,"35":1,"37":1,"38":2,"43":1,"44":1,"45":6,"48":1,"50":1,"51":2,"52":2,"53":2,"54":7,"55":3,"56":3,"57":3,"58":1,"69":1,"71":1,"72":1,"73":1,"104":1,"105":1,"106":1,"108":1,"112":3,"151":1,"154":1,"155":3,"156":3,"160":3,"162":1,"164":10,"173":1,"175":1,"183":2,"195":1,"207":3,"208":2,"230":1}}],["console",{"2":{"1":2,"2":2,"3":2,"4":2,"5":1,"7":2,"8":1,"9":1,"10":6,"11":6,"12":3,"18":4,"19":2,"20":3,"21":2,"26":4,"27":3,"28":4,"29":5,"34":4,"35":2,"36":5,"37":5,"38":5,"43":3,"44":2,"45":3,"47":2,"48":2,"50":1,"51":1,"62":1,"63":1,"64":2,"113":12,"132":1,"133":1,"151":1,"173":1,"174":1,"175":1,"176":2,"177":2,"178":2,"179":1,"180":1,"181":1,"182":1,"190":8,"196":5,"205":6,"208":1,"214":7,"228":6,"231":2}}],["concat",{"2":{"1":2,"43":1,"57":1}}],["catsandog",{"2":{"45":2}}],["catsanddog",{"2":{"45":2}}],["cats",{"2":{"45":6,"136":3}}],["cat",{"2":{"45":6}}],["candy",{"2":{"38":9}}],["candies",{"2":{"38":15}}],["canjump",{"2":{"36":7}}],["canal",{"2":{"7":1}}],["car",{"2":{"7":1}}],["判断栈是否为空",{"2":{"227":1}}],["判断集合中是否存在",{"2":{"213":1,"220":1}}],["判断队列是否为空",{"2":{"195":1}}],["判断字典中是否存在某个",{"2":{"189":1}}],["判断得到的容量是否为质数",{"2":{"163":1}}],["判断获取到的",{"2":{"155":1,"156":1}}],["判断哈希表是否要扩容",{"2":{"154":1,"160":1,"163":1,"164":1}}],["判断是插入数据操作还是修改数据操作",{"2":{"154":1,"164":1}}],["判断是否在",{"2":{"217":1,"218":1,"219":1,"220":3}}],["判断是否需要调用扩容函数进行压缩",{"2":{"160":1}}],["判断是否需要调用扩容函数进行扩容",{"2":{"160":1}}],["判断是否要进行哈希表压缩",{"2":{"156":1,"160":1,"163":1,"164":1}}],["判断是否存在",{"2":{"154":1,"164":1}}],["判断是否为根节点",{"2":{"82":1,"83":1}}],["判断是否找到了问题的解决方案",{"2":{"40":1}}],["判断是否能够到达最后一个下标",{"2":{"36":1}}],["判断新增还是修改原来的值",{"2":{"154":1}}],["判断链表是否为空",{"2":{"112":1,"181":1,"183":1}}],["判断多种插入情况",{"2":{"105":1,"106":1,"112":1}}],["判断寻找到的后续节点是否直接就是要删除节点的",{"2":{"82":1,"83":1}}],["判断终止条件",{"2":{"40":1}}],["判断你是否能够到达最后一个下标",{"2":{"36":1}}],["判断枢纽值的位置",{"2":{"12":1}}],["判断一个字符串是否为回文字符串",{"0":{"7":1}}],["判断当前元素是否为数组",{"2":{"1":1}}],["→",{"2":{"6":1}}],["详情查看",{"2":{"6":1}}],["|a",{"2":{"5":3}}],["||",{"2":{"2":2,"12":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"105":1,"106":1,"107":1,"112":2,"162":1,"175":1,"176":1,"178":1,"179":1,"183":4}}],["最普通的表示方法",{"0":{"238":1}}],["最先被添加",{"2":{"203":1}}],["最好的情况还是让数据在哈希表中均匀分布",{"2":{"148":1}}],["最好的情况下为",{"2":{"12":1}}],["最好的装填因子取决于存储效率和速度之间的平衡",{"2":{"145":1}}],["最大位数",{"2":{"57":1}}],["最大值在二叉搜索树的最右边",{"2":{"76":1}}],["最大值",{"2":{"56":2}}],["最大堆是一个完全二叉树",{"2":{"56":1}}],["最大子序列和等问题",{"2":{"24":1,"32":1}}],["最大子数组和",{"0":{"20":1}}],["最后造成栈溢出",{"2":{"223":1}}],["最后放上的托盘",{"2":{"222":1}}],["最后通过",{"2":{"173":1}}],["最后一个节点的",{"2":{"173":1,"183":1}}],["最后一层的叶子节点从左向右是连续存在",{"2":{"92":1}}],["最后",{"2":{"71":1,"72":1,"73":1,"154":1,"155":1,"156":1,"159":1}}],["最后对整个数组进行插入排序",{"2":{"53":1}}],["最后的被除数就是两个数的最大公约数",{"2":{"4":1}}],["最坏的情况是",{"2":{"249":1}}],["最坏的情况",{"2":{"249":1}}],["最坏情况下",{"2":{"57":1,"58":1}}],["最坏情况下为",{"2":{"45":1}}],["最坏空间复杂度",{"2":{"55":1}}],["最坏和平均情况下的时间复杂度都是",{"2":{"54":1}}],["最坏时间复杂度",{"2":{"50":1,"51":1,"52":1,"53":3,"54":1,"55":1,"56":1,"57":1,"58":1}}],["最优情况下",{"2":{"57":1,"58":1}}],["最优时间复杂度为",{"2":{"50":1,"52":1}}],["最优时间复杂度",{"2":{"50":1,"51":1,"52":1,"54":1,"55":1,"56":1,"57":1,"58":1}}],["最优化问题",{"2":{"24":1,"32":1}}],["最终一定能找到出问题的线段",{"2":{"249":1}}],["最终查找到数据",{"2":{"66":1}}],["最终排序",{"2":{"53":1}}],["最终达到完全有序",{"2":{"50":1}}],["最终结果",{"2":{"26":1,"27":1,"28":1,"29":1}}],["最短路径等问题",{"2":{"32":1}}],["最长递增子序列是",{"2":{"27":1}}],["最长递增子序列",{"0":{"27":1}}],["最长公共子序列等问题",{"2":{"24":1}}],["最小值在二叉搜索树的最左边",{"2":{"76":1}}],["最小的",{"0":{"12":1}}],["最小公倍数公式",{"2":{"5":1}}],["最小公倍数可以通过以下公式计算",{"2":{"5":1}}],["的对数",{"2":{"249":1}}],["的对应位置",{"2":{"154":1}}],["的定义",{"0":{"247":1}}],["的物理实现",{"2":{"243":1}}],["的路径长度为",{"2":{"236":1}}],["的子节点",{"2":{"236":1}}],["的子序列上追加",{"2":{"27":1}}],["的子序列",{"2":{"27":2}}],["的父节点",{"2":{"236":2}}],["的度为",{"2":{"236":1}}],["的特殊节点",{"2":{"235":1}}],["的树",{"2":{"234":1}}],["的所有",{"2":{"216":1,"220":1}}],["的所有非空右子树的键值都大于",{"2":{"65":1}}],["的所有非空左子树的键值都小于",{"2":{"65":1}}],["的人可优先处理",{"2":{"192":1}}],["的节点称为父节点",{"2":{"236":1}}],["的节点",{"2":{"178":1,"179":1,"183":3,"236":1}}],["的情况",{"2":{"175":2,"179":2,"183":4}}],["的平方根即可",{"2":{"162":1}}],["的实现",{"0":{"160":1}}],["的实现思路",{"2":{"69":1}}],["的格式",{"2":{"154":1,"164":1}}],["的变量",{"2":{"151":1}}],["的探测序列",{"2":{"143":1}}],["的探测",{"2":{"142":1}}],["的幂相乘求和",{"2":{"136":1}}],["的数据",{"2":{"156":1,"164":1}}],["的数字",{"2":{"136":1}}],["的数组来存储每个金额的最少硬币数",{"2":{"29":1}}],["的数组来存储每个位置的最高金额",{"2":{"28":1}}],["的数组来存储每个位置的最长子序列长度",{"2":{"27":1}}],["的数组来存储每一阶的方法数",{"2":{"26":1}}],["的数组",{"2":{"18":1,"159":1}}],["的递归方法",{"2":{"133":1}}],["的点并设置为访问中状态",{"2":{"132":1}}],["的缩写",{"2":{"124":1}}],["的时候进行扩容",{"2":{"159":1}}],["的时候",{"2":{"121":1,"173":1,"183":1}}],["的时间复杂度",{"2":{"51":1,"52":1,"54":1,"135":1}}],["的时间来构建",{"2":{"43":1}}],["的边更远或者用的时间更长",{"2":{"117":1}}],["的边",{"2":{"117":1}}],["的一个连续序列",{"2":{"117":1}}],["的规律",{"2":{"89":1}}],["的非叶子节点",{"2":{"89":1}}],["的非叶子节点个数",{"2":{"89":1}}],["的二叉树的最大节点总数为",{"2":{"89":1}}],["的二叉树",{"2":{"88":2}}],["的两个不相交的二叉树组成",{"2":{"87":1}}],["的后继时",{"2":{"82":1}}],["的后继",{"2":{"82":1}}],["的前驱",{"2":{"82":1}}],["的右子树节点",{"2":{"82":1,"83":1}}],["的右子树中一直向左遍历查找",{"2":{"82":1}}],["的右子树中查找最小值",{"2":{"82":1}}],["的右子树中选择一合适的节点替代节点",{"2":{"81":3}}],["的右子节点",{"2":{"66":1,"80":2}}],["的左子树中一直向右遍历查找",{"2":{"82":1}}],["的左子树中查找最大值",{"2":{"82":1}}],["的左子树中选择一合适的节点替代节点",{"2":{"81":3}}],["的左子节点",{"2":{"66":2,"80":2}}],["的左节点",{"2":{"78":1}}],["的",{"2":{"69":1,"84":1,"175":2,"176":1,"177":1,"183":3,"189":1,"209":1}}],["的来源",{"2":{"65":1}}],["的高效排序算法",{"2":{"54":1}}],["的过程中处理小数据块",{"2":{"52":1}}],["的卡片",{"2":{"51":1}}],["的大小",{"2":{"45":1}}],["的长度",{"2":{"45":1}}],["的结果存入缓存",{"2":{"45":1}}],["的拷贝加入结果集",{"2":{"44":2}}],["的位置都放置了数据",{"2":{"141":1}}],["的位置就会停止查找",{"2":{"141":1}}],["的位置就是合适的位置",{"2":{"141":1}}],["的位置存放的数据与需要查询的数据",{"2":{"141":1}}],["的位置起",{"2":{"64":1}}],["的位置的元素为",{"2":{"64":1}}],["的位置",{"2":{"36":1,"62":1}}],["的孩子满足",{"2":{"34":1}}],["的硬币数量",{"2":{"29":1}}],["的算法",{"2":{"21":1}}],["的算法解决此问题",{"2":{"21":1}}],["的和最大",{"2":{"20":1}}],["的元素",{"2":{"18":1,"50":1,"51":3}}],["的话",{"2":{"12":2}}],["的值就转化为求",{"2":{"147":1}}],["的值",{"2":{"8":1,"151":2}}],["的值上",{"2":{"8":1}}],["的最坏时间复杂度",{"2":{"53":1}}],["的最大堆",{"2":{"12":1}}],["的最大公约数",{"2":{"4":2,"5":1}}],["的最小公倍数",{"2":{"5":1}}],["的乘积的绝对值",{"2":{"5":1}}],["的方式来求两个数的最小公倍数",{"2":{"5":1}}],["中文维基百科",{"2":{"243":1}}],["中添加如下代码",{"2":{"160":2}}],["中每一个",{"2":{"155":1,"159":1}}],["中对应的索引值",{"2":{"155":1,"156":1}}],["中使用的就是链地址法",{"2":{"145":1}}],["中取出队列",{"2":{"132":1}}],["中包含存储的数据",{"2":{"95":1}}],["中序遍历第二遍历根节点",{"2":{"74":1}}],["中序遍历",{"0":{"72":1},"2":{"70":1,"72":1}}],["中间索引",{"2":{"48":1}}],["中插入空格来构成单词",{"2":{"45":1}}],["中所有字符串都不同",{"2":{"45":1}}],["中增加空格来构建一个句子",{"2":{"45":1}}],["中的每一个数据取出来依次添加到",{"2":{"159":1}}],["中的每一个",{"2":{"159":1}}],["中的",{"2":{"145":1,"148":1,"186":3,"211":1}}],["中的所有元素互不相同",{"2":{"44":1}}],["中的所有整数互不相同",{"2":{"43":1}}],["中的最后一个值即为可以偷窃到的最高金额",{"2":{"28":1}}],["中的最大值即为最长递增子序列的长度",{"2":{"27":1}}],["中等",{"2":{"19":1,"20":1,"21":1,"27":1,"28":1,"29":1,"36":1,"37":1,"43":1,"44":1}}],["中",{"2":{"5":1,"216":2,"220":2}}],["jack",{"2":{"208":1}}],["java",{"2":{"145":1,"148":1,"186":1}}],["javascriptfunction",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":2,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["javascript",{"0":{"227":1},"2":{"5":3,"46":1,"49":1,"59":1,"101":1,"148":2,"170":1,"209":1}}],["j++",{"2":{"19":2,"21":1,"27":1,"34":1,"50":1,"51":1,"128":1}}],["j",{"2":{"19":6,"21":5,"27":9,"34":7,"50":9,"51":4,"52":7,"53":8,"89":1,"128":3}}],["jumpstairs",{"2":{"11":7}}],["join",{"2":{"7":1}}],["jsremove",{"2":{"180":1}}],["jsremoveat",{"2":{"179":1}}],["jsupdate",{"2":{"178":1}}],["jsgetdata",{"2":{"176":1}}],["jstostring",{"2":{"174":1}}],["jssize",{"2":{"158":1,"182":1}}],["jsindexof",{"2":{"177":1}}],["jsinsertnode",{"2":{"69":1}}],["jsisempty",{"2":{"157":1,"181":1}}],["jshashfn",{"2":{"151":1}}],["jsconsole",{"2":{"151":1}}],["jsconst",{"2":{"60":2,"62":1,"63":1,"64":2,"113":1,"173":1,"190":1,"196":1,"205":1,"214":1}}],["jsclass",{"2":{"112":1,"124":1,"153":1,"164":1,"172":1,"183":1,"204":1}}],["jslet",{"2":{"78":1}}],["js",{"2":{"2":1,"3":1,"4":1,"57":1,"67":1,"69":1,"71":1,"72":1,"73":1,"76":1,"77":1,"79":1,"80":1,"82":1,"83":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"126":1,"127":1,"128":1,"129":1,"131":1,"132":2,"133":2,"154":1,"155":1,"156":1,"160":3,"163":3,"173":1,"174":1,"175":2,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"189":1,"195":1,"207":1,"208":1,"213":1,"216":1,"217":1,"218":1,"219":1,"220":1,"227":1,"228":1,"231":1,"239":1}}],["jsfunction",{"2":{"1":2,"7":1,"8":1,"9":1,"10":1,"11":1,"12":3,"47":1,"48":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"58":1,"162":2,"230":1}}],["在科研和开发前沿技术时",{"2":{"250":1}}],["在代码实现中谁是父节点并没有关系",{"2":{"240":1}}],["在添加元素过程中",{"2":{"193":1}}],["在字典中删除指定的",{"2":{"189":1}}],["在字典中添加键值对",{"2":{"189":1}}],["在字典中",{"2":{"185":1}}],["在字符串",{"2":{"45":1}}],["在当前节点和当前节点的上一节点之间插入新节点",{"2":{"175":1,"183":1}}],["在当前已排序序列中比较",{"2":{"52":1}}],["在指定的位置插入元素",{"2":{"195":1}}],["在指定位置",{"2":{"175":1,"183":1}}],["在指定索引位置插入元素",{"2":{"62":1}}],["在哈希表中的删除方法",{"2":{"160":1}}],["在哈希表中的添加方法",{"2":{"160":1}}],["在进行较大数据的与运算时会出现问题",{"2":{"148":1}}],["在设计哈希表时",{"2":{"148":1}}],["在中国霍纳法则也叫做秦久韶算法",{"2":{"147":1}}],["在开发中使用链地址法较多",{"2":{"145":1}}],["在开放地址法中寻找空白单元格的最好的解决方式为再哈希化",{"2":{"143":1}}],["在我们需要时",{"2":{"130":1}}],["在二维数组中",{"2":{"121":1}}],["在二叉树中",{"2":{"91":1}}],["在二叉搜索树中",{"2":{"82":1}}],["在二叉搜索树中查找最值非常简单",{"2":{"76":1}}],["在后面的案例中",{"2":{"120":1}}],["在数组开头或中间位置插入数据的成本很高",{"2":{"167":1}}],["在数组首位插入一个元素",{"2":{"62":1}}],["在数学的概念上",{"2":{"116":1}}],["在数学上起源于哥尼斯堡七桥问题",{"2":{"115":1}}],["在计算机程序设计中",{"2":{"115":1}}],["在计数排序中",{"2":{"58":1}}],["在第",{"2":{"105":1,"106":1,"112":1}}],["在上图中",{"2":{"92":1}}],["在保证删除节点",{"2":{"81":3}}],["在树中查找一个键",{"2":{"68":1}}],["在排序好的数组中查询数据",{"2":{"66":1}}],["在排序过程中",{"2":{"50":1,"53":1,"55":1}}],["在索引",{"2":{"62":1,"64":1}}],["在基数排序过程中",{"2":{"57":1}}],["在实际中",{"2":{"138":1}}],["在实际开发中",{"2":{"98":1}}],["在实际应用中",{"2":{"55":1}}],["在实际应用中有一定的优势",{"2":{"53":1}}],["在实践中具有较好的性能表现",{"2":{"56":1}}],["在堆排序中",{"2":{"56":1}}],["在最后面添加新节点",{"2":{"173":1,"183":1}}],["在最后一个位置插入",{"2":{"105":1,"106":1,"112":1}}],["在最优情况下",{"2":{"56":1}}],["在最坏情况下",{"2":{"21":1,"50":1,"51":1,"52":1,"55":2,"56":1}}],["在理想情况下",{"2":{"55":1}}],["在合并两个有序子数组的过程中",{"2":{"54":1}}],["在插入过程中",{"2":{"52":1}}],["在选择排序过程中",{"2":{"51":1}}],["在一般情况下",{"2":{"50":1,"52":1}}],["在一次排序过程中",{"2":{"50":1}}],["在每一轮排序中",{"2":{"50":1}}],["在每个节点处",{"2":{"40":1}}],["在缓存中",{"2":{"45":2}}],["在递归调用结束后",{"2":{"43":2,"44":2}}],["在回溯时",{"2":{"40":1}}],["在探索过程中",{"2":{"40":1}}],["在柠檬水摊上",{"2":{"35":1}}],["在右半部分继续搜索",{"2":{"21":1}}],["在左半部分继续搜索",{"2":{"21":1}}],["在这个问题中",{"2":{"20":1}}],["在",{"2":{"5":1,"105":1,"106":1,"108":1,"112":2,"163":1,"175":1,"183":1,"223":1}}],["对应这个人",{"2":{"207":1}}],["对应的",{"2":{"159":1}}],["对应的数组",{"2":{"122":1}}],["对哈希表容量进行压缩",{"2":{"160":1}}],["对哈希表进行扩容",{"2":{"160":1}}],["对哈希表进行扩容操作",{"2":{"150":1}}],["对步长进行了优化",{"2":{"142":1}}],["对最终数据插入的数组进行整个结构的封装",{"2":{"137":1}}],["对称的位置",{"2":{"121":1}}],["对飞机航线建模",{"2":{"118":1}}],["对交通流量建模",{"2":{"118":1}}],["对任何非空二叉树",{"2":{"89":1}}],["对统计数组进行累加",{"2":{"58":1}}],["对堆的剩余部分重新堆化",{"2":{"56":1}}],["对每一位重复上述排序过程",{"2":{"57":1}}],["对每一半分别进行递归排序",{"2":{"54":1}}],["对每个点操作",{"2":{"133":1}}],["对每个子数组进行排序",{"2":{"54":1}}],["对每个子序列进行插入排序",{"2":{"53":2}}],["对每个分组使用插入排序",{"2":{"53":1}}],["对每个孩子",{"2":{"34":1}}],["对当前分组进行插入排序",{"2":{"53":1}}],["对整个数组进行一次插入排序",{"2":{"53":1}}],["对于任意一棵非空树",{"2":{"235":1}}],["对于给定的两个集合",{"2":{"215":3}}],["对于每一条所连接的没有被访问过的顶点",{"2":{"131":1}}],["对于每个未排序部分的元素",{"2":{"52":1}}],["对于每个单词",{"2":{"45":1}}],["对于每个位置",{"2":{"36":1}}],["对于每个金额",{"2":{"29":1}}],["对于每个房子",{"2":{"28":1}}],["对于每个",{"2":{"27":1}}],["对于一棵平衡二叉树来说",{"2":{"84":1}}],["对于递归实现",{"2":{"54":1}}],["对于这个问题",{"2":{"37":1}}],["对于最后一位顾客",{"2":{"35":1}}],["对于接下来的",{"2":{"35":1}}],["对孩子的胃口数组和饼干尺寸数组进行排序",{"2":{"34":1}}],["对数组进行遍历时",{"2":{"12":1}}],["对象默认的",{"2":{"101":1,"170":1}}],["对象",{"2":{"9":1,"195":1,"207":1}}],["对",{"2":{"4":1,"5":1,"12":1,"141":1,"151":1,"175":1,"183":1}}],["和第一个哈希函数不同",{"2":{"143":1}}],["和开放地址法",{"2":{"138":1}}],["和其他数据结构一样",{"2":{"130":1}}],["和右子树",{"2":{"87":1}}],["和堆的最后一个元素交换",{"2":{"56":1}}],["和堆的最后一个元素",{"2":{"56":1}}],["和词典",{"2":{"45":1}}],["和一个字符串字典",{"2":{"45":1}}],["和起始索引",{"2":{"44":1}}],["和剩余可选择的数字",{"2":{"43":1}}],["和饼干尺寸数组",{"2":{"34":1}}],["和整数",{"2":{"21":1}}],["和斐波那契数列类似",{"2":{"11":1}}],["和",{"2":{"4":3,"5":4,"11":1,"26":1,"34":1,"35":1,"45":1,"53":1,"55":1,"67":1,"122":1,"162":1,"175":1,"183":1,"186":1,"223":1,"236":4,"238":1}}],["将栈结构的内容以字符串的形式返回",{"2":{"226":1}}],["将队列中的元素以字符串形式返回",{"2":{"204":1}}],["将队列中的内容",{"2":{"203":1}}],["将队列中元素以字符串形式返回",{"2":{"195":1}}],["将队头关联的点添加到队尾",{"2":{"132":1}}],["将字典所包含的所有数值以数组形式返回",{"2":{"187":1}}],["将字典所包含的所有键名以数组形式返回",{"2":{"187":1}}],["将字母转化为数字也有很多种方案",{"2":{"136":1}}],["将这个字典中的所有元素全部删除",{"2":{"187":1}}],["将大数字转化成数组范围内下标的过程",{"2":{"137":1}}],["将颜色设置为访问中",{"2":{"133":1}}],["将传入的顶点放入队列",{"2":{"132":1}}],["将入队列",{"2":{"132":1}}],["将添加的顶点放入到数组中",{"2":{"126":1}}],["将经过两个顶点的每条航线看作一条边",{"2":{"118":1}}],["将每个机场看成顶点",{"2":{"118":1}}],["将每个数字加入当前路径",{"2":{"43":2,"44":2}}],["将后续的左节点改为被删除的左节点",{"2":{"82":1,"83":1}}],["将统计数组中的值进行累加",{"2":{"58":1}}],["将数据插入到",{"2":{"154":1}}],["将数字放入相应的桶中",{"2":{"57":1}}],["将数字按照十位的值进行分组",{"2":{"57":1}}],["将数字按照个位的值进行分组",{"2":{"57":1}}],["将数组从中间分成两个子数组",{"2":{"54":1}}],["将数组重新排列",{"2":{"21":1}}],["将数组分成左右两部分",{"2":{"18":2,"19":1,"20":1}}],["将数组分为比枢纽值大和比枢纽值小的两个部分",{"2":{"12":1}}],["将所有分组合并为一个数组",{"2":{"57":1}}],["将元素加入到队列中",{"2":{"204":1}}],["将元素按优先级加入到队列中",{"2":{"195":1}}],["将元素按照该位的值进行分组",{"2":{"57":1}}],["将元素放置到正确的位置上",{"2":{"58":1}}],["将元素插入到已排序部分的正确位置后",{"2":{"52":1}}],["将堆顶",{"2":{"56":1}}],["将无序数组构建成一个最大堆",{"2":{"56":1}}],["将较小的元素加入结果数组中",{"2":{"54":1}}],["将两个有序的子数组合并成一个有序的数组",{"2":{"54":1}}],["将前一个元素后移",{"2":{"53":1}}],["将待排序数组中的元素放置到正确的位置上",{"2":{"58":1}}],["将待排序数组分成两半",{"2":{"54":1}}],["将待排序数组分成若干个子序列",{"2":{"53":1}}],["将待排序数组根据当前增量值分成若干个子序列",{"2":{"53":1}}],["将待排序数组的第一个元素视为已排序部分",{"2":{"52":1}}],["将找到的位置插入元素",{"2":{"52":1}}],["将找到的最小",{"2":{"51":1}}],["将其顺时针旋转",{"2":{"240":1}}],["将其删除",{"2":{"156":1,"164":1,"207":1}}],["将其标注为被发现的",{"2":{"131":1}}],["将其与已排序部分的元素逐个比较",{"2":{"52":1}}],["将其插入到已排序部分的正确位置",{"2":{"52":1}}],["将其加入结果集",{"2":{"43":1}}],["将已排序部分的长度增加",{"2":{"51":1}}],["将整个序列看作两部分",{"2":{"51":1}}],["将标志设置为",{"2":{"50":1}}],["将词典转化为集合",{"2":{"45":1}}],["将当前集合",{"2":{"216":1,"220":1}}],["将当前子字符串",{"2":{"45":1}}],["将当前子字符串的结果存入缓存",{"2":{"45":1}}],["将当前子字符串的结果存入缓存中",{"2":{"45":1}}],["将当前单词和递归结果组合成新的句子",{"2":{"45":1}}],["将当前数字加入路径",{"2":{"44":1}}],["将当前路径",{"2":{"44":2}}],["将当前路径加入结果集",{"2":{"43":1,"44":1}}],["将最后一个元素移除",{"2":{"43":1,"44":1}}],["将问题抽象成一个决策树",{"2":{"40":1}}],["将问题抽象为数学模型",{"2":{"31":1}}],["将区间按照结束时间进行排序",{"2":{"37":1}}],["将孩子的胃口数组",{"2":{"34":1}}],["将原问题分解为若干子问题",{"2":{"23":1}}],["将原问题划分成若干个规模较小的子问题",{"2":{"15":1}}],["将剩余的元素添加到结果数组",{"2":{"19":1}}],["将子问题的解合并成原问题的解",{"2":{"15":1}}],["将文本转换为小写",{"2":{"9":1}}],["将新的参数数组求和并加到当前",{"2":{"8":1}}],["将",{"2":{"4":1,"5":1,"66":1,"127":2,"132":5,"159":1,"207":1,"216":1,"220":1}}],["为递归函数",{"2":{"223":1}}],["为什么没有停止条件的递归会造成栈溢出",{"2":{"223":1}}],["为什么需要扩容",{"2":{"159":1}}],["为度为",{"2":{"89":1}}],["为叶子节点",{"2":{"89":1}}],["为父节点",{"2":{"80":4}}],["为根节点",{"2":{"80":2}}],["为止",{"2":{"69":1,"77":1}}],["为空",{"2":{"45":1}}],["为空字符串",{"2":{"45":1}}],["为当前区间的结束时间",{"2":{"37":2}}],["为负无穷大",{"2":{"37":1}}],["为了提供效率",{"2":{"148":1}}],["为了方便理解我们创建这样一套编码系统",{"2":{"136":1}}],["为了把字符串转化为对应的下标值",{"2":{"136":1}}],["为了记录顶点是否被访问过",{"2":{"131":1}}],["为了保证算法的效率",{"2":{"131":1}}],["为了能够正确的显示图的结果",{"2":{"128":1}}],["为了能以较快的时间",{"2":{"84":1}}],["为了到达第",{"2":{"26":1}}],["为了找到数组中的第",{"2":{"21":1}}],["为",{"2":{"4":1,"5":1,"20":1,"36":2,"136":4,"172":1,"173":1,"175":1,"183":3}}],["bucket",{"2":{"154":14,"155":7,"156":9,"159":2,"160":3,"164":23}}],["bubblesort",{"2":{"50":2}}],["bubble",{"2":{"50":1}}],["black",{"2":{"132":1,"133":1}}],["bfs",{"0":{"132":1},"2":{"131":2,"132":3}}],["breadth",{"2":{"131":1}}],["break",{"2":{"12":1,"50":1,"195":1}}],["backwardstring",{"0":{"110":1},"2":{"110":2,"112":2,"113":2}}],["backwordstring",{"2":{"101":1}}],["backtrack",{"2":{"43":6,"44":6,"45":6}}],["bst",{"2":{"65":1}}],["bb",{"2":{"64":3,"174":1,"175":1,"178":2}}],["binarystring",{"2":{"230":3}}],["binarysearch",{"2":{"48":3}}],["binary",{"2":{"48":1,"65":1,"91":2,"92":1}}],["bill",{"2":{"35":3}}],["bills",{"2":{"35":7}}],["be",{"2":{"10":2}}],["b|",{"2":{"5":3}}],["b",{"2":{"4":7,"5":16,"12":6,"34":4,"37":2,"71":1,"88":1,"89":1,"94":2,"116":2,"120":4,"121":2,"122":1,"129":4,"132":1,"133":1,"136":1,"160":3,"164":3,"173":1,"196":4,"205":2,"223":7,"224":2,"236":6,"238":2,"239":2}}],["google",{"2":{"250":1}}],["gray",{"2":{"132":2,"133":1}}],["graph",{"2":{"124":2,"129":13,"132":2,"133":1,"245":1}}],["greater",{"2":{"10":2}}],["getprime",{"2":{"154":1,"156":1,"160":2,"163":5,"164":4}}],["get",{"0":{"155":1},"2":{"127":2,"128":1,"132":1,"133":1,"150":1,"155":2,"164":2,"170":1,"187":1,"189":2,"190":2}}],["getdata",{"0":{"176":1},"2":{"112":3,"113":2,"176":3,"183":2}}],["getdigit",{"2":{"57":2}}],["getelement",{"2":{"101":1}}],["getsuccessor",{"2":{"82":2,"83":2}}],["getmaxcommondivisor",{"2":{"4":4}}],["gap",{"2":{"53":14}}],["gt",{"2":{"27":1,"34":1,"66":1,"69":1,"71":8,"72":14,"73":14,"77":1,"89":2,"116":1,"117":4,"121":2,"159":1,"160":1,"223":6,"224":5,"235":2,"236":1}}],["g",{"2":{"7":1,"9":1,"34":9,"71":1,"89":1,"94":1,"129":3,"132":1,"133":1}}],["gcd",{"2":{"4":1,"5":8}}],["时将该元素删除",{"2":{"206":1}}],["时就会发现",{"2":{"141":1}}],["时不会跳过空位置去插入其他位置",{"2":{"141":1}}],["时的最少硬币数为",{"2":{"29":1}}],["时间复杂度可以达到",{"2":{"168":1}}],["时间复杂度可能达到",{"2":{"21":1}}],["时间复杂度也是",{"2":{"84":1}}],["时间复杂度为",{"2":{"55":1}}],["时间复杂度",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":2,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1,"50":1,"54":1,"56":1}}],["时间复杂度降为了",{"2":{"10":1}}],["时",{"2":{"4":1,"19":1,"20":1,"53":1,"62":1,"141":3,"154":1,"160":2,"173":3,"183":3,"207":2,"235":1}}],["0~9",{"2":{"139":1}}],["000",{"2":{"249":5}}],["00",{"2":{"113":1}}],["0",{"2":{"4":3,"5":2,"8":3,"9":1,"10":7,"11":7,"12":6,"18":2,"19":11,"20":3,"21":1,"26":5,"27":9,"28":17,"29":13,"34":3,"35":6,"36":10,"37":6,"38":4,"43":8,"44":5,"47":2,"48":2,"50":2,"51":1,"52":2,"53":2,"54":4,"55":2,"56":5,"57":7,"58":7,"62":5,"101":1,"105":5,"106":5,"107":4,"112":9,"113":3,"117":15,"121":3,"128":2,"129":1,"131":1,"132":3,"133":2,"143":2,"150":1,"151":1,"153":1,"154":3,"155":1,"156":2,"157":1,"159":1,"160":5,"162":2,"163":1,"164":12,"170":1,"172":2,"173":3,"175":10,"176":3,"177":1,"178":3,"179":5,"181":1,"183":25,"195":2,"204":2,"207":1,"227":1,"230":2,"235":4,"236":2}}],["用",{"2":{"235":1}}],["用的不多",{"2":{"212":1}}],["用这次哈希化的结果作为该关键字的步长",{"2":{"143":1}}],["用于保存不同的元素",{"2":{"135":1}}],["用于保存它的父节点",{"2":{"78":1}}],["用于保存需要删除的节点",{"2":{"78":1}}],["用于查找插入点",{"2":{"69":1}}],["用于缓存子字符串的结果和存储递归栈",{"2":{"45":1}}],["用于快速查找",{"2":{"45":1}}],["用于记录需要移除的区间数量",{"2":{"37":1}}],["用于继续累加新的参数",{"2":{"8":1}}],["用于存储所有的边",{"2":{"124":1}}],["用于存储所有的顶点",{"2":{"124":1}}],["用于存储对应的其他数据",{"2":{"120":1}}],["用于存储待插入的元素的临时变量",{"2":{"52":1}}],["用于存储递归调用栈和临时路径",{"2":{"43":1,"44":1}}],["用于存储频率最高的单词及其出现次数",{"2":{"9":1}}],["用于存储唯一的元素",{"2":{"2":1}}],["用于存储扁平化后的元素",{"2":{"1":1}}],["用大的数去除以小的那个数",{"2":{"4":1}}],["求两个集合的交集",{"2":{"217":1,"220":1}}],["求两个集合的并集",{"2":{"216":1,"220":1}}],["求两个数的最小公倍数",{"0":{"5":1}}],["求两个数的最大公约数",{"0":{"4":1}}],["求多项式的值时",{"2":{"147":1}}],["求和得到最少需要的糖果数",{"2":{"38":1}}],["求该青蛙跳上一个",{"2":{"11":1}}],["求数组的最大值和最小值",{"0":{"3":1}}],["myvertexes",{"2":{"129":3}}],["myarray4",{"2":{"64":3}}],["myarray3",{"2":{"64":3}}],["myarray2",{"2":{"63":3}}],["myarray",{"2":{"62":3}}],["monday",{"2":{"60":4}}],["mostdigits",{"2":{"57":2}}],["mostfrequentword",{"2":{"9":3}}],["memo",{"2":{"45":7}}],["merge",{"2":{"19":2,"54":3}}],["mergesort",{"2":{"19":4,"54":4}}],["m",{"2":{"29":2,"34":5,"94":1,"235":2}}],["mid",{"2":{"18":3,"19":3,"20":7,"48":6,"54":3}}],["minloadfactor",{"2":{"156":1,"160":1,"163":1,"164":2}}],["minindex",{"2":{"51":4}}],["min",{"2":{"3":3,"29":2,"58":7,"68":1,"76":2}}],["majorityelementrec",{"2":{"18":4}}],["majorityelement",{"2":{"18":5}}],["man",{"2":{"7":1}}],["maxdigitcount",{"2":{"57":2}}],["maxdigits",{"2":{"57":4}}],["maxreach",{"2":{"36":16}}],["maxcrossingsubarray",{"2":{"20":2}}],["maxcount",{"2":{"9":4}}],["maxsubarray",{"2":{"20":4}}],["max",{"2":{"3":3,"20":1,"27":3,"28":5,"36":3,"38":1,"56":1,"57":1,"58":5,"68":1,"76":2}}],["math",{"2":{"3":6,"5":2,"12":2,"18":1,"19":1,"20":2,"27":2,"28":5,"29":2,"36":1,"38":1,"48":1,"56":1,"57":6,"156":1,"160":1,"162":2,"163":1,"164":1,"230":1}}],["mapreduce",{"2":{"16":1}}],["map",{"2":{"1":1,"126":1,"186":1,"189":1,"190":14,"203":1}}],["names",{"2":{"208":3}}],["namelist",{"2":{"207":4}}],["name",{"2":{"185":1,"190":4,"207":2}}],["next",{"2":{"100":2,"104":1,"105":5,"106":5,"107":6,"109":1,"112":13,"172":1,"173":7,"174":1,"175":5,"176":1,"177":1,"178":1,"179":6,"183":22}}],["newlimit",{"2":{"160":2,"164":2}}],["newnode",{"2":{"69":8,"104":6,"105":14,"106":14,"112":20,"173":5,"175":7,"183":10}}],["newpivotindex",{"2":{"12":6}}],["new",{"2":{"2":1,"26":1,"27":1,"28":1,"29":1,"38":1,"45":1,"58":1,"60":2,"69":1,"104":1,"105":1,"106":1,"112":2,"113":1,"124":1,"129":1,"132":1,"173":2,"175":1,"183":2,"190":1,"195":1,"196":1,"205":1,"207":2,"214":1,"216":1,"217":1,"218":1,"220":3,"230":2}}],["n~2~",{"2":{"89":2}}],["n~2~表示度为",{"2":{"89":1}}],["n~0~",{"2":{"89":3}}],["node",{"2":{"67":1,"69":15,"71":5,"72":5,"73":5,"76":10,"77":16,"95":2,"101":1,"103":2,"170":1,"172":2,"173":1,"175":1,"183":4,"239":3}}],["n^",{"2":{"53":2}}],["n^2",{"2":{"21":1,"27":1,"45":2,"50":4,"51":7,"52":5,"53":2,"55":2,"147":1}}],["nlogk",{"2":{"12":1}}],["n+1",{"2":{"11":1,"26":1,"147":1}}],["num",{"2":{"18":2,"57":5,"162":2}}],["nums",{"2":{"12":41,"18":16,"19":11,"20":15,"21":22,"27":17,"28":15,"36":9,"43":11,"44":13,"57":10}}],["number++",{"2":{"163":1,"164":1}}],["number",{"2":{"10":2,"64":1,"162":11,"163":5,"164":5,"206":2,"207":9}}],["null",{"2":{"3":2,"67":2,"69":3,"71":1,"72":1,"73":1,"76":4,"77":3,"78":2,"79":8,"80":4,"82":1,"83":10,"100":2,"103":2,"104":1,"105":2,"106":2,"107":6,"109":1,"110":1,"112":12,"141":2,"155":6,"156":5,"164":3,"169":2,"172":3,"173":2,"174":1,"175":2,"176":1,"179":2,"183":11,"239":3}}],["n",{"2":{"10":12,"11":18,"12":7,"18":12,"19":4,"20":5,"21":5,"26":15,"27":2,"28":14,"29":3,"34":5,"35":2,"36":1,"37":2,"38":8,"41":1,"43":6,"44":4,"45":1,"47":2,"48":2,"50":5,"51":4,"52":2,"53":6,"54":12,"55":16,"56":22,"57":9,"58":9,"84":6,"128":1,"147":7,"148":1,"235":4}}],["algorithm",{"0":{"247":1},"2":{"248":1}}],["age",{"2":{"185":1,"190":5}}],["abc",{"2":{"151":1,"177":1,"214":5}}],["abstract",{"2":{"243":1}}],["abs",{"2":{"5":2,"57":2}}],["adt",{"2":{"243":1}}],["adjoin",{"2":{"124":1}}],["adj",{"2":{"124":1,"128":3,"133":3}}],["adjlist",{"2":{"124":3,"126":1,"127":2,"128":1,"132":1,"133":1}}],["added",{"2":{"195":3}}],["addedge",{"2":{"127":1,"129":10}}],["address",{"2":{"190":1}}],["addvertex",{"2":{"126":1,"129":1}}],["add",{"2":{"8":8,"212":1,"213":2,"214":5,"216":3,"217":1,"218":1,"220":7}}],["append",{"0":{"104":1,"173":1},"2":{"101":1,"104":3,"112":3,"113":4,"170":1,"173":6,"183":2}}],["applepen",{"2":{"45":4}}],["apple",{"2":{"45":10}}],["apply",{"2":{"3":4}}],["avl",{"2":{"84":3}}],["amp",{"0":{"82":1},"2":{"148":1}}],["amount",{"2":{"29":14}}],["aaaaaaaaaa",{"2":{"136":1}}],["aa",{"2":{"64":6,"174":1,"175":1,"176":1,"177":1,"178":1}}],["and",{"2":{"45":6,"54":1,"55":1}}],["arr",{"2":{"48":4}}],["array",{"2":{"1":7,"2":12,"3":3,"26":1,"27":1,"28":1,"29":1,"38":1,"47":3,"50":13,"51":14,"52":11,"53":11,"54":7,"55":11,"56":23,"57":1,"58":13,"60":2,"62":3,"63":3,"64":2,"245":1}}],["args",{"2":{"8":4}}],["a",{"2":{"4":6,"5":15,"7":4,"9":2,"12":6,"34":4,"37":2,"62":3,"71":1,"88":1,"89":1,"94":2,"116":2,"120":4,"121":4,"122":3,"129":4,"132":5,"133":1,"136":1,"173":1,"196":2,"205":2,"223":8,"224":2,"236":1,"238":1,"239":1}}],["88",{"2":{"231":1}}],["802",{"2":{"57":6}}],["860",{"2":{"35":1}}],["89",{"2":{"11":1}}],["8",{"2":{"3":1,"4":2,"8":2,"12":5,"20":2,"26":1,"34":2,"58":4,"72":1,"73":1,"79":2,"81":2,"82":1,"94":2}}],["定义存储",{"2":{"151":1}}],["定义了两个属性",{"2":{"124":1}}],["定义回溯函数",{"2":{"45":1}}],["定义缓存",{"2":{"45":2}}],["定义变量",{"2":{"36":1,"82":1,"83":1}}],["定义状态",{"2":{"26":1,"27":1,"28":1,"29":1}}],["定义子问题",{"2":{"23":1}}],["定义一个增量序列",{"2":{"53":1}}],["定义一个回溯函数",{"2":{"43":1,"44":1}}],["定义一个变量记录是否成功添加了新元素",{"2":{"195":1}}],["定义一个变量",{"2":{"36":1,"159":1}}],["定义一个数组",{"2":{"26":1,"27":1,"28":1,"29":1}}],["定义一个内部函数",{"2":{"8":1}}],["定义一个函数来计算两个数的最大公约数",{"2":{"4":1}}],["定义一个包含若干数字的数组",{"2":{"3":1}}],["定义结果数组",{"2":{"1":1,"2":1}}],["数中有一个称为根",{"2":{"235":1}}],["数学中常指的集合中的元素是可以重复的",{"2":{"210":1}}],["数字之前的人重新放入到队尾",{"2":{"207":1}}],["数字相加",{"2":{"136":1}}],["数据结构和算法的创新和优化是必不可少的",{"2":{"250":1}}],["数据结构和算法是计算机科学的核心内容",{"2":{"250":1}}],["数据结构的实现",{"2":{"248":1}}],["数据结构的定义",{"0":{"243":1}}],["数据结构与算法与语言无关",{"2":{"245":1}}],["数据结构与算法分析",{"2":{"243":1}}],["数据结构在生活中应用",{"0":{"244":1}}],["数据结构就是在计算机中",{"2":{"243":1}}],["数据结构是",{"2":{"243":1}}],["数据结构是数据对象",{"2":{"243":1}}],["数据结构",{"2":{"243":2}}],["数据结构去重",{"2":{"2":1}}],["数据的插入和删除操作效率都很高",{"2":{"235":1}}],["数据",{"2":{"143":1}}],["数据压缩",{"2":{"16":1}}],["数组是一个线性结构",{"2":{"221":1}}],["数组是最简单的内存数据结构",{"2":{"59":1}}],["数组形式",{"2":{"185":1}}],["数组缺点",{"2":{"167":1}}],["数组内容",{"2":{"160":1,"164":1}}],["数组每一个下标值对应的位置存储的不再是一个数字了",{"2":{"139":1}}],["数组常见操作",{"0":{"61":1},"1":{"62":1,"63":1,"64":1}}],["数组中可以保存不同类型的值",{"2":{"59":1}}],["数组中的元素互不相同",{"2":{"44":1}}],["数组中的元素而不改变其余元素的顺序",{"2":{"27":1}}],["数组中的每个元素代表你在该位置可以跳跃的最大长度",{"2":{"36":1}}],["数组中的最大值",{"2":{"27":1}}],["数组中的第",{"0":{"21":1}}],["数组求和得到最少需要的糖果数",{"2":{"38":1}}],["数组的创建需要申请一段连续的内存空间",{"2":{"167":1}}],["数组的",{"2":{"46":1,"49":1}}],["数组的最后一个值",{"2":{"28":1}}],["数组的大小需要是",{"2":{"11":1}}],["数组来存储每个台阶的方法数",{"2":{"26":1}}],["数组",{"0":{"59":1,"167":1,"197":1},"1":{"60":1,"61":1,"62":1,"63":1,"64":1},"2":{"23":1,"27":2,"28":3,"29":2,"38":2,"44":3,"122":1,"159":1,"167":1,"235":1,"245":1}}],["数组去重",{"0":{"2":1}}],["数组扁平化",{"0":{"1":1}}],["sibling",{"2":{"236":1}}],["size",{"0":{"158":1,"182":1},"2":{"101":1,"112":3,"150":1,"164":1,"170":1,"182":3,"183":2,"187":1,"189":2,"190":2,"195":4,"196":2,"203":1,"204":2,"205":2,"207":1,"212":1,"213":2,"214":2,"220":2,"226":1,"227":2,"228":2}}],["swift",{"2":{"186":1}}],["swap",{"2":{"51":2}}],["sqrt",{"2":{"162":1}}],["splice",{"2":{"62":3,"63":2,"64":4,"156":1,"164":1,"195":1}}],["split",{"2":{"1":1,"7":1,"9":1}}],["saturday",{"2":{"60":4}}],["sand",{"2":{"45":6}}],["shift",{"2":{"63":1,"204":1}}],["shell",{"2":{"53":1}}],["should",{"2":{"10":2}}],["super",{"2":{"103":2,"112":6,"195":5}}],["successorparent",{"2":{"82":3,"83":3}}],["successor",{"2":{"82":12,"83":12}}],["sunday",{"2":{"60":4}}],["subtree",{"2":{"235":1}}],["subset",{"2":{"219":2,"220":2}}],["subsets",{"2":{"44":4}}],["sub",{"2":{"45":3}}],["subresult",{"2":{"45":2}}],["sum",{"2":{"8":4,"20":8,"38":2}}],["s",{"2":{"34":9,"45":29}}],["sedgewick",{"2":{"53":2}}],["sequence",{"2":{"53":1}}],["sequentialsearch",{"2":{"47":3}}],["sequential",{"2":{"47":1}}],["search2",{"2":{"77":1}}],["searchnode",{"2":{"77":4}}],["search",{"2":{"47":1,"48":1,"65":1,"68":1,"77":2,"131":2}}],["selectionsort",{"2":{"51":2}}],["selection",{"2":{"51":1}}],["select",{"2":{"12":4}}],["set",{"2":{"2":3,"45":1,"126":1,"187":1,"189":2,"190":4,"211":2,"213":1,"214":15,"216":1,"217":1,"218":1,"220":4}}],["stack",{"2":{"222":1,"223":1,"227":1,"228":9,"230":6,"245":1}}],["startswith",{"2":{"45":1}}],["start",{"2":{"37":4,"44":4,"63":1}}],["starti",{"2":{"37":1}}],["storage",{"2":{"153":1,"154":4,"155":2,"156":2,"159":4,"160":4,"164":10}}],["storeindex++",{"2":{"12":1}}],["storeindex",{"2":{"12":6}}],["stepsize",{"2":{"143":2}}],["structure",{"2":{"243":1}}],["string",{"2":{"151":2}}],["str",{"2":{"7":2}}],["slice",{"2":{"12":1,"19":2,"43":2,"45":2,"54":2}}],["sortedindex++",{"2":{"58":1}}],["sortedindex",{"2":{"58":2}}],["sortedarray",{"2":{"19":6}}],["sortednums",{"2":{"12":2}}],["sortarray",{"2":{"19":3}}],["sort",{"2":{"12":3,"34":2,"37":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":2,"57":1,"58":1}}],["s+",{"2":{"9":1}}],["测试封装的栈结构",{"0":{"228":1}}],["测试用例",{"2":{"18":1}}],["测试",{"0":{"231":1},"2":{"2":2,"47":1,"48":1,"50":1,"51":1,"113":9,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"190":7,"196":5,"205":6,"208":1,"214":6,"228":6,"231":1}}],["测试代码",{"0":{"129":1,"196":1,"205":1,"208":1},"2":{"1":1,"4":2,"5":1,"129":1,"132":1,"133":1}}],["返回以字符串形式的栈内元素数据",{"2":{"227":1}}],["返回栈里的元素个数",{"2":{"226":1}}],["返回栈顶的元素",{"2":{"226":1}}],["返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合",{"2":{"215":1}}],["返回一个包含两个集合中共有元素的新集合",{"2":{"215":1}}],["返回一个包含两个集合中所有元素的新集合",{"2":{"215":1}}],["返回一个包含集合中所有值的数组",{"2":{"212":1}}],["返回集合所包含元素的数量",{"2":{"212":1}}],["返回这个人在原数组中对应的索引",{"2":{"207":1}}],["返回删除的那个元素",{"2":{"204":1}}],["返回删除的元素",{"2":{"195":1}}],["返回队列包含的元素个数",{"2":{"203":1}}],["返回队列中的第一个元素",{"2":{"203":1}}],["返回字典所包含元素的数量",{"2":{"187":1}}],["返回指定",{"2":{"177":1,"183":1}}],["返回哈希表包含的元素个数",{"2":{"150":1}}],["返回反向遍历的节点的字符串形式",{"2":{"101":1}}],["返回正向遍历节点字符串形式",{"2":{"101":1}}],["返回链表包含的元素个数",{"2":{"101":1,"170":1}}],["返回元素在链表中的索引",{"2":{"101":1,"170":1}}],["返回树中最大的值",{"2":{"68":1}}],["返回树中最小的值",{"2":{"68":1}}],["返回排序后的数组",{"2":{"50":1,"53":1}}],["返回索引",{"2":{"48":1}}],["返回最终结果",{"2":{"45":1}}],["返回所有可能的句子",{"2":{"45":1}}],["返回所有的子集",{"2":{"44":1}}],["返回所有的排列",{"2":{"43":1}}],["返回包含一个空字符串的数组",{"2":{"45":3}}],["返回该数组所有可能的子集",{"2":{"44":1}}],["返回该元素",{"2":{"20":1}}],["返回需要移除的区间数量",{"2":{"37":1}}],["返回需要移除区间的最小数量",{"2":{"37":1}}],["返回满足孩子的数量",{"2":{"34":1}}],["返回到达第",{"2":{"26":1}}],["返回结果",{"2":{"23":1,"35":1,"36":1,"37":1,"45":1}}],["返回跨越中间点的最大子数组和",{"2":{"20":1}}],["返回三个部分中最大的值",{"2":{"20":1}}],["返回数组的唯一元素",{"2":{"20":1}}],["返回数组本身",{"2":{"19":1}}],["返回其所有可能的句子组合",{"2":{"45":1}}],["返回其所有可能的全排列",{"2":{"43":1}}],["返回其最大和",{"2":{"20":1}}],["返回其中的多数元素",{"2":{"18":1}}],["返回出现次数较多的元素",{"2":{"18":1}}],["返回第",{"2":{"10":1,"11":1}}],["返回频率最高的单词及其出现次数",{"2":{"9":1}}],["返回",{"2":{"8":2,"11":1,"27":1,"28":1,"29":3,"35":4,"36":6,"78":1,"83":1,"101":1,"150":1,"156":1,"170":1,"176":1,"177":1,"183":2,"189":2,"203":1,"212":1,"213":1,"219":1,"220":2}}],["返回去重后的结果数组",{"2":{"2":1}}],["返回扁平化后的结果数组",{"2":{"1":1}}],["python",{"2":{"186":1}}],["put",{"0":{"154":1},"2":{"150":1,"154":2,"160":2,"163":2,"164":4}}],["push",{"2":{"2":1,"12":1,"19":4,"43":2,"44":2,"45":1,"54":4,"55":2,"57":1,"62":1,"71":1,"72":1,"73":1,"126":1,"127":2,"154":1,"160":1,"164":1,"195":2,"204":1,"226":1,"227":3,"228":4,"230":1}}],["position",{"0":{"105":1,"106":1,"107":1,"108":1},"2":{"101":4,"105":8,"106":8,"107":7,"108":6,"112":23,"170":4,"175":13,"176":7,"178":8,"179":11,"183":36}}],["postordertraversalnode",{"2":{"73":4}}],["postordertraversal",{"2":{"73":1}}],["postordertraverse",{"2":{"68":1}}],["pop",{"2":{"43":2,"44":2,"63":1,"226":1,"227":3,"228":2,"230":1}}],["place",{"2":{"57":2}}],["plan",{"2":{"7":1}}],["peek",{"2":{"203":1,"226":1,"227":2,"228":2}}],["perv",{"2":{"105":1,"106":1,"107":1,"112":2}}],["perfect",{"2":{"91":1}}],["permute",{"2":{"43":5}}],["pen",{"2":{"45":6}}],["pineapple",{"2":{"45":4}}],["pineapplepenapple",{"2":{"45":2}}],["pine",{"2":{"45":6}}],["pivot",{"2":{"21":3,"55":6}}],["pivotvalue",{"2":{"12":2}}],["pivotindex",{"2":{"12":6,"21":6}}],["priorityqueue",{"2":{"195":1,"196":14}}],["priority",{"2":{"195":10,"196":8}}],["prime",{"2":{"151":2}}],["prim",{"2":{"32":1}}],["preordertraversalnode",{"2":{"71":4}}],["preordertraversal",{"2":{"71":1}}],["preordertraverse",{"2":{"68":1}}],["previousnode",{"2":{"105":4,"106":4,"107":4,"112":8,"175":4,"179":3,"183":7}}],["prev2",{"2":{"28":3}}],["prev1",{"2":{"28":5}}],["prev",{"2":{"10":5,"100":2,"103":2,"104":1,"105":3,"106":3,"107":3,"110":1,"112":8}}],["prevprev",{"2":{"10":3}}],["pre",{"2":{"1":3,"8":4}}],["passgame",{"2":{"207":1,"208":2}}],["parentnode",{"2":{"78":3,"79":2,"80":8,"82":2,"83":15}}],["parent",{"2":{"78":2,"79":2,"80":8,"236":1}}],["parseint",{"2":{"53":2,"54":1}}],["partition",{"2":{"12":3,"21":2}}],["path",{"2":{"43":9,"44":11}}],["panama",{"2":{"7":1}}],["检查输入是否为数组且长度大于",{"2":{"50":1}}],["检查输入是否有效",{"2":{"10":1}}],["检查当前选择是否满足问题的约束条件",{"2":{"40":1}}],["检查当前位置是否能够到达",{"2":{"36":1}}],["检查约束条件",{"2":{"40":1}}],["检查每个孩子与后一个孩子的评分",{"2":{"38":1}}],["检查每个孩子与前一个孩子的评分",{"2":{"38":1}}],["检查终止条件",{"2":{"36":1}}],["检查是否超过了",{"2":{"36":1}}],["检查是否可达",{"2":{"36":1}}],["检查是否有足够的",{"2":{"35":1}}],["检查结果数组中是否已经包含当前元素",{"2":{"2":1}}],["检查传入的参数是否为数组",{"2":{"1":1,"2":2}}],["利用栈结构的特点封装实现十进制转换为二进制的方法",{"2":{"229":1}}],["利用队列结构的特点实现击鼓传花游戏求解方法的封装",{"2":{"207":1}}],["利用了堆数据结构的特性",{"2":{"56":1}}],["利用状态转移方程",{"2":{"23":1}}],["利用",{"2":{"1":1}}],["654",{"2":{"224":1}}],["65432",{"2":{"224":1}}],["654321",{"2":{"224":2}}],["6543",{"2":{"136":1,"224":1}}],["65",{"2":{"185":1,"224":1}}],["63",{"2":{"142":1}}],["60337",{"2":{"136":1}}],["66",{"2":{"57":6}}],["6",{"2":{"1":4,"3":1,"5":2,"8":1,"12":4,"20":3,"21":4,"27":2,"34":1,"37":1,"43":1,"50":2,"51":2,"52":2,"53":2,"54":2,"55":2,"56":2,"57":2,"58":3,"64":4,"65":4,"72":1,"73":1,"80":1,"84":1,"94":2,"117":1,"136":1,"141":1,"151":1,"224":11}}],["500",{"2":{"249":1}}],["54321",{"2":{"178":2,"179":1,"180":1}}],["5设置访问完的点为黑色",{"2":{"132":1}}],["53",{"2":{"20":1}}],["55",{"2":{"8":1,"36":1}}],["5",{"2":{"1":4,"2":4,"8":2,"10":1,"12":4,"18":1,"19":8,"20":4,"21":8,"26":2,"27":2,"28":1,"29":7,"34":1,"35":27,"36":1,"37":2,"38":4,"47":2,"48":2,"50":2,"51":2,"52":2,"53":2,"54":2,"55":2,"56":2,"57":2,"58":3,"63":1,"64":4,"72":1,"73":1,"80":5,"81":1,"82":1,"84":1,"89":1,"94":2,"117":3,"136":1,"141":1,"143":2,"151":1,"154":1,"164":1,"207":1,"224":10}}],["43",{"2":{"136":3}}],["435",{"2":{"37":1}}],["45°",{"2":{"240":1}}],["456",{"2":{"175":2,"178":2,"179":1,"180":1,"214":1}}],["45",{"2":{"57":6}}],["455",{"2":{"34":1}}],["46",{"2":{"43":1}}],["4181",{"2":{"10":1}}],["4",{"2":{"1":4,"2":5,"3":1,"4":2,"5":2,"8":3,"11":1,"12":12,"20":7,"21":8,"26":1,"27":5,"28":4,"29":3,"35":1,"36":5,"37":5,"38":4,"47":2,"48":2,"50":2,"51":2,"52":2,"53":4,"54":2,"55":2,"56":2,"57":2,"58":6,"63":1,"64":3,"66":2,"80":1,"84":1,"89":1,"94":2,"117":2,"120":1,"132":5,"133":1,"136":1,"141":1,"143":1,"154":1,"162":1,"164":1,"207":1,"208":1,"224":10,"236":1}}],["31",{"2":{"151":1}}],["3~7",{"2":{"141":1}}],["33",{"2":{"141":1}}],["322",{"2":{"29":1}}],["300",{"2":{"27":1}}],["34",{"2":{"10":1}}],["39",{"2":{"10":1}}],["3",{"2":{"1":4,"2":5,"8":4,"9":1,"10":2,"11":5,"12":8,"18":6,"19":4,"20":3,"21":6,"26":4,"27":10,"28":10,"29":7,"34":8,"35":4,"36":7,"37":14,"38":3,"43":15,"44":10,"45":1,"47":3,"48":3,"50":2,"51":7,"52":2,"53":4,"54":2,"55":2,"56":2,"57":2,"58":9,"62":2,"63":4,"64":3,"65":3,"66":1,"72":1,"73":1,"78":1,"80":2,"82":2,"83":3,"84":1,"94":2,"105":1,"106":1,"112":1,"113":1,"117":2,"120":1,"132":2,"133":1,"136":4,"141":1,"142":1,"151":1,"154":1,"160":1,"164":2,"173":1,"175":1,"176":1,"178":1,"179":2,"182":1,"183":5,"196":1,"207":1,"216":1,"220":1,"224":10,"228":3,"236":1,"238":1,"244":1}}],["21",{"2":{"224":1}}],["213",{"2":{"142":1}}],["215",{"2":{"21":1}}],["26",{"2":{"136":1,"141":1}}],["22222",{"2":{"113":1}}],["22",{"2":{"113":1}}],["25",{"2":{"72":1,"73":1,"141":1,"160":1,"164":1}}],["2^",{"2":{"89":1}}],["2^k^",{"2":{"89":1}}],["2^k",{"2":{"53":1}}],["2^n",{"2":{"44":2}}],["27^2",{"2":{"136":1}}],["27^3",{"2":{"136":1}}],["27",{"2":{"29":1,"136":3,"141":1}}],["20",{"2":{"10":1,"35":7,"45":1,"72":1,"73":1,"136":2,"196":4,"249":2}}],["24",{"2":{"8":1,"57":6,"141":1}}],["23",{"2":{"3":2,"20":2,"141":1}}],["2",{"2":{"1":4,"2":5,"3":1,"8":5,"10":2,"11":13,"12":8,"18":18,"19":10,"20":7,"21":9,"26":13,"27":9,"28":13,"29":8,"34":15,"35":4,"36":7,"37":23,"38":15,"43":15,"44":12,"45":1,"47":3,"48":4,"50":3,"51":16,"52":2,"53":4,"54":2,"55":2,"56":6,"57":8,"58":10,"62":2,"63":4,"64":6,"65":1,"66":1,"69":2,"79":1,"80":12,"81":3,"82":1,"83":12,"84":1,"89":2,"91":1,"94":4,"104":1,"105":1,"106":1,"107":1,"108":1,"112":4,"113":1,"117":2,"120":1,"132":2,"133":2,"136":1,"147":1,"151":1,"154":2,"156":1,"160":3,"162":5,"163":4,"164":4,"167":1,"173":1,"175":2,"176":1,"178":1,"179":1,"183":5,"190":1,"205":1,"207":1,"214":1,"216":1,"217":1,"218":1,"220":3,"224":9,"228":5,"230":2,"236":3,"238":1,"244":5,"249":2}}],["17",{"2":{"136":1,"163":2}}],["170",{"2":{"57":6}}],["19",{"2":{"136":1,"185":2}}],["198",{"2":{"28":1}}],["14",{"2":{"72":1,"73":1,"81":1,"163":3}}],["140",{"2":{"45":1}}],["13",{"2":{"66":4,"72":1,"73":1,"94":1,"141":9,"142":1}}],["135",{"2":{"38":1}}],["1~3",{"2":{"57":1}}],["15",{"2":{"35":1,"38":2,"66":2,"72":1,"73":1,"81":6,"84":1,"163":2,"196":4}}],["180°",{"2":{"234":1}}],["18",{"2":{"27":2,"72":1,"73":1,"81":1,"190":5,"196":4}}],["100",{"2":{"231":1}}],["1000000",{"2":{"249":2}}],["1000",{"2":{"45":1,"135":1}}],["10^2",{"2":{"136":1}}],["10^3",{"2":{"136":1}}],["10^9",{"2":{"18":2}}],["1011000",{"2":{"231":1}}],["101",{"2":{"27":3}}],["104",{"2":{"18":1}}],["10",{"2":{"8":1,"10":1,"11":1,"27":2,"29":3,"34":1,"35":19,"43":2,"44":3,"45":1,"57":5,"66":14,"72":1,"73":1,"79":2,"81":1,"94":1,"136":2,"139":1,"141":1,"196":2}}],["1其中",{"2":{"5":1}}],["165",{"2":{"185":1}}],["163",{"2":{"142":1}}],["169",{"2":{"18":1}}],["16",{"2":{"4":2,"143":1,"163":2}}],["123代码测试",{"2":{"180":1,"181":1,"182":1}}],["123",{"2":{"151":1,"157":1,"158":1,"175":2,"176":2,"177":1,"179":1,"180":1,"214":7,"231":1}}],["12345",{"2":{"178":4,"179":1,"180":1}}],["1234567",{"2":{"126":1,"127":1,"133":1,"153":1,"163":1}}],["123456789",{"2":{"162":1}}],["1234567891011",{"2":{"131":1}}],["123456789101112代码测试",{"2":{"174":1}}],["123456789101112",{"2":{"79":1,"219":1}}],["12345678910111213",{"2":{"71":1,"72":1,"73":1,"109":1,"110":1,"128":1}}],["1234567891011121314代码测试",{"2":{"176":1}}],["1234567891011121314",{"2":{"7":1}}],["123456789101112131415代码测试",{"2":{"177":1}}],["12345678910111213141516",{"2":{"172":1}}],["1234567891011121314151617代码测试",{"2":{"178":1}}],["1234567891011121314151617",{"2":{"155":1,"216":1}}],["12345678910111213141516171819",{"2":{"76":1,"230":1}}],["123456789101112131415161718192021",{"2":{"69":1,"104":1}}],["1234567891011121314151617181920212223这种表示法的优点在于每一个节点中引用的数量都是确定的",{"2":{"239":1}}],["1234567891011121314151617181920212223第二步",{"2":{"78":1}}],["1234567891011121314151617181920212223二分搜索的时间复杂度为",{"2":{"48":1}}],["1234567891011121314151617181920212223",{"2":{"27":1,"43":1}}],["123456789101112131415161718192021222324时间复杂度",{"2":{"55":1}}],["1234567891011121314151617181920212223242526",{"2":{"214":1}}],["123456789101112131415161718192021222324252627",{"2":{"190":1}}],["123456789101112131415161718192021222324252627时间复杂度",{"2":{"53":1}}],["12345678910111213141516171819202122232425262728",{"2":{"34":1,"37":1,"38":1,"80":1,"156":1}}],["1234567891011121314151617181920212223242526272829过程图解",{"2":{"173":1}}],["12345678910111213141516171819202122232425262728293031代码测试",{"2":{"179":1}}],["12345678910111213141516171819202122232425262728293031",{"2":{"132":1,"133":1}}],["12345678910111213141516171819202122232425262728293031时间复杂度",{"2":{"58":1}}],["1234567891011121314151617181920212223242526272829303132333435",{"2":{"77":1}}],["1234567891011121314151617181920212223242526272829303132333435时间复杂度",{"2":{"51":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940",{"2":{"213":1,"227":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142代码测试",{"2":{"175":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142",{"2":{"82":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243基本过程",{"2":{"54":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243",{"2":{"45":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748",{"2":{"189":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051",{"2":{"105":1,"106":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101",{"2":{"220":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124",{"2":{"164":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204",{"2":{"183":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190",{"2":{"112":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114",{"2":{"83":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879",{"2":{"195":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354",{"2":{"19":1,"20":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041424344454647堆排序",{"2":{"56":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546",{"2":{"18":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445",{"2":{"12":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041时间复杂度",{"2":{"57":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041",{"2":{"21":1,"107":1}}],["123456789101112131415161718192021222324252627282930313233343536373839",{"2":{"113":1,"204":1}}],["1234567891011121314151617181920212223242526272829303132333435363738",{"2":{"10":1}}],["12345678910111213141516171819202122232425262728293031323334353637",{"2":{"2":1,"9":1}}],["12345678910111213141516171819202122232425262728293031323334冒泡排序有几种可以优化的空间",{"2":{"50":1}}],["12345678910111213141516171819202122232425262728293031323334",{"2":{"35":1,"154":1,"207":1}}],["123456789101112131415161718192021222324252627282930313233",{"2":{"8":1,"196":1}}],["1234567891011121314151617181920212223242526272829",{"2":{"11":1}}],["12345678910111213141516171819202122232425时间复杂度",{"2":{"52":1}}],["12345678910111213141516171819202122232425",{"2":{"26":1,"36":1,"44":1,"205":1}}],["123456789101112131415161718192021222324",{"2":{"1":1,"28":1,"29":1}}],["1234567891011121314151617181920优化后的算法分析",{"2":{"28":1}}],["1234567891011121314151617181920",{"2":{"5":1,"129":1,"160":1,"228":1}}],["12345678910111213141516哈希函数测试",{"2":{"151":1}}],["123456789101112131415顺序搜索的时间复杂度为",{"2":{"47":1}}],["123456789101112131415",{"2":{"4":1,"12":1,"103":1,"217":1,"218":1}}],["1234567891011insertnode",{"2":{"69":1}}],["12345678910",{"2":{"1":1,"3":1,"60":2,"108":1,"162":1}}],["12345678",{"2":{"12":1,"67":1}}],["123456",{"2":{"124":1,"132":1,"173":1}}],["1234在",{"2":{"163":1}}],["1234",{"2":{"62":1,"63":1,"64":2,"160":2,"163":1,"175":1,"208":1}}],["12",{"2":{"4":4,"5":1,"28":4,"72":1,"73":1,"94":1,"151":1,"174":1,"181":1,"182":1}}],["1100100",{"2":{"231":1}}],["111111",{"2":{"113":2}}],["11",{"2":{"3":1,"29":3,"66":3,"72":1,"73":1,"80":4,"84":1,"94":1,"196":2}}],["1",{"2":{"1":4,"2":11,"3":2,"8":3,"9":1,"10":8,"11":13,"12":19,"18":18,"19":16,"20":19,"21":9,"26":22,"27":13,"28":28,"29":19,"34":21,"35":2,"36":13,"37":24,"38":30,"43":27,"44":14,"45":4,"47":5,"48":7,"50":11,"51":16,"52":12,"53":14,"54":6,"55":5,"56":9,"57":4,"58":13,"62":2,"63":2,"64":8,"65":1,"66":1,"69":2,"79":1,"80":12,"81":3,"82":1,"83":13,"89":6,"94":3,"101":1,"104":1,"105":1,"106":1,"107":5,"108":1,"112":8,"113":2,"117":12,"120":1,"121":4,"132":2,"133":2,"135":1,"136":3,"141":2,"142":1,"143":1,"144":2,"148":1,"151":1,"154":2,"155":1,"156":1,"159":1,"160":2,"162":6,"163":3,"164":6,"168":1,"170":1,"173":2,"175":2,"176":2,"177":4,"178":2,"179":2,"183":10,"185":1,"207":5,"216":1,"217":1,"218":1,"220":3,"224":9,"227":1,"228":3,"230":1,"236":2,"244":5,"249":2}}],["lucy",{"2":{"208":1}}],["list",{"2":{"245":1}}],["linked",{"2":{"245":1}}],["linkedlist",{"2":{"103":2,"112":1,"172":2,"173":6,"174":1,"175":3,"176":2,"177":2,"178":4,"179":2,"180":2,"181":1,"182":1,"183":1}}],["lifo",{"2":{"222":1}}],["lily",{"2":{"208":2}}],["limit",{"2":{"151":2,"153":1,"154":3,"155":1,"156":4,"160":6,"163":5,"164":10}}],["lrd",{"2":{"73":1}}],["ldr",{"2":{"72":1}}],["last",{"2":{"222":1}}],["lastindex",{"2":{"50":4}}],["laodfactor",{"2":{"160":2}}],["largest",{"2":{"56":9}}],["loadfactor",{"2":{"154":1,"159":2,"160":2,"163":1,"164":2}}],["low",{"2":{"48":4}}],["lomuto",{"2":{"21":1}}],["log10",{"2":{"57":1}}],["log^2",{"2":{"53":2}}],["log",{"2":{"1":2,"2":2,"3":2,"4":2,"5":1,"7":2,"8":1,"9":1,"10":6,"11":6,"12":4,"18":10,"19":3,"20":7,"21":3,"26":4,"27":3,"28":4,"29":5,"34":8,"35":2,"36":5,"37":6,"38":5,"43":3,"44":2,"45":3,"47":2,"48":3,"50":1,"51":1,"54":5,"55":8,"56":7,"62":1,"63":1,"64":2,"84":5,"113":12,"132":1,"133":1,"151":2,"173":1,"174":1,"175":1,"176":2,"177":2,"178":2,"179":1,"180":1,"181":1,"182":1,"190":8,"196":5,"205":6,"208":1,"214":7,"228":6,"231":2,"249":1}}],["lt",{"2":{"10":1,"18":4,"27":1,"43":4,"44":4,"45":6,"66":2,"69":1,"77":1,"160":1}}],["lcm",{"2":{"5":5}}],["level",{"2":{"236":1}}],["leaf",{"2":{"236":1}}],["len",{"2":{"156":2,"164":2}}],["length++",{"2":{"104":1,"105":1,"106":1,"112":2,"173":1,"175":1,"183":2}}],["lengthoflis",{"2":{"27":4}}],["length",{"2":{"2":2,"12":6,"18":2,"19":6,"20":1,"21":2,"27":3,"28":2,"34":2,"36":2,"37":1,"38":1,"43":4,"44":2,"45":5,"47":1,"48":1,"50":2,"51":4,"52":3,"53":4,"54":6,"55":3,"56":2,"57":3,"58":3,"101":1,"105":3,"106":3,"107":5,"112":8,"128":2,"129":1,"131":1,"132":1,"133":2,"148":1,"154":1,"156":1,"160":1,"164":2,"170":1,"172":1,"173":1,"175":2,"176":1,"178":1,"179":2,"181":1,"182":1,"183":10,"187":1,"189":1,"195":1,"203":1,"204":2,"212":1,"213":1,"220":1,"226":1,"227":3}}],["lemonadechange",{"2":{"35":3}}],["leetcode",{"2":{"18":1,"19":1,"20":1,"21":1,"26":1,"27":1,"28":1,"29":1,"34":1,"35":1,"36":1,"37":1,"38":1,"43":1,"44":1,"45":1}}],["leftchild",{"2":{"239":3}}],["leftcount",{"2":{"18":2}}],["leftlength",{"2":{"54":3}}],["leftarray",{"2":{"54":5}}],["leftsum",{"2":{"20":4}}],["leftmax",{"2":{"20":2}}],["leftmajority",{"2":{"18":5}}],["left",{"2":{"12":10,"18":9,"19":8,"20":8,"21":8,"51":3,"54":2,"55":4,"56":4,"67":2,"69":3,"71":1,"72":1,"73":1,"76":2,"77":2,"78":1,"79":3,"80":14,"82":5,"83":16}}],["let",{"2":{"1":1,"8":1,"9":2,"10":3,"11":1,"12":4,"18":2,"19":2,"20":5,"21":2,"26":1,"27":2,"28":4,"29":1,"34":3,"35":2,"36":2,"37":2,"38":2,"43":1,"44":1,"47":1,"48":2,"50":3,"51":3,"52":2,"53":3,"54":2,"55":1,"56":3,"57":4,"58":6,"76":2,"77":1,"78":2,"82":4,"83":7,"105":3,"106":3,"107":3,"109":2,"110":2,"112":10,"128":4,"129":3,"131":2,"132":7,"133":5,"151":2,"154":3,"156":1,"162":2,"164":4,"173":1,"174":2,"175":3,"176":2,"177":2,"178":2,"179":3,"183":15,"195":4,"204":2,"207":1,"216":3,"217":2,"218":2,"219":1,"220":8,"227":2,"230":1}}],["则扩容",{"2":{"154":1,"160":1,"163":1,"164":1}}],["则修改数据",{"2":{"154":1,"164":1}}],["则线性查找",{"2":{"141":1}}],["则余数的范围",{"2":{"139":1}}],["则它由根节点和称为其左子树",{"2":{"87":1}}],["则需要在",{"2":{"82":1}}],["则需要统计这两个元素在整个数组中的出现次数",{"2":{"18":1}}],["则合适的节点指的是",{"2":{"81":1}}],["则不需要删除",{"2":{"78":1}}],["则向左查找",{"2":{"77":1}}],["则满足以下性质",{"2":{"65":1}}],["则交换并继续堆化",{"2":{"56":1}}],["则交换它们的位置",{"2":{"50":1}}],["则交换它们",{"2":{"50":1}}],["则把剩余的元素全部加入到结果数组中",{"2":{"54":2}}],["则进行交换",{"2":{"53":1}}],["则数组已经有序",{"2":{"50":1}}],["则排序完成",{"2":{"50":1}}],["则递归处理剩余部分的字符串",{"2":{"45":2}}],["则递归调用",{"2":{"1":1}}],["则当前孩子的糖果数等于前一个孩子的糖果数加",{"2":{"38":1}}],["则只移动饼干的指针",{"2":{"34":1}}],["则表示无法凑成该金额",{"2":{"29":1}}],["则可以偷窃的最高金额是这两个房子中金额较大的那个",{"2":{"28":1}}],["则更新最大值",{"2":{"56":2}}],["则更新最小元素索引",{"2":{"51":1}}],["则更新当前孩子的糖果数为",{"2":{"38":3}}],["则更新",{"2":{"27":1}}],["则该元素即为整个数组的多数元素",{"2":{"18":1}}],["则直接返回原数组",{"2":{"50":1}}],["则直接求解",{"2":{"15":1}}],["则直接将元素加入到堆中",{"2":{"12":1}}],["则直接将元素添加到结果数组中",{"2":{"1":1}}],["则继续向后遍历",{"2":{"12":1}}],["则最小的",{"2":{"12":1}}],["则返回当前元素的索引",{"2":{"47":1}}],["则返回该元素",{"2":{"18":1}}],["则返回",{"2":{"4":1,"5":1,"35":2,"36":2,"47":1,"68":2,"101":1,"150":1,"170":1,"187":1}}],["则将当前元素添加到结果数组中",{"2":{"2":1}}],["函数中调用",{"2":{"223":1}}],["函数调用栈",{"2":{"223":1}}],["函数来实现",{"2":{"12":1}}],["函数的",{"2":{"8":1}}],["函数自身",{"2":{"8":1}}],["函数将传入的初始参数数组求和",{"2":{"8":1}}],["函数",{"2":{"1":1,"8":1,"36":1,"37":1,"38":1,"43":3,"44":3,"45":3,"223":2}}],["full",{"2":{"91":1}}],["function",{"2":{"1":2,"2":3,"4":1,"5":2,"8":4,"12":2,"18":2,"19":2,"20":2,"21":2,"43":1,"44":1,"45":1,"51":1,"54":1,"56":1,"57":4,"132":1,"133":1,"207":1}}],["front",{"2":{"195":4,"199":1,"203":1,"204":2,"205":2,"207":1}}],["from",{"2":{"57":1}}],["friday",{"2":{"60":4}}],["flag",{"2":{"50":3}}],["flattenarray",{"2":{"1":6}}],["floor",{"2":{"12":1,"18":1,"19":1,"20":1,"48":1,"56":1,"57":2,"156":1,"160":1,"163":1,"164":1,"230":1}}],["f",{"2":{"11":6,"71":1,"89":1,"94":2,"129":2,"132":1,"133":1,"147":1,"238":1,"239":1}}],["fifo",{"2":{"199":1}}],["first",{"2":{"131":2,"199":2,"222":1}}],["finish",{"2":{"37":3}}],["findcontentchildren",{"2":{"34":5}}],["findkthlargest",{"2":{"21":3}}],["findksmallestnumberswithmaxheap",{"2":{"12":2}}],["findksmallestnumbers",{"2":{"12":2}}],["findmostword",{"2":{"9":2}}],["five++",{"2":{"35":1}}],["five",{"2":{"35":8}}],["fill",{"2":{"26":1,"27":1,"28":1,"29":1,"38":1,"58":1}}],["fibonacci",{"2":{"10":7}}],["forwardtostring",{"0":{"109":1},"2":{"109":2,"112":2,"113":2}}],["forwardstring",{"2":{"101":1}}],["for",{"2":{"9":1,"10":1,"11":1,"12":3,"18":1,"20":2,"21":1,"26":1,"27":2,"28":2,"29":2,"35":1,"36":1,"37":1,"38":2,"43":1,"44":1,"45":2,"47":1,"50":1,"51":2,"52":1,"53":2,"55":1,"56":2,"57":3,"58":3,"128":2,"129":1,"131":1,"132":1,"133":2,"151":1,"154":1,"155":1,"156":1,"160":2,"162":2,"164":5,"195":2,"204":1,"207":2,"216":2,"217":1,"218":1,"219":1,"220":5,"227":1}}],["foreach",{"2":{"2":1,"9":1}}],["false",{"2":{"7":1,"35":11,"36":8,"50":2,"68":1,"77":3,"78":3,"80":2,"83":3,"101":1,"105":1,"106":1,"112":1,"150":1,"162":4,"170":1,"175":1,"178":1,"181":1,"183":2,"187":1,"189":2,"190":1,"195":1,"196":1,"203":1,"205":1,"212":1,"213":4,"214":1,"219":2,"220":6,"226":1,"228":1}}],["==",{"2":{"18":1,"45":1,"56":1,"76":2,"77":1,"78":1,"79":1,"80":7,"82":2,"83":3,"105":2,"106":2,"112":2,"173":1,"183":1}}],["===",{"2":{"2":1,"4":1,"5":1,"7":1,"10":2,"11":2,"12":4,"18":3,"20":1,"21":2,"27":1,"28":4,"29":1,"35":3,"37":1,"43":1,"45":2,"47":1,"48":1,"57":1,"69":3,"71":1,"72":1,"73":1,"77":1,"78":1,"79":3,"80":4,"82":1,"83":9,"104":1,"105":3,"106":3,"107":3,"112":7,"132":1,"133":2,"154":2,"155":2,"156":2,"157":1,"162":3,"164":7,"173":1,"175":1,"177":1,"179":1,"181":1,"183":5,"204":1,"227":1}}],["=>",{"2":{"9":1,"12":3,"34":2,"37":1,"38":1,"57":1}}],["=",{"2":{"1":2,"2":3,"3":1,"5":1,"7":2,"8":5,"9":8,"10":9,"11":7,"12":22,"18":14,"19":9,"20":16,"21":10,"26":12,"27":8,"28":25,"29":14,"34":8,"35":5,"36":5,"37":7,"38":8,"43":9,"44":8,"45":17,"47":1,"48":6,"50":8,"51":9,"52":7,"53":12,"54":10,"55":5,"56":11,"57":9,"58":10,"60":2,"62":1,"63":1,"64":2,"66":1,"67":3,"69":6,"71":1,"72":1,"73":1,"76":4,"77":3,"78":8,"79":8,"80":13,"82":13,"83":30,"89":4,"103":2,"104":6,"105":18,"106":18,"107":14,"108":1,"109":3,"110":3,"112":46,"113":1,"124":2,"128":4,"129":3,"131":3,"132":10,"133":8,"136":4,"143":2,"144":1,"148":1,"151":4,"153":3,"154":7,"155":2,"156":5,"160":6,"162":5,"163":3,"164":23,"172":5,"173":7,"174":3,"175":14,"176":3,"177":3,"178":4,"179":8,"183":45,"189":3,"190":1,"195":7,"196":1,"204":2,"205":1,"207":3,"208":2,"213":3,"214":1,"216":1,"217":1,"218":1,"220":6,"227":2,"230":3,"235":1,"239":9}}],["ir++",{"2":{"54":2}}],["ir",{"2":{"54":4}}],["il++",{"2":{"54":2}}],["il",{"2":{"54":4}}],["ii",{"0":{"45":1},"2":{"41":2}}],["i+1",{"2":{"38":1}}],["i++",{"2":{"10":1,"11":1,"12":3,"18":1,"19":2,"20":1,"21":1,"26":1,"27":1,"28":2,"29":1,"34":1,"36":1,"38":1,"43":1,"44":1,"47":1,"51":1,"52":1,"53":1,"55":1,"57":2,"58":3,"128":1,"129":1,"131":1,"132":1,"133":2,"154":1,"156":1,"162":2,"164":2,"195":1,"207":1}}],["i",{"2":{"10":2,"11":5,"12":13,"18":4,"19":6,"20":7,"21":6,"26":13,"27":14,"28":18,"29":14,"34":7,"35":2,"36":10,"37":1,"38":16,"43":6,"44":6,"45":2,"47":4,"51":5,"52":4,"53":4,"55":5,"56":17,"57":7,"58":14,"71":1,"89":4,"94":1,"128":4,"129":5,"131":3,"132":4,"133":8,"154":3,"156":4,"162":6,"164":7,"190":4,"195":4,"207":2,"236":1}}],["intersectionset",{"2":{"217":3,"220":3}}],["intersection",{"2":{"217":2,"220":2}}],["intervals",{"2":{"37":9}}],["initializecolor",{"2":{"131":1,"132":1,"133":1}}],["inordertraversalnode",{"2":{"72":4}}],["inordertraversal",{"2":{"72":1}}],["inordertraverse",{"2":{"68":1}}],["index++",{"2":{"175":1,"176":1,"177":1,"178":1,"179":1,"183":5}}],["index+1",{"2":{"141":1}}],["index=4",{"2":{"141":1}}],["index=3",{"2":{"141":3}}],["index",{"2":{"62":1,"64":2,"141":1,"148":1,"154":6,"155":3,"156":3,"159":1,"164":9,"175":2,"176":1,"177":3,"178":1,"179":1,"183":8}}],["indexof",{"0":{"6":1,"177":1},"2":{"2":1,"46":1,"101":1,"112":3,"113":2,"170":1,"177":4,"180":1,"183":3,"207":1}}],["insertnode",{"2":{"69":9}}],["insert",{"0":{"105":1,"106":1,"175":1},"2":{"68":1,"69":3,"101":1,"105":3,"106":3,"108":1,"112":4,"113":3,"170":1,"175":5,"183":2}}],["insertsort",{"2":{"52":2}}],["insertion",{"2":{"52":1}}],["infinity",{"2":{"20":2,"29":6,"37":1}}],["input",{"2":{"10":2}}],["invalid",{"2":{"10":2}}],["in",{"2":{"9":1,"199":1,"222":1}}],["isprime",{"2":{"162":2,"163":3,"164":1}}],["ispalindrome",{"2":{"7":3}}],["isempty",{"0":{"157":1,"181":1},"2":{"101":1,"112":3,"132":1,"150":1,"164":1,"170":1,"181":3,"183":2,"195":5,"196":2,"203":1,"204":2,"205":2,"226":1,"227":2,"228":2,"230":1}}],["isleftchild",{"2":{"78":5,"79":1,"80":6,"82":1,"83":8}}],["is",{"2":{"9":2}}],["isarray",{"2":{"1":2,"2":2,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1}}],["items",{"2":{"189":8,"190":1,"195":6,"196":2,"204":7,"205":2,"213":7,"214":2,"220":7,"227":8,"228":1}}],["item",{"2":{"1":5,"2":3,"8":4,"62":3,"64":2,"100":1,"151":2,"195":3,"204":5,"227":5}}],["if",{"2":{"1":2,"2":3,"4":1,"5":1,"9":2,"10":3,"11":3,"12":7,"18":3,"19":2,"20":3,"21":4,"26":1,"27":2,"28":4,"29":1,"34":1,"35":5,"36":2,"37":2,"38":2,"43":1,"45":3,"47":1,"48":2,"50":3,"51":2,"52":1,"53":1,"54":2,"55":2,"56":4,"57":1,"58":2,"69":4,"71":1,"72":1,"73":1,"76":2,"77":5,"78":2,"79":3,"80":6,"82":3,"83":14,"104":1,"105":4,"106":4,"107":4,"112":9,"132":2,"133":3,"154":3,"155":2,"156":3,"160":3,"162":4,"163":2,"164":9,"173":1,"175":2,"176":1,"177":1,"178":1,"179":2,"183":8,"189":1,"195":3,"213":2,"217":1,"218":1,"219":1,"220":5}}],["兼容性好",{"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
