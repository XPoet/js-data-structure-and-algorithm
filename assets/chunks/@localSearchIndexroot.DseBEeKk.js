const t='{"documentCount":238,"nextId":238,"documentIds":{"0":"/algorithm/classic.html#经典算法题","1":"/algorithm/classic.html#数组扁平化","2":"/algorithm/classic.html#数组去重","3":"/algorithm/classic.html#求数组的最大值和最小值","4":"/algorithm/classic.html#求两个数的最大公约数","5":"/algorithm/classic.html#求两个数的最小公倍数","6":"/algorithm/classic.html#实现-indexof-方法","7":"/algorithm/classic.html#判断一个字符串是否为回文字符串","8":"/algorithm/classic.html#实现一个累加函数的功能","9":"/algorithm/classic.html#如何查找一篇英文文章中出现频率最高的单词","10":"/algorithm/classic.html#二维数组中的查找","11":"/algorithm/classic.html#斐波那契数列","12":"/algorithm/classic.html#跳台阶","13":"/algorithm/classic.html#动态规划","14":"/algorithm/classic.html#递归方法分析","15":"/algorithm/classic.html#备忘录方法","16":"/algorithm/classic.html#迭代法","17":"/algorithm/classic.html#最小的-k-个数","18":"/algorithm/idea.html#算法设计思想","19":"/algorithm/idea.html#分而治之","20":"/algorithm/idea.html#猜数字大小-二分搜索","21":"/algorithm/idea.html#翻转二叉树","22":"/algorithm/idea.html#相同的树","23":"/algorithm/idea.html#对称二叉树","24":"/algorithm/idea.html#动态规划","25":"/algorithm/idea.html#爬楼梯问题","26":"/algorithm/idea.html#打家劫舍","27":"/algorithm/idea.html#贪心算法","28":"/algorithm/idea.html#分发饼干","29":"/algorithm/idea.html#买卖股票的最佳时机","30":"/algorithm/idea.html#回溯算法","31":"/algorithm/idea.html#全排列","32":"/algorithm/idea.html#子集问题","33":"/algorithm/search.html#搜索","34":"/algorithm/search.html#顺序搜索","35":"/algorithm/search.html#二分搜索","36":"/algorithm/sort.html#排序","37":"/algorithm/sort.html#冒泡排序","38":"/algorithm/sort.html#选择排序","39":"/algorithm/sort.html#插入排序","40":"/algorithm/sort.html#希尔排序","41":"/algorithm/sort.html#归并排序","42":"/algorithm/sort.html#快速排序","43":"/algorithm/sort.html#堆排序","44":"/algorithm/sort.html#基数排序","45":"/algorithm/sort.html#计数排序","46":"/algorithm/sort.html#系统自带排序实现","47":"/data-structure/Array.html#数组","48":"/data-structure/Array.html#创建和初始化数组","49":"/data-structure/Array.html#数组常见操作","50":"/data-structure/Array.html#添加元素","51":"/data-structure/Array.html#删除元素","52":"/data-structure/Array.html#修改元素","53":"/data-structure/BinaryTree.html#二叉树","54":"/data-structure/BinaryTree.html#二叉树的概念","55":"/data-structure/BinaryTree.html#二叉树的组成","56":"/data-structure/BinaryTree.html#二叉树的五种形态","57":"/data-structure/BinaryTree.html#二叉树的特性","58":"/data-structure/BinaryTree.html#特殊的二叉树","59":"/data-structure/BinaryTree.html#完美二叉树","60":"/data-structure/BinaryTree.html#完全二叉树","61":"/data-structure/BinaryTree.html#二叉树的数据存储","62":"/data-structure/BinaryTree.html#使用数组","63":"/data-structure/BinaryTree.html#使用链表","64":"/data-structure/BinarySearchTree.html#二叉搜索树","65":"/data-structure/BinarySearchTree.html#二叉搜索树应用举例","66":"/data-structure/BinarySearchTree.html#二叉搜索树的封装","67":"/data-structure/BinarySearchTree.html#二叉搜索树的常见操作","68":"/data-structure/BinarySearchTree.html#插入数据","69":"/data-structure/BinarySearchTree.html#遍历数据","70":"/data-structure/BinarySearchTree.html#先序遍历","71":"/data-structure/BinarySearchTree.html#中序遍历","72":"/data-structure/BinarySearchTree.html#后序遍历","73":"/data-structure/BinarySearchTree.html#总结","74":"/data-structure/BinarySearchTree.html#查找数据","75":"/data-structure/BinarySearchTree.html#查找最大值或最小值","76":"/data-structure/BinarySearchTree.html#查找特定值","77":"/data-structure/BinarySearchTree.html#删除数据","78":"/data-structure/BinarySearchTree.html#删除的是叶子节点","79":"/data-structure/BinarySearchTree.html#删除的是只有一个子节点的节点","80":"/data-structure/BinarySearchTree.html#删除的是有两个子节点的节点","81":"/data-structure/BinarySearchTree.html#前驱-后继","82":"/data-structure/BinarySearchTree.html#完整实现","83":"/data-structure/BinarySearchTree.html#平衡树","84":"/data-structure/DoubleLinkedList.html#双向链表","85":"/data-structure/DoubleLinkedList.html#单向链表和双向链表","86":"/data-structure/DoubleLinkedList.html#单向链表","87":"/data-structure/DoubleLinkedList.html#双向链表-1","88":"/data-structure/DoubleLinkedList.html#双向链表结构","89":"/data-structure/DoubleLinkedList.html#双向链表常见的操作","90":"/data-structure/DoubleLinkedList.html#双向链表的封装","91":"/data-structure/DoubleLinkedList.html#创建双向链表类-doublylinkedlist","92":"/data-structure/DoubleLinkedList.html#append-element","93":"/data-structure/DoubleLinkedList.html#insert-position-element","94":"/data-structure/DoubleLinkedList.html#insert-position-element-1","95":"/data-structure/DoubleLinkedList.html#removeat-position","96":"/data-structure/DoubleLinkedList.html#update-position-data","97":"/data-structure/DoubleLinkedList.html#forwardtostring","98":"/data-structure/DoubleLinkedList.html#backwardstring","99":"/data-structure/DoubleLinkedList.html#其他方法的实现","100":"/data-structure/DoubleLinkedList.html#完整实现","101":"/data-structure/DoubleLinkedList.html#代码测试","102":"/data-structure/Graph.html#图","103":"/data-structure/Graph.html#图的概念","104":"/data-structure/Graph.html#什么是图","105":"/data-structure/Graph.html#图的术语","106":"/data-structure/Graph.html#现实建模","107":"/data-structure/Graph.html#图的表示","108":"/data-structure/Graph.html#顶点表示","109":"/data-structure/Graph.html#邻接矩阵","110":"/data-structure/Graph.html#邻接表","111":"/data-structure/Graph.html#图的封装","112":"/data-structure/Graph.html#创建图类","113":"/data-structure/Graph.html#方法","114":"/data-structure/Graph.html#添加顶点","115":"/data-structure/Graph.html#添加边","116":"/data-structure/Graph.html#tostring-方法","117":"/data-structure/Graph.html#测试代码","118":"/data-structure/Graph.html#图的遍历","119":"/data-structure/Graph.html#遍历的方式","120":"/data-structure/Graph.html#广度优先搜索-bfs","121":"/data-structure/Graph.html#深度优先搜索-dfs","122":"/data-structure/LinkedList.html#单向链表","123":"/data-structure/LinkedList.html#链表和数组","124":"/data-structure/LinkedList.html#数组","125":"/data-structure/LinkedList.html#链表","126":"/data-structure/LinkedList.html#单向链表-1","127":"/data-structure/LinkedList.html#链表中的常见操作","128":"/data-structure/LinkedList.html#单向链表的封装","129":"/data-structure/LinkedList.html#创建单向链表类","130":"/data-structure/LinkedList.html#实现-append-方法","131":"/data-structure/LinkedList.html#实现-tostring-方法","132":"/data-structure/LinkedList.html#实现-insert-方法","133":"/data-structure/LinkedList.html#实现-getdata-方法","134":"/data-structure/LinkedList.html#实现-indexof-方法","135":"/data-structure/LinkedList.html#实现-update-方法","136":"/data-structure/LinkedList.html#实现-removeat-方法","137":"/data-structure/LinkedList.html#实现-remove-方法","138":"/data-structure/LinkedList.html#实现-isempty-方法","139":"/data-structure/LinkedList.html#实现-size-方法","140":"/data-structure/LinkedList.html#完整实现","141":"/data-structure/HashTable.html#哈希表","142":"/data-structure/HashTable.html#认识哈希表","143":"/data-structure/HashTable.html#认识哈希化","144":"/data-structure/HashTable.html#哈希表的一些概念","145":"/data-structure/HashTable.html#地址的冲突","146":"/data-structure/HashTable.html#链地址法-拉链法","147":"/data-structure/HashTable.html#开放地址法","148":"/data-structure/HashTable.html#线性探测","149":"/data-structure/HashTable.html#二次探测","150":"/data-structure/HashTable.html#再哈希法","151":"/data-structure/HashTable.html#装填因子","152":"/data-structure/HashTable.html#不同探测方式性能的比较","153":"/data-structure/HashTable.html#哈希函数","154":"/data-structure/HashTable.html#快速计算","155":"/data-structure/HashTable.html#均匀分布","156":"/data-structure/HashTable.html#封装哈希表","157":"/data-structure/HashTable.html#哈希表常见操作","158":"/data-structure/HashTable.html#哈希函数的简单实现","159":"/data-structure/HashTable.html#哈希表的实现","160":"/data-structure/HashTable.html#创建哈希表类","161":"/data-structure/HashTable.html#put-key-value","162":"/data-structure/HashTable.html#get-key","163":"/data-structure/HashTable.html#remove-key","164":"/data-structure/HashTable.html#isempty","165":"/data-structure/HashTable.html#size","166":"/data-structure/HashTable.html#哈希表的扩容与压缩","167":"/data-structure/HashTable.html#resize-的实现","168":"/data-structure/HashTable.html#选择质数作为哈希表容量","169":"/data-structure/HashTable.html#质数判断","170":"/data-structure/HashTable.html#实现扩容或压缩后的哈希表容量为质数","171":"/data-structure/HashTable.html#哈希表完整实现","172":"/data-structure/PriorityQueue.html#优先队列","173":"/data-structure/PriorityQueue.html#场景","174":"/data-structure/PriorityQueue.html#优先队列-1","175":"/data-structure/PriorityQueue.html#优先队列的实现","176":"/data-structure/PriorityQueue.html#代码实现","177":"/data-structure/PriorityQueue.html#测试代码","178":"/data-structure/PriorityQueue.html#数组、栈和队列图解","179":"/data-structure/Map.html#字典","180":"/data-structure/Map.html#字典特点","181":"/data-structure/Map.html#字典和映射的关系","182":"/data-structure/Map.html#字典常见的操作","183":"/data-structure/Map.html#字典封装","184":"/data-structure/Map.html#代码实现","185":"/data-structure/Map.html#代码测试","186":"/data-structure/Queue.html#队列","187":"/data-structure/Queue.html#认识队列","188":"/data-structure/Queue.html#队列图解","189":"/data-structure/Queue.html#队列在程序中的应用","190":"/data-structure/Queue.html#队列的实现","191":"/data-structure/Queue.html#队列常见的操作","192":"/data-structure/Queue.html#代码实现","193":"/data-structure/Queue.html#测试代码","194":"/data-structure/Queue.html#队列的应用","195":"/data-structure/Queue.html#代码实现-1","196":"/data-structure/Queue.html#测试代码-1","197":"/data-structure/Set.html#集合","198":"/data-structure/Set.html#集合特点","199":"/data-structure/Set.html#封装集合","200":"/data-structure/Set.html#集合常见的操作","201":"/data-structure/Set.html#代码实现","202":"/data-structure/Set.html#代码测试","203":"/data-structure/Set.html#集合间的操作","204":"/data-structure/Set.html#并集的实现","205":"/data-structure/Set.html#交集的实现","206":"/data-structure/Set.html#差集的实现","207":"/data-structure/Set.html#子集的实现","208":"/data-structure/Set.html#集合的完整实现","209":"/data-structure/Stack.html#栈","210":"/data-structure/Stack.html#什么是栈","211":"/data-structure/Stack.html#程序中的栈结构","212":"/data-structure/Stack.html#练习","213":"/data-structure/Stack.html#栈结构实现","214":"/data-structure/Stack.html#栈常见的操作","215":"/data-structure/Stack.html#javascript-代码实现栈结构","216":"/data-structure/Stack.html#测试封装的栈结构","217":"/data-structure/Stack.html#栈结构的简单应用","218":"/data-structure/Stack.html#代码实现","219":"/data-structure/Stack.html#测试","220":"/data-structure/Tree.html#树","221":"/data-structure/Tree.html#真实的树","222":"/data-structure/Tree.html#树的特点","223":"/data-structure/Tree.html#树结构的优势","224":"/data-structure/Tree.html#树的常用术语","225":"/data-structure/Tree.html#树结构的表示方式","226":"/data-structure/Tree.html#最普通的表示方法","227":"/data-structure/Tree.html#儿子-兄弟表示法","228":"/data-structure/Tree.html#儿子-兄弟表示法旋转","229":"/foreword.html#前言","230":"/foreword.html#什么是数据结构","231":"/foreword.html#数据结构的定义","232":"/foreword.html#数据结构在生活中应用","233":"/foreword.html#常见的数据结构","234":"/foreword.html#什么是算法","235":"/foreword.html#算法-algorithm-的定义","236":"/foreword.html#算法通俗理解","237":"/foreword.html#算法案例"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,41],"2":[1,1,32],"3":[1,1,19],"4":[1,1,23],"5":[1,1,43],"6":[3,1,26],"7":[1,1,24],"8":[1,1,23],"9":[1,1,36],"10":[1,1,74],"11":[1,1,57],"12":[1,1,59],"13":[1,1,12],"14":[1,2,40],"15":[1,2,38],"16":[1,2,31],"17":[3,1,125],"18":[1,1,1],"19":[1,1,18],"20":[3,2,62],"21":[1,2,30],"22":[1,2,53],"23":[1,2,57],"24":[1,1,16],"25":[1,2,57],"26":[1,2,61],"27":[1,1,5],"28":[1,2,66],"29":[1,2,63],"30":[1,1,13],"31":[1,2,47],"32":[1,2,54],"33":[1,1,7],"34":[1,1,27],"35":[1,1,44],"36":[1,1,7],"37":[1,1,65],"38":[1,1,68],"39":[1,1,65],"40":[1,1,85],"41":[1,1,82],"42":[1,1,115],"43":[1,1,98],"44":[1,1,73],"45":[1,1,68],"46":[1,1,17],"47":[1,1,8],"48":[1,1,16],"49":[1,1,1],"50":[1,2,28],"51":[1,2,25],"52":[1,2,30],"53":[1,1,1],"54":[1,1,3],"55":[1,1,9],"56":[1,1,15],"57":[1,1,41],"58":[1,1,1],"59":[1,2,13],"60":[1,2,16],"61":[1,1,2],"62":[1,2,38],"63":[1,2,6],"64":[1,1,35],"65":[1,1,42],"66":[1,1,26],"67":[1,1,24],"68":[1,2,65],"69":[1,2,11],"70":[1,3,42],"71":[1,3,52],"72":[1,3,52],"73":[1,3,10],"74":[1,2,1],"75":[1,3,27],"76":[1,3,44],"77":[1,2,52],"78":[1,3,38],"79":[1,3,50],"80":[1,3,44],"81":[3,4,68],"82":[1,3,60],"83":[1,1,59],"84":[1,1,1],"85":[1,1,1],"86":[1,2,10],"87":[1,2,17],"88":[1,1,18],"89":[1,1,45],"90":[1,1,1],"91":[2,2,27],"92":[3,2,29],"93":[4,2,59],"94":[4,2,59],"95":[3,2,42],"96":[4,2,21],"97":[2,2,21],"98":[2,2,21],"99":[1,2,2],"100":[1,2,104],"101":[1,2,31],"102":[1,1,1],"103":[1,1,5],"104":[2,2,41],"105":[1,2,84],"106":[1,2,14],"107":[1,1,6],"108":[1,2,27],"109":[1,2,42],"110":[1,2,36],"111":[1,1,1],"112":[1,2,25],"113":[1,2,1],"114":[1,3,22],"115":[1,3,25],"116":[2,3,28],"117":[1,2,29],"118":[1,1,6],"119":[1,2,59],"120":[3,2,99],"121":[3,2,79],"122":[1,1,1],"123":[1,1,4],"124":[1,2,21],"125":[1,2,28],"126":[1,1,16],"127":[1,1,41],"128":[1,1,1],"129":[1,2,24],"130":[3,2,66],"131":[3,2,32],"132":[3,2,79],"133":[3,2,42],"134":[3,2,34],"135":[3,2,49],"136":[3,2,56],"137":[3,2,24],"138":[3,2,20],"139":[3,2,18],"140":[1,2,134],"141":[1,1,1],"142":[1,1,68],"143":[1,2,79],"144":[1,2,11],"145":[1,2,10],"146":[3,3,21],"147":[1,3,7],"148":[1,4,82],"149":[1,4,37],"150":[1,4,48],"151":[1,3,12],"152":[1,3,28],"153":[1,2,7],"154":[1,3,28],"155":[1,3,34],"156":[1,1,1],"157":[1,2,21],"158":[1,2,47],"159":[1,2,1],"160":[1,3,20],"161":[4,3,88],"162":[3,3,50],"163":[3,3,66],"164":[2,3,8],"165":[2,3,6],"166":[1,1,49],"167":[2,2,72],"168":[1,2,1],"169":[1,3,43],"170":[1,3,67],"171":[1,1,111],"172":[1,1,1],"173":[1,1,11],"174":[1,1,6],"175":[1,1,1],"176":[1,2,76],"177":[1,2,35],"178":[2,1,1],"179":[1,1,1],"180":[1,1,26],"181":[1,1,16],"182":[1,1,26],"183":[1,1,1],"184":[1,2,39],"185":[1,2,31],"186":[1,1,1],"187":[1,1,27],"188":[1,2,1],"189":[1,2,10],"190":[1,1,5],"191":[1,2,36],"192":[1,2,36],"193":[1,2,24],"194":[1,1,10],"195":[1,2,63],"196":[1,2,19],"197":[1,1,9],"198":[1,1,10],"199":[1,1,8],"200":[1,2,24],"201":[1,2,38],"202":[1,2,25],"203":[1,1,10],"204":[1,2,29],"205":[1,2,26],"206":[1,2,27],"207":[1,2,23],"208":[1,1,72],"209":[1,1,7],"210":[1,1,28],"211":[1,1,35],"212":[1,1,39],"213":[1,1,1],"214":[1,2,23],"215":[2,2,37],"216":[1,2,19],"217":[1,1,2],"218":[1,2,37],"219":[1,2,12],"220":[1,1,1],"221":[1,1,1],"222":[1,1,11],"223":[1,1,68],"224":[1,1,65],"225":[1,1,1],"226":[1,2,25],"227":[2,2,21],"228":[2,2,14],"229":[1,1,1],"230":[1,1,1],"231":[1,2,24],"232":[1,2,44],"233":[1,2,20],"234":[1,1,1],"235":[3,2,7],"236":[1,2,6],"237":[1,2,43]},"averageFieldLength":[1.2857142857142863,1.7142857142857142,31.655462184873958],"storedFields":{"0":{"title":"经典算法题","titles":[]},"1":{"title":"数组扁平化","titles":["经典算法题"]},"2":{"title":"数组去重","titles":["经典算法题"]},"3":{"title":"求数组的最大值和最小值","titles":["经典算法题"]},"4":{"title":"求两个数的最大公约数","titles":["经典算法题"]},"5":{"title":"求两个数的最小公倍数","titles":["经典算法题"]},"6":{"title":"实现 IndexOf 方法","titles":["经典算法题"]},"7":{"title":"判断一个字符串是否为回文字符串","titles":["经典算法题"]},"8":{"title":"实现一个累加函数的功能","titles":["经典算法题"]},"9":{"title":"如何查找一篇英文文章中出现频率最高的单词","titles":["经典算法题"]},"10":{"title":"二维数组中的查找","titles":["经典算法题"]},"11":{"title":"斐波那契数列","titles":["经典算法题"]},"12":{"title":"跳台阶","titles":["经典算法题"]},"13":{"title":"动态规划","titles":["经典算法题"]},"14":{"title":"递归方法分析","titles":["经典算法题","动态规划"]},"15":{"title":"备忘录方法","titles":["经典算法题","动态规划"]},"16":{"title":"迭代法","titles":["经典算法题","动态规划"]},"17":{"title":"最小的 K 个数","titles":["经典算法题"]},"18":{"title":"算法设计思想","titles":[]},"19":{"title":"分而治之","titles":["算法设计思想"]},"20":{"title":"猜数字大小 (二分搜索)","titles":["算法设计思想","分而治之"]},"21":{"title":"翻转二叉树","titles":["算法设计思想","分而治之"]},"22":{"title":"相同的树","titles":["算法设计思想","分而治之"]},"23":{"title":"对称二叉树","titles":["算法设计思想","分而治之"]},"24":{"title":"动态规划","titles":["算法设计思想"]},"25":{"title":"爬楼梯问题","titles":["算法设计思想","动态规划"]},"26":{"title":"打家劫舍","titles":["算法设计思想","动态规划"]},"27":{"title":"贪心算法","titles":["算法设计思想"]},"28":{"title":"分发饼干","titles":["算法设计思想","贪心算法"]},"29":{"title":"买卖股票的最佳时机","titles":["算法设计思想","贪心算法"]},"30":{"title":"回溯算法","titles":["算法设计思想"]},"31":{"title":"全排列","titles":["算法设计思想","回溯算法"]},"32":{"title":"子集问题","titles":["算法设计思想","回溯算法"]},"33":{"title":"搜索","titles":[]},"34":{"title":"顺序搜索","titles":["搜索"]},"35":{"title":"二分搜索","titles":["搜索"]},"36":{"title":"排序","titles":[]},"37":{"title":"冒泡排序","titles":["排序"]},"38":{"title":"选择排序","titles":["排序"]},"39":{"title":"插入排序","titles":["排序"]},"40":{"title":"希尔排序","titles":["排序"]},"41":{"title":"归并排序","titles":["排序"]},"42":{"title":"快速排序","titles":["排序"]},"43":{"title":"堆排序","titles":["排序"]},"44":{"title":"基数排序","titles":["排序"]},"45":{"title":"计数排序","titles":["排序"]},"46":{"title":"系统自带排序实现","titles":["排序"]},"47":{"title":"数组","titles":[]},"48":{"title":"创建和初始化数组","titles":["数组"]},"49":{"title":"数组常见操作","titles":["数组"]},"50":{"title":"添加元素","titles":["数组","数组常见操作"]},"51":{"title":"删除元素","titles":["数组","数组常见操作"]},"52":{"title":"修改元素","titles":["数组","数组常见操作"]},"53":{"title":"二叉树","titles":[]},"54":{"title":"二叉树的概念","titles":["二叉树"]},"55":{"title":"二叉树的组成","titles":["二叉树"]},"56":{"title":"二叉树的五种形态","titles":["二叉树"]},"57":{"title":"二叉树的特性","titles":["二叉树"]},"58":{"title":"特殊的二叉树","titles":["二叉树"]},"59":{"title":"完美二叉树","titles":["二叉树","特殊的二叉树"]},"60":{"title":"完全二叉树","titles":["二叉树","特殊的二叉树"]},"61":{"title":"二叉树的数据存储","titles":["二叉树"]},"62":{"title":"使用数组","titles":["二叉树","二叉树的数据存储"]},"63":{"title":"使用链表","titles":["二叉树","二叉树的数据存储"]},"64":{"title":"二叉搜索树","titles":[]},"65":{"title":"二叉搜索树应用举例","titles":["二叉搜索树"]},"66":{"title":"二叉搜索树的封装","titles":["二叉搜索树"]},"67":{"title":"二叉搜索树的常见操作","titles":["二叉搜索树"]},"68":{"title":"插入数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"69":{"title":"遍历数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"70":{"title":"先序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"71":{"title":"中序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"72":{"title":"后序遍历","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"73":{"title":"总结","titles":["二叉搜索树","二叉搜索树的常见操作","遍历数据"]},"74":{"title":"查找数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"75":{"title":"查找最大值或最小值","titles":["二叉搜索树","二叉搜索树的常见操作","查找数据"]},"76":{"title":"查找特定值","titles":["二叉搜索树","二叉搜索树的常见操作","查找数据"]},"77":{"title":"删除数据","titles":["二叉搜索树","二叉搜索树的常见操作"]},"78":{"title":"删除的是叶子节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"79":{"title":"删除的是只有一个子节点的节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"80":{"title":"删除的是有两个子节点的节点","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"81":{"title":"前驱&amp;后继","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据","删除的是有两个子节点的节点"]},"82":{"title":"完整实现","titles":["二叉搜索树","二叉搜索树的常见操作","删除数据"]},"83":{"title":"平衡树","titles":[]},"84":{"title":"双向链表","titles":[]},"85":{"title":"单向链表和双向链表","titles":["双向链表"]},"86":{"title":"单向链表","titles":["双向链表","单向链表和双向链表"]},"87":{"title":"双向链表","titles":["双向链表","单向链表和双向链表"]},"88":{"title":"双向链表结构","titles":["双向链表"]},"89":{"title":"双向链表常见的操作","titles":["双向链表"]},"90":{"title":"双向链表的封装","titles":["双向链表"]},"91":{"title":"创建双向链表类 DoublyLinkedList","titles":["双向链表","双向链表的封装"]},"92":{"title":"append(element)","titles":["双向链表","双向链表的封装"]},"93":{"title":"insert(position, element)","titles":["双向链表","双向链表的封装"]},"94":{"title":"insert(position, element)","titles":["双向链表","双向链表的封装"]},"95":{"title":"removeAt(position)","titles":["双向链表","双向链表的封装"]},"96":{"title":"update(position, data)","titles":["双向链表","双向链表的封装"]},"97":{"title":"forwardToString()","titles":["双向链表","双向链表的封装"]},"98":{"title":"backwardString()","titles":["双向链表","双向链表的封装"]},"99":{"title":"其他方法的实现","titles":["双向链表","双向链表的封装"]},"100":{"title":"完整实现","titles":["双向链表","双向链表的封装"]},"101":{"title":"代码测试","titles":["双向链表","双向链表的封装"]},"102":{"title":"图","titles":[]},"103":{"title":"图的概念","titles":["图"]},"104":{"title":"什么是图？","titles":["图","图的概念"]},"105":{"title":"图的术语","titles":["图","图的概念"]},"106":{"title":"现实建模","titles":["图","图的概念"]},"107":{"title":"图的表示","titles":["图"]},"108":{"title":"顶点表示","titles":["图","图的表示"]},"109":{"title":"邻接矩阵","titles":["图","图的表示"]},"110":{"title":"邻接表","titles":["图","图的表示"]},"111":{"title":"图的封装","titles":["图"]},"112":{"title":"创建图类","titles":["图","图的封装"]},"113":{"title":"方法","titles":["图","图的封装"]},"114":{"title":"添加顶点","titles":["图","图的封装","方法"]},"115":{"title":"添加边","titles":["图","图的封装","方法"]},"116":{"title":"toString 方法","titles":["图","图的封装","方法"]},"117":{"title":"测试代码","titles":["图","图的封装"]},"118":{"title":"图的遍历","titles":["图"]},"119":{"title":"遍历的方式","titles":["图","图的遍历"]},"120":{"title":"广度优先搜索 (BFS)","titles":["图","图的遍历"]},"121":{"title":"深度优先搜索 (DFS)","titles":["图","图的遍历"]},"122":{"title":"单向链表","titles":[]},"123":{"title":"链表和数组","titles":["单向链表"]},"124":{"title":"数组","titles":["单向链表","链表和数组"]},"125":{"title":"链表","titles":["单向链表","链表和数组"]},"126":{"title":"单向链表","titles":["单向链表"]},"127":{"title":"链表中的常见操作","titles":["单向链表","单向链表"]},"128":{"title":"单向链表的封装","titles":["单向链表","单向链表"]},"129":{"title":"创建单向链表类","titles":["单向链表","单向链表","单向链表的封装"]},"130":{"title":"实现 append() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"131":{"title":"实现 toString() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"132":{"title":"实现 insert() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"133":{"title":"实现 getData() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"134":{"title":"实现 indexOf() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"135":{"title":"实现 update() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"136":{"title":"实现 removeAt() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"137":{"title":"实现 remove() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"138":{"title":"实现 isEmpty() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"139":{"title":"实现 size() 方法","titles":["单向链表","单向链表","单向链表的封装"]},"140":{"title":"完整实现","titles":["单向链表","单向链表","单向链表的封装"]},"141":{"title":"哈希表","titles":[]},"142":{"title":"认识哈希表","titles":["哈希表"]},"143":{"title":"认识哈希化","titles":["哈希表","认识哈希表"]},"144":{"title":"哈希表的一些概念","titles":["哈希表","认识哈希表"]},"145":{"title":"地址的冲突","titles":["哈希表","认识哈希表"]},"146":{"title":"链地址法（拉链法）","titles":["哈希表","认识哈希表","地址的冲突"]},"147":{"title":"开放地址法","titles":["哈希表","认识哈希表","地址的冲突"]},"148":{"title":"线性探测","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"149":{"title":"二次探测","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"150":{"title":"再哈希法","titles":["哈希表","认识哈希表","地址的冲突","开放地址法"]},"151":{"title":"装填因子","titles":["哈希表","认识哈希表","地址的冲突"]},"152":{"title":"不同探测方式性能的比较","titles":["哈希表","认识哈希表","地址的冲突"]},"153":{"title":"哈希函数","titles":["哈希表","认识哈希表"]},"154":{"title":"快速计算","titles":["哈希表","认识哈希表","哈希函数"]},"155":{"title":"均匀分布","titles":["哈希表","认识哈希表","哈希函数"]},"156":{"title":"封装哈希表","titles":["哈希表"]},"157":{"title":"哈希表常见操作","titles":["哈希表","封装哈希表"]},"158":{"title":"哈希函数的简单实现","titles":["哈希表","封装哈希表"]},"159":{"title":"哈希表的实现","titles":["哈希表","封装哈希表"]},"160":{"title":"创建哈希表类","titles":["哈希表","封装哈希表","哈希表的实现"]},"161":{"title":"put(key,value)","titles":["哈希表","封装哈希表","哈希表的实现"]},"162":{"title":"get(key)","titles":["哈希表","封装哈希表","哈希表的实现"]},"163":{"title":"remove(key)","titles":["哈希表","封装哈希表","哈希表的实现"]},"164":{"title":"isEmpty()","titles":["哈希表","封装哈希表","哈希表的实现"]},"165":{"title":"size()","titles":["哈希表","封装哈希表","哈希表的实现"]},"166":{"title":"哈希表的扩容与压缩","titles":["哈希表"]},"167":{"title":"resize() 的实现","titles":["哈希表","哈希表的扩容与压缩"]},"168":{"title":"选择质数作为哈希表容量","titles":["哈希表","哈希表的扩容与压缩"]},"169":{"title":"质数判断","titles":["哈希表","哈希表的扩容与压缩","选择质数作为哈希表容量"]},"170":{"title":"实现扩容或压缩后的哈希表容量为质数","titles":["哈希表","哈希表的扩容与压缩","选择质数作为哈希表容量"]},"171":{"title":"哈希表完整实现","titles":["哈希表"]},"172":{"title":"优先队列","titles":[]},"173":{"title":"场景","titles":["优先队列"]},"174":{"title":"优先队列","titles":["优先队列"]},"175":{"title":"优先队列的实现","titles":["优先队列"]},"176":{"title":"代码实现","titles":["优先队列","优先队列的实现"]},"177":{"title":"测试代码","titles":["优先队列","优先队列的实现"]},"178":{"title":"数组、栈和队列图解","titles":["优先队列"]},"179":{"title":"字典","titles":[]},"180":{"title":"字典特点","titles":["字典"]},"181":{"title":"字典和映射的关系","titles":["字典"]},"182":{"title":"字典常见的操作","titles":["字典"]},"183":{"title":"字典封装","titles":["字典"]},"184":{"title":"代码实现","titles":["字典","字典封装"]},"185":{"title":"代码测试","titles":["字典","字典封装"]},"186":{"title":"队列","titles":[]},"187":{"title":"认识队列","titles":["队列"]},"188":{"title":"队列图解","titles":["队列","认识队列"]},"189":{"title":"队列在程序中的应用","titles":["队列","认识队列"]},"190":{"title":"队列的实现","titles":["队列"]},"191":{"title":"队列常见的操作","titles":["队列","队列的实现"]},"192":{"title":"代码实现","titles":["队列","队列的实现"]},"193":{"title":"测试代码","titles":["队列","队列的实现"]},"194":{"title":"队列的应用","titles":["队列"]},"195":{"title":"代码实现","titles":["队列","队列的应用"]},"196":{"title":"测试代码","titles":["队列","队列的应用"]},"197":{"title":"集合","titles":[]},"198":{"title":"集合特点","titles":["集合"]},"199":{"title":"封装集合","titles":["集合"]},"200":{"title":"集合常见的操作","titles":["集合","封装集合"]},"201":{"title":"代码实现","titles":["集合","封装集合"]},"202":{"title":"代码测试","titles":["集合","封装集合"]},"203":{"title":"集合间的操作","titles":["集合"]},"204":{"title":"并集的实现","titles":["集合","集合间的操作"]},"205":{"title":"交集的实现","titles":["集合","集合间的操作"]},"206":{"title":"差集的实现","titles":["集合","集合间的操作"]},"207":{"title":"子集的实现","titles":["集合","集合间的操作"]},"208":{"title":"集合的完整实现","titles":["集合"]},"209":{"title":"栈","titles":[]},"210":{"title":"什么是栈","titles":["栈"]},"211":{"title":"程序中的栈结构","titles":["栈"]},"212":{"title":"练习","titles":["栈"]},"213":{"title":"栈结构实现","titles":["栈"]},"214":{"title":"栈常见的操作","titles":["栈","栈结构实现"]},"215":{"title":"JavaScript 代码实现栈结构","titles":["栈","栈结构实现"]},"216":{"title":"测试封装的栈结构","titles":["栈","栈结构实现"]},"217":{"title":"栈结构的简单应用","titles":["栈"]},"218":{"title":"代码实现","titles":["栈","栈结构的简单应用"]},"219":{"title":"测试","titles":["栈","栈结构的简单应用"]},"220":{"title":"树","titles":[]},"221":{"title":"真实的树","titles":["树"]},"222":{"title":"树的特点","titles":["树"]},"223":{"title":"树结构的优势","titles":["树"]},"224":{"title":"树的常用术语","titles":["树"]},"225":{"title":"树结构的表示方式","titles":["树"]},"226":{"title":"最普通的表示方法","titles":["树","树结构的表示方式"]},"227":{"title":"儿子 - 兄弟表示法","titles":["树","树结构的表示方式"]},"228":{"title":"儿子 - 兄弟表示法旋转","titles":["树","树结构的表示方式"]},"229":{"title":"前言","titles":[]},"230":{"title":"什么是数据结构","titles":["前言"]},"231":{"title":"数据结构的定义","titles":["前言","什么是数据结构"]},"232":{"title":"数据结构在生活中应用","titles":["前言","什么是数据结构"]},"233":{"title":"常见的数据结构","titles":["前言","什么是数据结构"]},"234":{"title":"什么是算法","titles":["前言"]},"235":{"title":"算法（Algorithm）的定义","titles":["前言","什么是算法"]},"236":{"title":"算法通俗理解","titles":["前言","什么是算法"]},"237":{"title":"算法案例","titles":["前言","什么是算法"]}},"dirtCount":0,"index":[["≈",{"2":{"237":1}}],["位底",{"2":{"237":1}}],["位置开始一个一个位置地查找数据",{"2":{"148":1}}],["位置插入元素",{"2":{"96":1,"100":1}}],["位置的节点",{"2":{"96":1,"100":1}}],["位置中间插入",{"2":{"93":1,"94":1,"100":1}}],["位置起的",{"2":{"51":1}}],["位置",{"2":{"42":2,"148":1}}],["位置为默认的已排序的序列",{"2":{"39":1}}],["怎么计算出来的呢",{"2":{"237":1}}],["怎么找到某本指定的书",{"2":{"232":1}}],["看一下问题出在上海到中间位置",{"2":{"237":1}}],["米",{"2":{"237":1}}],["高架线长度是",{"2":{"237":1}}],["高位默认为",{"2":{"44":1}}],["假如上海和杭州之间有一条高架线",{"2":{"237":1}}],["假设你是一位很棒的家长",{"2":{"28":1}}],["假设你正在爬楼梯",{"2":{"25":1}}],["假设枢纽值的位置为",{"2":{"17":1}}],["假设我们只差最后一步就能走上第",{"2":{"14":1}}],["离不开算法",{"2":{"236":1}}],["步骤逻辑",{"2":{"236":1}}],["散列表",{"2":{"233":1}}],["堆",{"2":{"233":1}}],["堆排序的平均时间复杂度为",{"2":{"43":1}}],["堆排序",{"0":{"43":1}}],["更多",{"2":{"232":1}}],["更新链表长度",{"2":{"132":1,"136":1,"140":2}}],["更新",{"2":{"45":1}}],["正传",{"2":{"232":1}}],["正整数",{"2":{"44":1}}],["阿",{"2":{"232":1}}],["盲目找",{"2":{"232":1}}],["哪里有空位放哪里",{"2":{"232":1}}],["精心选择的数据结构可以带来最优效率的算法",{"2":{"231":1}}],["组织数据的方式",{"2":{"231":1}}],["组成",{"2":{"83":1,"125":1}}],["抽象数据类型",{"2":{"231":1}}],["任何树都可以通过二叉树进行模拟",{"2":{"228":1}}],["兄弟表示法组成的树结构",{"2":{"228":1}}],["兄弟表示法旋转",{"0":{"228":1}}],["兄弟表示法",{"0":{"227":1}}],["兄弟节点",{"2":{"224":1}}],["儿子",{"0":{"227":1,"228":1}}],["层",{"2":{"224":1}}],["层的最大节点树为",{"2":{"57":1}}],["规定根节点在",{"2":{"224":1}}],["规律总结",{"2":{"80":1}}],["互为兄弟节点",{"2":{"224":1}}],["互联网中的某台主机",{"2":{"105":1}}],["互联网中的网络关系",{"2":{"104":1}}],["具有同一父节点的各节点彼此是兄弟节点",{"2":{"224":1}}],["具体算法为",{"2":{"154":1}}],["子节点",{"2":{"224":1}}],["子集的实现",{"0":{"207":1}}],["子集",{"2":{"203":1,"207":1,"208":1}}],["子集问题",{"0":{"32":1}}],["叶节点",{"2":{"224":1}}],["叶子节点不为根节点",{"2":{"78":1}}],["叶子节点也是根节点",{"2":{"78":1}}],["≥",{"2":{"223":1}}],["底层使用的数组中很多单元没有被利用",{"2":{"223":1}}],["才能在使用数据时更加方便呢",{"2":{"232":1}}],["才能提高查找效率",{"2":{"223":1}}],["才能有效的计算",{"2":{"110":1}}],["生成有序数组",{"2":{"223":1}}],["生活中类似队列结构的场景",{"2":{"187":1}}],["生活中类似优先队列的场景",{"2":{"173":1}}],["效率天壤之别",{"2":{"237":1}}],["效率高",{"2":{"223":1}}],["效率更高",{"2":{"155":1}}],["模拟的树结构相当于旋转",{"2":{"222":1}}],["形成许多树枝",{"2":{"222":1}}],["连接着根的是树干",{"2":{"222":1}}],["连续的单元",{"2":{"148":1}}],["真实的树",{"0":{"221":1}}],["除数除以二",{"2":{"218":1}}],["除二取余法",{"2":{"218":1}}],["除了二叉树最后一层外",{"2":{"60":1}}],["除了最下一层的叶子节点外",{"2":{"59":1}}],["压栈操作",{"2":{"215":1}}],["压入栈",{"2":{"211":2}}],["仅仅返回它",{"2":{"214":1}}],["仅允许在表的一端进行插入和删除运算",{"2":{"210":1}}],["答案",{"2":{"212":4}}],["×",{"2":{"212":1}}],["√",{"2":{"212":3}}],["问下列哪一个不是合法的出栈顺序",{"2":{"212":1}}],["题目所说的按顺序进栈指的不是一次性全部进栈",{"2":{"212":1}}],["题目",{"2":{"212":1}}],["练习",{"0":{"212":1}}],["弹出栈的顺序为",{"2":{"211":1}}],["函数",{"2":{"211":2}}],["函数中调用",{"2":{"211":1}}],["函数调用栈",{"2":{"211":1}}],["函数来实现",{"2":{"17":1}}],["程序中的栈结构",{"0":{"211":1}}],["必须对这种任意性加以限制",{"2":{"209":1}}],["栈结构的简单应用",{"0":{"217":1},"1":{"218":1,"219":1}}],["栈结构的封装",{"2":{"215":1}}],["栈结构实现",{"0":{"213":1},"1":{"214":1,"215":1,"216":1}}],["栈常见的操作",{"0":{"214":1}}],["栈顶",{"2":{"211":1}}],["栈的特点",{"2":{"210":1}}],["栈和队列就是比较常见的受限的线性结构",{"2":{"209":1}}],["栈和队列图解",{"0":{"178":1}}],["栈",{"0":{"209":1},"1":{"210":1,"211":1,"212":1,"213":1,"214":1,"215":1,"216":1,"217":1,"218":1,"219":1},"2":{"210":1,"233":1}}],["验证一个给定集合是否是另一个集合的子集",{"2":{"203":1}}],["差集的实现",{"0":{"206":1}}],["差集",{"2":{"203":1,"206":1,"208":1}}],["交集的实现",{"0":{"205":1}}],["交集",{"2":{"203":1}}],["交换节点信息",{"2":{"93":1,"94":1,"100":1}}],["交换数组中两个元素的位置",{"2":{"38":1,"43":1}}],["交换最小元素到当前位置",{"2":{"38":1}}],["交换是个比较耗时的操作",{"2":{"38":1}}],["了解集合的底层实现",{"2":{"199":1}}],["了解这些术语有助于我们更深层次的理解图",{"2":{"105":1}}],["集合的完整实现",{"0":{"208":1}}],["集合的所有",{"2":{"204":1,"208":1}}],["集合中存在",{"2":{"205":1,"206":1,"207":1,"208":3}}],["集合间的操作",{"0":{"203":1},"1":{"204":1,"205":1,"206":1,"207":1},"2":{"208":1}}],["集合结构的封装",{"2":{"201":1,"208":1}}],["集合常见的操作",{"0":{"200":1}}],["集合是特殊的数组",{"2":{"198":1}}],["集合通常是由一组无序的",{"2":{"198":1}}],["集合特点",{"0":{"198":1}}],["集合比较常见的实现方式是哈希表",{"2":{"197":1}}],["集合",{"0":{"197":1},"1":{"198":1,"199":1,"200":1,"201":1,"202":1,"203":1,"204":1,"205":1,"206":1,"207":1,"208":1}}],["传入一组数据集合和设定的数字",{"2":{"194":1}}],["击鼓传花",{"2":{"194":1,"196":1}}],["转成字符串形式",{"2":{"191":1}}],["转化为数字",{"2":{"143":1}}],["转化为",{"2":{"23":1}}],["移出空位",{"2":{"232":1}}],["移除栈顶的元素",{"2":{"214":1}}],["移除集合中的所有项",{"2":{"200":1}}],["移除队列的第一",{"2":{"191":1}}],["移动",{"2":{"42":1}}],["线程队列",{"2":{"189":1}}],["线性查找",{"2":{"163":1,"237":1}}],["线性遍历",{"2":{"162":1}}],["线性探测存在一个比较严重的问题",{"2":{"148":1}}],["线性探测存在的问题",{"2":{"148":1}}],["线性探测",{"0":{"148":1},"2":{"147":1,"149":1,"152":1}}],["打印队列",{"2":{"189":1}}],["打家劫舍",{"0":{"26":1}}],["甚至是厕所排队",{"2":{"187":1}}],["甚至子节点还有子节点",{"2":{"80":1}}],["商场",{"2":{"187":1}}],["受限之处",{"2":{"187":1}}],["认识队列",{"0":{"187":1},"1":{"188":1,"189":1}}],["认识哈希化",{"0":{"143":1}}],["认识哈希表",{"0":{"142":1},"1":{"143":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1,"150":1,"151":1,"152":1,"153":1,"154":1,"155":1}}],["队列中只剩下",{"2":{"195":1}}],["队列的应用",{"0":{"194":1},"1":{"195":1,"196":1}}],["队列的实现和栈一样",{"2":{"190":1}}],["队列的实现",{"0":{"190":1},"1":{"191":1,"192":1,"193":1}}],["队列不做任何变动",{"2":{"191":1}}],["队列不为空时一直持续",{"2":{"120":1}}],["队列常见的操作",{"0":{"191":1}}],["队列在程序中的应用",{"0":{"189":1}}],["队列图解",{"0":{"188":1}}],["队列",{"0":{"186":1},"1":{"187":1,"188":1,"189":1,"190":1,"191":1,"192":1,"193":1,"194":1,"195":1,"196":1},"2":{"187":1,"233":1}}],["清空集合中所有",{"2":{"201":1,"208":1}}],["清空字典中所有的键值对",{"2":{"184":1}}],["清空旧的数组",{"2":{"44":1}}],["主要特点是一一对应",{"2":{"180":1}}],["排队",{"2":{"187":1}}],["排队中",{"2":{"173":1}}],["排序过程",{"2":{"44":1}}],["排序循环的次数为",{"2":{"43":1}}],["排序",{"0":{"36":1},"1":{"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1}}],["排序后再取最小的",{"2":{"17":1}}],["买票",{"2":{"173":1,"187":1}}],["买卖股票的最佳时机",{"0":{"29":1}}],["终止",{"2":{"171":1}}],["终止不再往下执行",{"2":{"161":1}}],["已经有重复判断",{"2":{"204":1,"208":1}}],["已经存在",{"2":{"45":1}}],["已有个数",{"2":{"171":1}}],["停止循环",{"2":{"170":1}}],["整体的入栈顺序符合",{"2":{"212":1}}],["整体入栈顺序符合",{"2":{"212":1}}],["整除",{"2":{"169":2}}],["整个序列的最大值就是堆顶的根节点",{"2":{"43":1}}],["整个排序过程可以递归进行",{"2":{"42":1}}],["整个数组恰被分成一组",{"2":{"40":1}}],["针对质数的特点",{"2":{"169":1}}],["质数判断",{"0":{"169":1}}],["质数即可",{"2":{"158":1}}],["扩容或压缩",{"2":{"167":1,"171":1}}],["扩容之后所有的数据项都要进行同步修改",{"2":{"166":1}}],["关于质数",{"2":{"166":1}}],["寻找对应的数据",{"2":{"163":1}}],["仍然没有找到对应的",{"2":{"162":1}}],["格式为",{"2":{"161":1,"171":1}}],["封装集合",{"0":{"199":1},"1":{"200":1,"201":1,"202":1}}],["封装的哈希表的数据结构模型",{"2":{"160":1}}],["封装哈希表",{"0":{"156":1},"1":{"157":1,"158":1,"159":1,"160":1,"161":1,"162":1,"163":1,"164":1,"165":1}}],["秦九韶算法",{"2":{"158":1}}],["自己采用的一个质数",{"2":{"158":1}}],["此外",{"2":{"180":1}}],["此处先简单地指定数组的大小",{"2":{"158":1}}],["此时要求很大容量的数组",{"2":{"143":1}}],["此时的时间复杂度也是接近",{"2":{"83":1}}],["此时通过",{"2":{"79":6}}],["此时末尾就为最大值",{"2":{"43":1}}],["此时",{"2":{"43":1,"78":1}}],["此时递归的次数为",{"2":{"42":1}}],["此时枢纽值左边的值都比枢纽值小",{"2":{"42":1}}],["此时再执行交换操作即可",{"2":{"38":1}}],["此时可以直接结束",{"2":{"37":1}}],["采用的是链地址法",{"2":{"155":1}}],["采用邻接矩阵法",{"2":{"114":1}}],["尽量使用质数",{"2":{"155":1}}],["均匀分布",{"0":{"155":1}}],["均匀的分布",{"2":{"153":1}}],["降到了",{"2":{"154":1}}],["乘法次数",{"2":{"154":2}}],["变换之后",{"2":{"154":1}}],["变换之前",{"2":{"154":1}}],["变量",{"2":{"77":2}}],["霍纳法则",{"2":{"154":1}}],["快速计算",{"0":{"154":1}}],["快速的计算",{"2":{"153":1}}],["快速排序相对于其他排序算法的优势在于在相同数据量的情况下",{"2":{"42":1}}],["快速排序的平均时间复杂度为",{"2":{"42":1}}],["快速排序的空间复杂度取决于递归的深度",{"2":{"42":1}}],["快速排序有可能被转换为冒泡排序",{"2":{"42":1}}],["快速排序",{"0":{"42":1},"2":{"19":1}}],["提高速度的一个方法是在哈希函数中尽量减少乘法和除法",{"2":{"153":1}}],["提供了一个便利的",{"2":{"124":1}}],["较为平缓",{"2":{"152":1}}],["较小的饼干",{"2":{"28":1}}],["性能高的哈希函数应具备以下两个优点",{"2":{"153":1}}],["性能不高",{"2":{"152":1}}],["性能较差",{"2":{"152":1}}],["性能优于",{"2":{"83":1}}],["装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值",{"2":{"151":1}}],["装填因子",{"0":{"151":1},"2":{"151":1,"166":1,"167":1,"171":1}}],["探测长度会越来越长",{"2":{"150":1}}],["平均需要",{"2":{"237":1}}],["平均探测长度呈线性增长",{"2":{"152":1}}],["平均探测长度呈指数形式增长",{"2":{"152":2}}],["平均探测长度以及平均存取时间",{"2":{"150":1}}],["平衡树",{"0":{"83":1}}],["优点",{"2":{"223":4}}],["优先级都大于新插入的元素",{"2":{"176":1}}],["优先级越大",{"2":{"176":1}}],["优先级队列主要考虑的问题",{"2":{"174":1}}],["优先处理",{"2":{"173":1,"187":1}}],["优先排队的人",{"2":{"173":1,"187":1}}],["优先队列类",{"2":{"176":1}}],["优先队列内部的元素类",{"2":{"176":1}}],["优先队列的实现",{"0":{"175":1},"1":{"176":1,"177":1}}],["优先队列",{"0":{"172":1,"174":1},"1":{"173":1,"174":1,"175":1,"176":1,"177":1,"178":1}}],["优秀的哈希函数",{"2":{"150":1}}],["优化后的冒泡排序",{"2":{"37":1}}],["避免了数据聚集带来的影响",{"2":{"149":1}}],["等待",{"2":{"189":1}}],["等",{"2":{"181":1,"224":1}}],["等依次探测",{"2":{"149":1}}],["等于",{"2":{"42":2,"79":6,"82":6}}],["聚集会影响哈希表的性能",{"2":{"148":1}}],["查看栈顶元素",{"2":{"215":1}}],["查看队列的队头元素",{"2":{"192":1}}],["查看队列的前端元素",{"2":{"176":1}}],["查看队列中元素的个数",{"2":{"176":1,"192":1}}],["查看队列是否为空",{"2":{"176":1,"192":1}}],["查询",{"2":{"148":1,"223":1}}],["查询过程中不会遍历整个哈希表",{"2":{"148":1}}],["查找对应的问题后",{"2":{"237":1}}],["查找",{"2":{"142":1}}],["查找效率高",{"2":{"223":1}}],["查找效率低",{"2":{"223":1}}],["查找效率变成了",{"2":{"83":1}}],["查找效率非常高",{"2":{"65":1}}],["查找等操作的效率是",{"2":{"83":1}}],["查找前驱的原理相同",{"2":{"81":1}}],["查找前驱时",{"2":{"81":1}}],["查找需要被删除的节点",{"2":{"81":1}}],["查找二叉搜索树中是否有相同的",{"2":{"76":1}}],["查找二叉搜索树当中的特定值效率也非常高",{"2":{"76":1}}],["查找特定值",{"0":{"76":1}}],["查找最大值或最小值",{"0":{"75":1}}],["查找数据时需要先对数据进行排序",{"2":{"223":1}}],["查找数据",{"0":{"74":1},"1":{"75":1,"76":1}}],["产生输出",{"2":{"235":1}}],["产生一种依赖关键字",{"2":{"150":1}}],["产生冲突的元素一般不会太多",{"2":{"146":1}}],["产生的数组下标又太多",{"2":{"143":1}}],["产生的数组下标太少",{"2":{"143":1}}],["拉链法可以无限延伸下去",{"2":{"151":1}}],["拉链法",{"0":{"146":1},"2":{"145":1}}],["链地址法或者开放地址法",{"2":{"155":1}}],["链地址法的性能",{"2":{"152":1}}],["链地址法的装填因子可以大于",{"2":{"151":1}}],["链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据",{"2":{"146":1}}],["链地址法",{"0":{"146":1},"2":{"145":1}}],["链表和树等可通过图形的形式表示其结构和原理",{"2":{"142":1}}],["链表和数组一样",{"2":{"123":1}}],["链表和数组",{"0":{"123":1},"1":{"124":1,"125":1}}],["链表数据以字符串形式返回",{"2":{"140":1}}],["链表数据从后往前以字符串形式返回",{"2":{"98":1,"100":1}}],["链表数据从前往后以字符串形式返回",{"2":{"97":1,"100":1}}],["链表长度",{"2":{"130":1,"140":1}}],["链表长度大于",{"2":{"130":1,"140":1}}],["链表长度为",{"2":{"130":1,"140":1}}],["链表里的节点",{"2":{"129":1,"140":1}}],["链表中的常见操作",{"0":{"127":1}}],["链表中的最后一个节点指向",{"2":{"126":1}}],["链表中的元素在内存中不必是连续的空间",{"2":{"125":1}}],["链表缺点",{"2":{"125":1}}],["链表在插入和删除数据时",{"2":{"125":1}}],["链表不必在创建时就确定大小",{"2":{"125":1}}],["链表优点",{"2":{"125":1}}],["链表的数据结构",{"2":{"126":1}}],["链表的火车结构",{"2":{"126":1}}],["链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用",{"2":{"125":1}}],["链表的常见操作",{"2":{"100":1,"140":1}}],["链表",{"0":{"125":1},"2":{"110":2,"166":1,"223":2,"233":1}}],["链表内有多个节点的情况",{"2":{"95":1,"100":1}}],["链表内只有一个节点的情况",{"2":{"95":1,"100":1}}],["链表相连的过程是双向的",{"2":{"87":1}}],["链表相连的过程是单向的",{"2":{"86":1}}],["冲突是不可避免的",{"2":{"145":1}}],["地址的冲突",{"0":{"145":1},"1":{"146":1,"147":1,"148":1,"149":1,"150":1,"151":1,"152":1}}],["得到的就是哈希表",{"2":{"144":1}}],["称之为哈希化",{"2":{"144":1}}],["称为原来树的子树",{"2":{"223":1}}],["称为空树",{"2":{"223":1}}],["称为",{"2":{"81":2}}],["哈希函数的简单实现",{"0":{"158":1}}],["哈希函数",{"0":{"153":1},"1":{"154":1,"155":1},"2":{"144":1}}],["哈希化采用的是公式为",{"2":{"155":1}}],["哈希化的效率",{"2":{"150":1}}],["哈希化",{"2":{"144":1}}],["哈希表有哪些优势呢",{"2":{"223":1}}],["哈希表完整实现",{"0":{"171":1}}],["哈希表存储数据的变量",{"2":{"160":1,"171":1}}],["哈希表常见操作",{"0":{"157":1}}],["哈希表长度",{"2":{"151":1,"160":1,"167":1,"171":1}}],["哈希表中数据",{"2":{"167":1}}],["哈希表中执行插入和搜索操作效率是非常高的",{"2":{"150":1}}],["哈希表中的",{"2":{"142":1}}],["哈希表中的数据是没有顺序的",{"2":{"142":1}}],["哈希表最后还是基于数组来实现的",{"2":{"142":1}}],["哈希表的插入",{"2":{"223":1}}],["哈希表的插入和修改操作是同一个函数",{"2":{"161":1}}],["哈希表的扩容与压缩",{"0":{"166":1},"1":{"167":1,"168":1,"169":1,"170":1}}],["哈希表的实现",{"0":{"159":1},"1":{"160":1,"161":1,"162":1,"163":1,"164":1,"165":1}}],["哈希表的长度",{"2":{"155":1}}],["哈希表的优势在于它的速度",{"2":{"153":1}}],["哈希表的一些概念",{"0":{"144":1}}],["哈希表的结构就是数组",{"2":{"142":1}}],["哈希表的速度比树还要快",{"2":{"142":1}}],["哈希表并不好理解",{"2":{"142":1}}],["哈希表是什么",{"2":{"142":1}}],["哈希表是一种非常重要的数据结构",{"2":{"142":1}}],["哈希表同样存在不足之处",{"2":{"142":1}}],["哈希表相对于树来说编码要简单得多",{"2":{"142":1}}],["哈希表可以提供非常快速的",{"2":{"142":1}}],["哈希表通常是基于数组实现的",{"2":{"142":1}}],["哈希表",{"0":{"141":1},"1":{"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1,"150":1,"151":1,"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":1,"159":1,"160":1,"161":1,"162":1,"163":1,"164":1,"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1},"2":{"110":1,"144":1,"223":1}}],["造成了数组空间的浪费",{"2":{"143":1}}],["虽然效率不一定都比它们高",{"2":{"223":1}}],["虽然这种情况出现的概率较线性探测的聚集要小",{"2":{"149":1}}],["虽然取余操作得到的结构也有可能重复",{"2":{"143":1}}],["虽然该方式可以保证字符的唯一性",{"2":{"143":1}}],["虽然可以轻松地到达下一个节点",{"2":{"125":1}}],["幂的连乘",{"2":{"143":1}}],["幂集",{"2":{"32":1}}],["很多的单词按照该方式转化为数字后都是",{"2":{"143":1}}],["单词的下标值储存在数组中",{"2":{"143":1}}],["单向链表的封装",{"0":{"128":1},"1":{"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1,"140":1}}],["单向链表类似于火车",{"2":{"126":1}}],["单向链表有一个比较明显的缺点",{"2":{"86":1}}],["单向链表",{"0":{"86":1,"122":1,"126":1},"1":{"123":1,"124":1,"125":1,"126":1,"127":2,"128":2,"129":2,"130":2,"131":2,"132":2,"133":2,"134":2,"135":2,"136":2,"137":2,"138":2,"139":2,"140":2}}],["单向链表和双向链表",{"0":{"85":1},"1":{"86":1,"87":1}}],["作为数组的下标值",{"2":{"146":1}}],["作为",{"2":{"143":1}}],["作为插入的索引",{"2":{"44":1}}],["建立字符串和下标值的映射关系",{"2":{"142":1}}],["建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本",{"2":{"106":1}}],["建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道",{"2":{"106":1}}],["案例二",{"2":{"142":1}}],["案例一",{"2":{"142":1}}],["没错此时就可以使用哈希表的哈希函数来实现",{"2":{"142":1}}],["没有顺序意味着不能通过下标值进行访问",{"2":{"198":1}}],["没有用到的",{"2":{"105":1}}],["没有找到返回",{"2":{"34":1}}],["没有重复元素",{"2":{"31":1,"32":1}}],["能把某一员工的姓名转换为它对应的工号",{"2":{"142":1}}],["增加和删除数据时比较麻烦",{"2":{"142":1}}],["增加其计数",{"2":{"45":1}}],["公司想要存储",{"2":{"142":1}}],["公司的组织架构等等",{"2":{"104":1}}],["操作",{"2":{"142":1,"232":8}}],["赋值到",{"2":{"136":1,"140":1}}],["赋值为",{"2":{"132":1,"140":1}}],["痛过循环遍历",{"2":{"135":1,"140":1}}],["涉及到",{"2":{"135":1,"140":1}}],["原来的第一个节点",{"2":{"132":1,"140":1}}],["让新插入的元素进行优先级比较",{"2":{"176":1}}],["让新节点的",{"2":{"132":1,"140":1}}],["让",{"2":{"166":1}}],["让数字相加求和",{"2":{"143":1}}],["让上一节点的",{"2":{"136":1,"140":1}}],["让最后一个节点指向新节点",{"2":{"130":1}}],["让其只输出元素的值",{"2":{"89":1,"127":1}}],["循序依次找最后一个节点",{"2":{"130":1,"140":1}}],["循环",{"2":{"218":1}}],["循环遍历数组内元素",{"2":{"194":1}}],["循环使",{"2":{"130":1}}],["循环查找",{"2":{"81":1,"82":1}}],["循环查找到要删除的节点",{"2":{"77":1,"82":1}}],["循环实现",{"2":{"76":1}}],["循环调整每一个子树",{"2":{"43":1}}],["循环从",{"2":{"39":1}}],["循环到",{"2":{"24":1,"25":1,"26":1}}],["追加完新节点后",{"2":{"130":1,"140":1}}],["追加新节点",{"2":{"130":1,"140":1}}],["追加元素",{"2":{"92":1,"100":1}}],["初始设为质数",{"2":{"160":1,"171":1}}],["初始",{"2":{"129":1,"140":1}}],["初始链表长度为",{"2":{"129":1,"140":1}}],["初始化一些变量",{"2":{"132":1,"140":1}}],["初始化颜色",{"2":{"120":1,"121":1}}],["初始化顶点的颜色",{"2":{"119":1}}],["初始化桶",{"2":{"44":1}}],["初始化前两项",{"2":{"12":1}}],["火车头会连接一个节点",{"2":{"126":1}}],["访问任何一个位置的元素时",{"2":{"125":1}}],["内部类",{"2":{"129":1,"140":1}}],["内存空间不必是连续的",{"2":{"125":1}}],["内层循环的优化",{"2":{"37":1}}],["倍扩容后长度为",{"2":{"170":1}}],["倍扩容或压缩之后",{"2":{"170":1}}],["倍",{"2":{"124":1}}],["语法来访问数组元素",{"2":{"124":1}}],["调用",{"2":{"211":2}}],["调用深度优先算法",{"2":{"121":1}}],["调用广度优先算法",{"2":{"120":1}}],["处理",{"2":{"189":1}}],["处理完后设置为访问过点",{"2":{"121":1}}],["处理位数不够的情况",{"2":{"44":1}}],["拿与该点相邻的点",{"2":{"121":1}}],["拿到队头所关联",{"2":{"120":1}}],["拿到队头",{"2":{"120":1}}],["接收一些输入",{"2":{"235":1}}],["接着",{"2":{"161":1,"162":1,"163":1}}],["接着原路回退并探索下一条路径",{"2":{"121":1}}],["接起来一张",{"2":{"39":1}}],["沿着路径知道这条路径最后被访问了",{"2":{"121":1}}],["标志为黑色",{"2":{"120":1}}],["标注为被发现的灰色",{"2":{"120":1}}],["标注为被发现的",{"2":{"120":1}}],["执行完之后",{"2":{"211":1}}],["执行时也会被压入栈",{"2":{"211":1}}],["执行时",{"2":{"211":1}}],["执行的过程中会将",{"2":{"211":1}}],["执行相应的回调",{"2":{"121":1}}],["执行下面的步骤",{"2":{"120":1}}],["执行上述公式",{"2":{"24":1,"25":1,"26":1}}],["换句话说",{"2":{"120":1}}],["换成了",{"2":{"40":1}}],["黑色",{"2":{"119":1}}],["黑色表示该顶点被访问过且被完全探索过",{"2":{"119":1}}],["灰色",{"2":{"119":1,"120":2}}],["灰色表示该顶点被访问过",{"2":{"119":1}}],["白色",{"2":{"119":1,"120":1}}],["白色表示该顶点还没有被访问",{"2":{"119":1}}],["入栈或压栈",{"2":{"210":1}}],["入队",{"2":{"176":1,"177":1,"192":1}}],["入队列的顶点先被探索",{"2":{"119":1}}],["入度",{"2":{"110":3}}],["两种数据结构查找的效率相当",{"2":{"146":1}}],["两种方案总结",{"2":{"143":1}}],["两种算法的思想",{"2":{"119":1}}],["两个树就镜像",{"2":{"23":1}}],["两个树",{"2":{"22":1}}],["深度优先搜索算法的代码",{"2":{"121":1}}],["深度优先搜索算法的实现",{"2":{"121":1}}],["深度优先搜索算法将会从第一个指定的顶点开始遍历图",{"2":{"121":1}}],["深度优先搜索的思路",{"2":{"121":1}}],["深度优先搜索",{"0":{"121":1},"2":{"119":1,"121":1}}],["深度为",{"2":{"57":1}}],["简称",{"2":{"119":2}}],["简单的扩容可以直接扩大两倍",{"2":{"166":1}}],["简单路径要求不包含重复的顶点",{"2":{"105":1}}],["简单路径",{"2":{"105":1}}],["简单来说就是",{"2":{"40":1}}],["广度优先算法会从指定的第一个顶点开始遍历图",{"2":{"120":1}}],["广度优先搜索算法我们使用的是队列",{"2":{"121":1}}],["广度优先搜索算法的思路",{"2":{"120":1}}],["广度优先搜索的代码",{"2":{"120":1}}],["广度优先搜索的实现",{"2":{"120":1}}],["广度优先搜索",{"0":{"120":1},"2":{"119":1,"120":1}}],["广州地铁图",{"2":{"104":1}}],["加法次数",{"2":{"154":2}}],["加入到队列中",{"2":{"120":1}}],["加入到它的数组中",{"2":{"115":2}}],["加权的边可以表示从一个机场到另一个机场的航班成本",{"2":{"106":1}}],["加权的边可以表示限速或者车道的数量或者街道的距离",{"2":{"106":1}}],["结论",{"2":{"232":1,"237":1}}],["结账",{"2":{"173":1,"187":1}}],["结构用",{"2":{"114":1}}],["结果并不一定是最优",{"2":{"27":1}}],["逆邻接表",{"2":{"110":1}}],["出栈操作",{"2":{"215":1}}],["出栈而不是",{"2":{"212":1}}],["出栈",{"2":{"212":14}}],["出队",{"2":{"176":1,"177":1,"192":1}}],["出度",{"2":{"110":2}}],["出现的次数",{"2":{"45":1}}],["字典结构的封装",{"2":{"184":1}}],["字典封装",{"0":{"183":1},"1":{"184":1,"185":1}}],["字典常见的操作",{"0":{"182":1}}],["字典和映射的关系",{"0":{"181":1}}],["字典形式",{"2":{"180":1}}],["字典存储的是键值对",{"2":{"180":1}}],["字典特点",{"0":{"180":1}}],["字典",{"0":{"179":1},"1":{"180":1,"181":1,"182":1,"183":1,"184":1,"185":1},"2":{"110":2}}],["邻接的意思",{"2":{"112":1}}],["邻接表如果需要计算有向图的",{"2":{"110":1}}],["邻接表计算",{"2":{"110":1}}],["邻接表的问题",{"2":{"110":1}}],["邻接表由图中每个顶点以及和顶点相邻的顶点列表组成",{"2":{"110":1}}],["邻接表",{"0":{"110":1}}],["邻接矩阵展示出来的二维数组",{"2":{"109":1}}],["邻接矩阵的问题",{"2":{"109":1}}],["邻接矩阵让每个节点和一个整数向关联",{"2":{"109":1}}],["邻接矩阵",{"0":{"109":1}}],["另外一个选择就是使用链表",{"2":{"125":1}}],["另外",{"2":{"109":1,"114":1}}],["另外包含顶点和顶点之间的连线",{"2":{"107":1}}],["概述",{"2":{"109":1,"110":1}}],["​",{"2":{"106":1}}],["航空公司可以用图来为其飞行系统建模",{"2":{"106":1}}],["现实生活中很多结构都是树的抽象",{"2":{"222":1}}],["现实建模",{"0":{"106":1}}],["现在需要一种方法",{"2":{"150":1}}],["现在需要一种压缩方法",{"2":{"143":1}}],["现在要求输入一个整数",{"2":{"11":1}}],["带权图表示边有一定的权重",{"2":{"105":1}}],["带权图",{"2":{"105":1}}],["要根据方向来定",{"2":{"105":1}}],["要求",{"2":{"31":1,"32":1}}],["要求用程序来求出一共有多少种走法",{"2":{"13":1}}],["路径所包含边的个数称为路径长度",{"2":{"224":1}}],["路径指的是一个节点到另一节点的通道",{"2":{"224":1}}],["路径和路径长度",{"2":{"224":1}}],["路径是顶点",{"2":{"105":1}}],["路径",{"2":{"105":1}}],["路径有其他的概念",{"2":{"105":1}}],["度不为",{"2":{"224":1}}],["度",{"2":{"105":1}}],["度为",{"2":{"42":1,"224":1}}],["注意",{"2":{"105":1}}],["人际关系中的人",{"2":{"105":1}}],["人与人之间的关系网",{"2":{"104":1}}],["多个村庄中的某个村庄",{"2":{"105":1}}],["顶点是沿着路径被探索的",{"2":{"119":1}}],["顶点有关联的顶点",{"2":{"110":1}}],["顶点的表示相对简单",{"2":{"108":1}}],["顶点的度是",{"2":{"105":2}}],["顶点表示",{"0":{"108":1}}],["顶点可以表示街道的十字路口",{"2":{"106":1}}],["顶点和其他四个顶点相连",{"2":{"105":1}}],["顶点和其他两个顶点相连",{"2":{"105":1}}],["顶点刚才我们已经介绍过了",{"2":{"105":1}}],["顶点",{"2":{"105":1,"109":1}}],["某些术语后面用到的时候",{"2":{"105":1}}],["边不可能单独存在",{"2":{"115":2}}],["边的表示略微复杂",{"2":{"108":1}}],["边可以表示街道",{"2":{"106":1}}],["边可以是有向的",{"2":{"104":1}}],["边没有携带权重",{"2":{"105":1}}],["边表示顶点和顶点之间的连线",{"2":{"105":1}}],["边",{"2":{"105":1,"107":1,"110":1}}],["边是顶点和顶点之间的连线",{"2":{"104":1}}],["几乎每种编程语言中",{"2":{"197":1}}],["几乎每一种编程语言都有默认实现数组结构",{"2":{"124":1}}],["几乎所有的编程语言都直接或者间接应用这种数据结构",{"2":{"142":1}}],["几乎所有的编程语言都原生支持数组类型",{"2":{"47":1}}],["几叉树都不可以",{"2":{"104":1}}],["家谱",{"2":{"104":1}}],["实际情况中",{"2":{"152":1}}],["实际上",{"2":{"104":1,"142":1}}],["实现扩容或压缩后的哈希表容量为质数",{"0":{"170":1}}],["实现哈希化时采用取余运算",{"2":{"155":1}}],["实现灵活的内存动态管理",{"2":{"125":1}}],["实现起来会困难些",{"2":{"87":1}}],["实现原理是一个节点既有向前连接的引用",{"2":{"87":1}}],["实现原理是上一个节点中有指向下一个节点的引用",{"2":{"86":1}}],["实现思路",{"2":{"68":1,"71":1,"72":1,"77":1,"161":1,"162":1,"163":1,"166":1,"170":1}}],["实现一个累加函数的功能",{"0":{"8":1}}],["实现",{"0":{"6":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1},"2":{"5":1}}],["什么是算法",{"0":{"234":1},"1":{"235":1,"236":1,"237":1}}],["什么是数据结构",{"0":{"230":1},"1":{"231":1,"232":1,"233":1}}],["什么是栈",{"0":{"210":1}}],["什么是图呢",{"2":{"104":1}}],["什么是图",{"0":{"104":1}}],["什么情况下需要扩容",{"2":{"166":1}}],["什么问题适合回溯算法解决",{"2":{"30":1}}],["图书各种摆放方式",{"2":{"232":1}}],["图书摆放要使得两个相关操作方便实现",{"2":{"232":1}}],["图解",{"2":{"120":1,"121":1}}],["图片解析",{"2":{"109":1,"110":1}}],["图的遍历算法的思想在于必须访问每个第一次访问的节点",{"2":{"119":1}}],["图的遍历",{"0":{"118":1},"1":{"119":1,"120":1,"121":1}}],["图的封装",{"0":{"111":1},"1":{"112":1,"113":1,"114":1,"115":1,"116":1,"117":1}}],["图的表示",{"0":{"107":1},"1":{"108":1,"109":1,"110":1}}],["图的术语也非常多",{"2":{"105":1}}],["图的术语",{"0":{"105":1}}],["图的概念",{"0":{"103":1},"1":{"104":1,"105":1,"106":1}}],["图通常有什么特点呢",{"2":{"104":1}}],["图长什么样子呢",{"2":{"104":1}}],["图是一种与树有些相似的数据结构",{"2":{"104":1}}],["图论是一个非常大的话题",{"2":{"103":1}}],["图也是一种非常常见的数据结构",{"2":{"103":1}}],["图",{"0":{"102":1},"1":{"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1,"114":1,"115":1,"116":1,"117":1,"118":1,"119":1,"120":1,"121":1},"2":{"233":1}}],["代码测试",{"0":{"101":1,"185":1,"202":1},"2":{"130":1}}],["代码实现栈结构",{"0":{"215":1}}],["代码实现",{"0":{"176":1,"184":1,"192":1,"195":1,"201":1,"218":1},"2":{"10":1,"11":1,"12":1,"14":1,"15":1,"16":1,"20":1,"21":1,"22":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1,"34":1,"35":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"44":1,"45":1,"68":2,"70":1,"71":1,"72":1,"75":1,"76":1,"78":1,"79":1,"81":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1,"161":1,"162":1}}],["拼接为字符串",{"2":{"97":1,"98":1,"100":2,"131":1,"140":1}}],["~",{"2":{"93":1,"94":1,"95":1,"100":2,"132":1,"140":1,"169":3}}],["留个",{"2":{"93":1,"94":1,"100":1}}],["越界判断",{"2":{"93":1,"94":1,"95":1,"100":2,"133":1,"135":1,"136":1,"140":3}}],["巧妙之处",{"2":{"92":1,"93":1,"94":1,"100":2,"136":1,"140":1}}],["跟单向链表不同",{"2":{"92":1,"100":1}}],["重新锁定一般的路程",{"2":{"237":1}}],["重新加入到队列中",{"2":{"195":1}}],["重新加入到队尾",{"2":{"195":1}}],["重新",{"2":{"167":1,"171":1}}],["重新调整哈希表大小",{"2":{"167":1,"171":1}}],["重新调整堆顶元素为最大值",{"2":{"17":1}}],["重置所有属性",{"2":{"167":1,"171":1}}],["重写",{"2":{"92":1,"93":1,"94":1,"95":1,"96":1,"100":4,"176":2}}],["继承",{"2":{"176":5}}],["继承单向链表",{"2":{"100":3}}],["继承单向链表的节点类",{"2":{"91":1}}],["继续检查它的子树",{"2":{"43":1}}],["继续接",{"2":{"39":1}}],["新进一本",{"2":{"232":1}}],["新书怎么插入",{"2":{"232":1}}],["新的项",{"2":{"191":1}}],["新增数据",{"2":{"161":1,"171":1}}],["新插入节点的位置",{"2":{"132":1,"140":1}}],["新添加",{"2":{"91":2}}],["新建一个变量",{"2":{"29":1}}],["类别中按照字母顺序",{"2":{"232":1}}],["类似于自动餐托盘",{"2":{"210":1}}],["类的",{"2":{"176":4,"191":1}}],["类添加判断质数的",{"2":{"170":1}}],["类继承",{"2":{"91":1}}],["类继承单向链表的",{"2":{"91":1}}],["类",{"2":{"89":1,"91":2,"112":1,"127":1,"176":1,"199":1}}],["属性指向链表的第一个节点",{"2":{"126":1}}],["属性",{"2":{"91":2}}],["属性类似",{"2":{"89":1,"127":1,"182":1,"191":1,"200":1,"214":1}}],["属性外",{"2":{"66":1}}],["update",{"0":{"96":1,"135":1},"2":{"89":1,"96":3,"100":3,"101":2,"127":1,"135":4,"140":2}}],["unionset",{"2":{"204":6,"208":6}}],["union",{"2":{"204":2,"208":2}}],["unique",{"2":{"2":3}}],["undefined",{"2":{"161":1,"162":1,"163":1,"171":3,"184":2}}],["unshift",{"2":{"17":1,"50":1}}],["储存数据",{"2":{"88":1}}],["都是由一个个节点连接构成",{"2":{"226":1}}],["都有集合结构",{"2":{"197":1}}],["都有一个尺寸",{"2":{"28":1}}],["都有一个胃口值",{"2":{"28":1}}],["都不允许插入数据",{"2":{"148":1}}],["都要进行越界判断",{"2":{"135":1,"140":1}}],["都需要明确指定第一个被访问的顶点",{"2":{"119":1}}],["都需要处理四个引用",{"2":{"87":1}}],["都可以",{"2":{"110":1}}],["既可以实现哈希表的扩容",{"2":{"167":1}}],["既可以从头遍历到尾",{"2":{"87":1}}],["既能满足孩子",{"2":{"28":1}}],["经过哈希化得到",{"2":{"148":1}}],["经过哈希化",{"2":{"148":1}}],["经过哈希函数哈希化过后得到的下标值可能有重复",{"2":{"145":1}}],["经常会遇到需要回到上一个节点的情况",{"2":{"86":1}}],["经典算法题",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1}}],["双向链表类继承单向链表类",{"2":{"91":1}}],["双向链表常见的操作",{"0":{"89":1}}],["双向链表的其他方法通过继承单向链表来实现",{"2":{"99":1}}],["双向链表的节点类",{"2":{"91":1}}],["双向链表的封装",{"0":{"90":1},"1":{"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1}}],["双向链表的最后一个节点的",{"2":{"88":1}}],["双向链表的第一个节点的",{"2":{"88":1}}],["双向链表不仅有",{"2":{"88":1}}],["双向链表结构",{"0":{"88":1}}],["双向链表缺点",{"2":{"87":1}}],["双向链表可以有效的解决单向链表存在的问题",{"2":{"87":1}}],["双向链表",{"0":{"84":1,"87":1},"1":{"85":1,"86":1,"87":1,"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1}}],["红黑树",{"2":{"83":1}}],["开放地址法的装填因子最大为",{"2":{"151":1}}],["开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项",{"2":{"147":1}}],["开放地址法",{"0":{"147":1},"1":{"148":1,"149":1,"150":1}}],["开发中比较少用",{"2":{"83":1}}],["开始数数",{"2":{"195":1}}],["开始探测",{"2":{"149":1}}],["开始向后一个一个来查找合适的位置来放置",{"2":{"148":1}}],["开始访问",{"2":{"121":2}}],["开始",{"2":{"39":1,"149":1}}],["应该尽可能地等于右边的子孙节点的个数",{"2":{"83":1}}],["起码大部分是平衡的",{"2":{"83":1}}],["而",{"2":{"180":1}}],["而速度上升",{"2":{"152":1}}],["而不是取余运算",{"2":{"155":1}}],["而不是每个关键字探测步长都一样",{"2":{"150":1}}],["而不是两个",{"2":{"87":1}}],["而线性探测就是从",{"2":{"148":1}}],["而是有进有出",{"2":{"212":1}}],["而是一条链条",{"2":{"146":1}}],["而是存储由经过取余操作后得到相同余数的数字组成的数组或链表",{"2":{"146":1}}],["而是适用于所有的二叉树",{"2":{"69":1}}],["而在数组中一个下标值只能储存一个数据",{"2":{"143":1}}],["而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值",{"2":{"142":1}}],["而临街矩阵会非常简单",{"2":{"110":1}}],["而且不能快速找出哈希表中最大值或最小值这些特殊值",{"2":{"223":1}}],["而且",{"2":{"146":1}}],["而且即使只有一个边",{"2":{"109":1}}],["而且有",{"2":{"88":1}}],["而对于一棵非平衡二叉树来说",{"2":{"83":1}}],["会弹出栈被释放",{"2":{"211":1}}],["会发现只是术语就可以占据一个章节",{"2":{"105":1}}],["会严重影响二叉搜索树的性能",{"2":{"83":1}}],["会采用快排",{"2":{"46":1}}],["定义一个变量记录是否成功添加了新元素",{"2":{"176":1}}],["定义一个变量",{"2":{"166":1}}],["定义存储",{"2":{"158":1}}],["定义了两个属性",{"2":{"112":1}}],["定义变量",{"2":{"81":1,"82":1}}],["定义子问题",{"2":{"24":1,"25":1,"26":1}}],["前言",{"0":{"229":1},"1":{"230":1,"231":1,"232":1,"233":1,"234":1,"235":1,"236":1,"237":1}}],["前面的",{"2":{"195":1}}],["前面我们在哈希表中使用的是长度为",{"2":{"166":1}}],["前驱",{"0":{"81":1}}],["前提",{"2":{"29":1}}],["即把队头删除的元素",{"2":{"195":1}}],["即排在队列最前面的",{"2":{"191":1}}],["即可",{"2":{"162":1}}],["即将数据化为二进制进行与运算",{"2":{"155":1}}],["即它们的改变指向",{"2":{"132":1,"140":1}}],["即节点的",{"2":{"130":1,"140":1}}],["即只有",{"2":{"130":1,"140":1}}],["即从要删除的节点的右边开始查找最小的值",{"2":{"81":1,"82":1}}],["即在",{"2":{"81":2}}],["即",{"2":{"80":2,"132":1,"140":1,"142":1,"167":1,"211":1}}],["讨论这样的问题",{"2":{"80":1}}],["种情况",{"2":{"77":1}}],["种跳法",{"2":{"12":2}}],["小一点点的节点",{"2":{"80":1,"81":1}}],["小于",{"2":{"77":1,"82":1}}],["小的值",{"2":{"17":1}}],["小的数字了",{"2":{"17":1}}],["存取时间就依赖后来的探测长度",{"2":{"150":1}}],["存在新的相邻顶点就去访问",{"2":{"119":1}}],["存在右子节点时",{"2":{"79":1}}],["存在左子节点时",{"2":{"79":1}}],["存在返回",{"2":{"76":1,"201":1,"208":1}}],["存储和组织数据的方式",{"2":{"231":1}}],["存储数据",{"2":{"227":1}}],["存储元组",{"2":{"161":1,"171":1}}],["存储效率下降",{"2":{"152":1}}],["存储联系人和对应的电话号码",{"2":{"142":1}}],["存储多个元素",{"2":{"124":1,"125":1}}],["存储边信息",{"2":{"112":1}}],["存储顶点",{"2":{"112":1}}],["存储所有的顶点",{"2":{"108":1}}],["存储",{"2":{"45":1}}],["过程图解",{"2":{"71":1,"72":1}}],["父节点的设置只是为了方便指向子节点",{"2":{"228":1}}],["父节点",{"2":{"224":1}}],["父",{"2":{"71":1,"72":1,"73":1}}],["常见的编程语言都有直接或间接的使用上述常见的数据结构",{"2":{"233":1}}],["常见的数据结构",{"0":{"233":1}}],["常见的情况是",{"2":{"166":1}}],["常见的平衡树",{"2":{"83":1}}],["常见的三种二叉树遍历方式为",{"2":{"69":1}}],["常见的二叉树存储方式为数组和链表",{"2":{"61":1}}],["往栈里面添加元素",{"2":{"215":1}}],["往往先被拿出去使用",{"2":{"210":1}}],["往集合中添加",{"2":{"201":1,"208":1}}],["往哈希表里添加数据",{"2":{"161":1,"171":1}}],["往链表尾部追加数据",{"2":{"130":1,"140":1}}],["往双向链表尾部追加一个新的元素",{"2":{"92":1,"100":1}}],["往左查找",{"2":{"77":1,"82":1}}],["往左边查找插入",{"2":{"68":1}}],["往右边查找插入",{"2":{"68":1}}],["依然没有找到",{"2":{"163":1}}],["依然递归调用",{"2":{"68":1}}],["依赖队列的先进先出的特点",{"2":{"120":1}}],["依赖队列操作数据",{"2":{"120":1}}],["依次进行一次排序",{"2":{"44":1}}],["依次",{"2":{"39":1}}],["依次类推",{"2":{"14":1,"150":1}}],["无强制要求",{"2":{"158":1}}],["无论是插入",{"2":{"148":1}}],["无论多少数据",{"2":{"142":1}}],["无法通过下标值直接访问元素",{"2":{"125":1}}],["无法跳过第一个元素访问任何一个元素",{"2":{"125":1}}],["无权图",{"2":{"105":1}}],["无向图",{"2":{"105":1}}],["无右子节点成功插入",{"2":{"68":1}}],["无右子节点时",{"2":{"68":1}}],["无左子节点时",{"2":{"68":1}}],["与",{"2":{"143":1}}],["与数组的",{"2":{"89":1,"127":1,"182":1,"191":1,"200":1}}],["与先序遍历原理相同",{"2":{"71":1,"72":1}}],["与向左查找类似",{"2":{"68":1}}],["与根节点",{"2":{"65":1}}],["后进先出",{"2":{"210":1}}],["后面会区分",{"2":{"105":1}}],["后面每项的值等于前面两项的和",{"2":{"12":1}}],["后继的情况",{"2":{"81":1}}],["后继",{"0":{"81":1}}],["后原树二叉树仍为二叉搜索树的前提下",{"2":{"80":1}}],["后原二叉树仍为二叉搜索树的前提下",{"2":{"80":2}}],["后分",{"2":{"77":1}}],["后续遍历最后遍历根节点",{"2":{"73":1}}],["后序遍历",{"0":{"72":1},"2":{"69":1,"72":1}}],["后",{"2":{"68":1,"162":1}}],["情况",{"2":{"68":4,"79":6}}],["向下取整",{"2":{"218":1}}],["向一个栈插入新元素又称作进栈",{"2":{"210":1}}],["向集合添加一个新的项",{"2":{"200":1}}],["向队列尾部添加一个",{"2":{"191":1}}],["向字典中添加新元素",{"2":{"182":1}}],["向图中添加一些顶点",{"2":{"114":1}}],["向链表的特定位置插入一个新的项",{"2":{"127":1}}],["向链表的指定位置插入一个新元素",{"2":{"89":1}}],["向链表尾部添加一个新的项",{"2":{"127":1}}],["向链表尾部追加一个新元素",{"2":{"89":1}}],["向右查找",{"2":{"68":1}}],["向左查找",{"2":{"68":1}}],["向树中插入一个新的键",{"2":{"67":1}}],["根据数据的组织方式有关",{"2":{"232":1}}],["根据每个父节点子节点数量的不同",{"2":{"226":1}}],["根据优先级放入到正确位置",{"2":{"174":1}}],["根据传入的元素",{"2":{"176":1}}],["根据传入的",{"2":{"170":1,"171":1}}],["根据装填因子的大小",{"2":{"163":1,"167":1,"170":1,"171":1}}],["根据索引值获取对应的",{"2":{"162":1,"163":1}}],["根据索引值取出",{"2":{"161":1}}],["根据",{"2":{"161":3,"162":2,"163":1,"171":3}}],["根据探测空白单元格位置方式的不同",{"2":{"147":1}}],["根据顶点",{"2":{"115":2}}],["根据不同情况删除元素",{"2":{"95":1,"100":1}}],["根据比较传入的两个节点",{"2":{"68":1}}],["根左右",{"2":{"70":1,"73":1}}],["根节点的值相同",{"2":{"22":1}}],["首先需要为",{"2":{"170":1}}],["首先创建哈希表类",{"2":{"160":1}}],["首先使用霍纳法则计算",{"2":{"158":1}}],["首先计算最内层括号内一次多项式的值",{"2":{"154":1}}],["首先让",{"2":{"130":1}}],["首先依据以下二叉搜索树",{"2":{"80":1}}],["首先定义变量",{"2":{"77":1}}],["首先",{"2":{"70":1,"71":1,"72":1,"148":1,"161":1,"162":1,"163":1,"166":1}}],["首先根据传入的",{"2":{"68":1}}],["首先将第一个位置的数作为枢纽值",{"2":{"42":1}}],["首先将树分解到每一个子节点",{"2":{"41":1}}],["键",{"2":{"67":2}}],["还是中间到杭州的位置",{"2":{"237":1}}],["还应该在合适的时候能够取出来",{"2":{"232":1}}],["还应定义一个节点内部类",{"2":{"66":1}}],["还有其他的方法",{"2":{"200":1}}],["还有层序遍历",{"2":{"69":1}}],["还包含优先级",{"2":{"174":1}}],["还消耗最小",{"2":{"28":1}}],["右节点>的情况",{"2":{"79":1,"82":1}}],["右查找就能得到最值",{"2":{"75":1}}],["右指针",{"2":{"66":1}}],["右子节点的序号等于父节点序号",{"2":{"62":1}}],["右子树中的最小值",{"2":{"80":1}}],["右子树中比",{"2":{"80":1}}],["右子树本身也都是二叉搜索树",{"2":{"64":1}}],["右子树是否相同",{"2":{"22":1}}],["右子树相同",{"2":{"22":1}}],["指向的新数组中",{"2":{"166":1}}],["指向它",{"2":{"166":1}}],["指向原来的",{"2":{"166":1}}],["指向到当前的节点的",{"2":{"136":1,"140":1}}],["指向最后一个节点",{"2":{"130":1}}],["指向第一个节点",{"2":{"130":1}}],["指向新节点",{"2":{"130":1,"140":1}}],["指向链表的第一个节点",{"2":{"129":1,"140":1}}],["指向自己的数量",{"2":{"110":1}}],["指向别人的数量",{"2":{"110":1}}],["指向",{"2":{"88":2,"132":1,"140":1}}],["指向后一个节点",{"2":{"88":1}}],["指向前一个节点",{"2":{"88":1}}],["指向节点的根",{"2":{"66":1}}],["指针指向最后一个节点",{"2":{"88":1}}],["指针指向第一个节点",{"2":{"88":1}}],["指针指向的值小于枢纽值时",{"2":{"42":1}}],["指针指向的值大等于枢纽值时",{"2":{"42":1}}],["指针向后移动",{"2":{"42":2}}],["指针向前移动",{"2":{"42":2}}],["指针时结束循环",{"2":{"42":1}}],["下面只讨论查找",{"2":{"81":1}}],["下面是一个二叉搜索树",{"2":{"65":1}}],["下一步与父节点",{"2":{"65":2}}],["下一步与根节点",{"2":{"65":1}}],["次就可以找到出问题的地方",{"2":{"237":1}}],["次幂的底数等",{"2":{"155":1}}],["次多项式",{"2":{"154":1}}],["次",{"2":{"65":6,"154":4,"237":2}}],["次排序后的结果",{"2":{"40":1}}],["总的来说",{"2":{"223":1}}],["总个数",{"2":{"171":1}}],["总数据项",{"2":{"151":1}}],["总数为",{"2":{"57":2}}],["总结",{"0":{"73":1},"2":{"64":1,"146":1}}],["比如上图的",{"2":{"224":1}}],["比如上图中",{"2":{"105":1}}],["比如节点",{"2":{"224":1,"226":1}}],["比如树结构中数据都是有序的",{"2":{"223":1}}],["比如树三中节点",{"2":{"64":2}}],["比如函数",{"2":{"211":1}}],["比如在电影院",{"2":{"187":1}}],["比如保存一个人的信息",{"2":{"180":1}}],["比如原长度",{"2":{"170":1}}],["比如原二叉搜索树由",{"2":{"83":1}}],["比如从下标值",{"2":{"149":1}}],["比如从下表值",{"2":{"149":1}}],["比如从小到大",{"2":{"142":1}}],["比如插入",{"2":{"148":1}}],["比如设置为",{"2":{"148":1}}],["比如不存在",{"2":{"143":1}}],["比如我们要表示和",{"2":{"110":1}}],["比如村庄的名字",{"2":{"108":1}}],["比如距离或者花费的时间或者票价",{"2":{"105":1}}],["比如地铁站中两个站点之间的直接连线",{"2":{"105":1}}],["比如地铁站中某个站",{"2":{"105":1}}],["比如",{"2":{"104":2,"105":7,"109":1,"124":1,"143":3,"149":1,"152":1,"155":1,"166":1,"181":1,"224":1,"227":1}}],["比如下图中的节点",{"2":{"81":2}}],["比",{"2":{"81":2,"105":1}}],["比较好的二叉搜索树",{"2":{"83":1}}],["比较",{"2":{"65":3}}],["比第一张小",{"2":{"39":1}}],["非平衡树",{"2":{"83":1}}],["非空",{"2":{"120":1}}],["非空右子树的所有键值大于其根节点的键值",{"2":{"64":1}}],["非空左子树的所有键值小于其根节点的键值",{"2":{"64":1}}],["非完全二叉树需要转换成完全二叉树才能按照上面的方案存储",{"2":{"62":1}}],["非完全二叉树",{"2":{"62":1}}],["条件",{"2":{"64":3}}],["取出",{"2":{"180":1}}],["取出所有数据",{"2":{"167":1,"171":1}}],["取出对应的",{"2":{"161":1,"171":1}}],["取出对应的数组",{"2":{"115":2}}],["取决于填装因子",{"2":{"150":1}}],["取余",{"2":{"148":1,"158":1}}],["取数据的时候也十分方便",{"2":{"62":1}}],["取第一个值为枢纽值",{"2":{"42":1}}],["序号",{"2":{"62":2}}],["节点由于没有子节点",{"2":{"226":1}}],["节点需要",{"2":{"226":1}}],["节点上有乘客",{"2":{"126":1}}],["节点的层次为",{"2":{"224":1}}],["节点的层次",{"2":{"224":1}}],["节点的子树个数",{"2":{"224":1}}],["节点的度",{"2":{"224":1}}],["节点的",{"2":{"133":1,"140":1}}],["节点的后继",{"2":{"81":1}}],["节点的前驱",{"2":{"81":1}}],["节点的顺序来区分三种遍历方式",{"2":{"73":1}}],["节点类",{"2":{"66":1}}],["节点中的键",{"2":{"66":1}}],["节点",{"2":{"62":2,"71":1,"72":1,"136":1,"140":1,"227":3}}],["按照类别存放",{"2":{"232":1}}],["按照字母顺序找到位置",{"2":{"232":1}}],["按照书名的拼音字母顺序排放",{"2":{"232":1}}],["按照计数数组",{"2":{"45":1}}],["按顺序进栈",{"2":{"212":1}}],["按从上到下",{"2":{"62":1}}],["缺点",{"2":{"223":3}}],["缺点是改变了元素的类型",{"2":{"1":1}}],["缺失了右子节点",{"2":{"60":1}}],["完全探索一个顶点要求我们便查看该顶点的每一条边",{"2":{"119":1}}],["完全二叉树",{"0":{"60":1},"2":{"60":1,"62":1}}],["完整实现",{"0":{"82":1,"100":1,"140":1}}],["完美二叉树是特殊的完全二叉树",{"2":{"60":1}}],["完美二叉树",{"0":{"59":1},"2":{"59":1}}],["特点",{"2":{"187":1}}],["特殊之处在于里面的元素没有顺序",{"2":{"198":1}}],["特殊情况",{"2":{"173":1}}],["特殊的二叉树",{"0":{"58":1},"1":{"59":1,"60":1}}],["特性",{"2":{"21":1,"22":1,"23":1}}],["满足需求",{"2":{"150":1}}],["满足",{"2":{"57":1}}],["若装填因子",{"2":{"161":1,"167":1,"170":1,"171":1}}],["若使用数组",{"2":{"142":2}}],["若用",{"2":{"80":1}}],["若没找到",{"2":{"77":1}}],["若存在根节点则重新定义一个内部方法",{"2":{"68":1}}],["若想在其中查找数据",{"2":{"65":1}}],["若",{"2":{"57":1,"76":2,"78":2,"224":1}}],["若二叉树不为空",{"2":{"55":1}}],["^",{"2":{"57":1,"62":8}}],["上文所说的线性探测存在的问题",{"2":{"149":1}}],["上一节点为",{"2":{"132":1,"140":1}}],["上图中的边是没有任何意义的",{"2":{"105":1}}],["上图分别表示",{"2":{"56":1}}],["上面的顶点",{"2":{"108":1}}],["上面的图就是一张无向图",{"2":{"105":1}}],["上面的结点",{"2":{"104":1}}],["上帝视角",{"2":{"29":1}}],["修改添加元素的",{"2":{"170":1}}],["修改完",{"2":{"161":1,"171":1}}],["修改节点",{"2":{"135":1,"140":1}}],["修改某个位置的元素",{"2":{"127":1}}],["修改指定位置节点的",{"2":{"135":1,"140":1}}],["修改指定位置的节点",{"2":{"96":1,"100":1}}],["修改指定位置上的元素",{"2":{"89":1}}],["修改指定索引位置的几个元素",{"2":{"52":1}}],["修改指定索引位置的元素",{"2":{"52":1}}],["修改两个元素为",{"2":{"52":1}}],["修改索引",{"2":{"52":1}}],["修改元素",{"0":{"52":1}}],["删除效率都非常高",{"2":{"223":1}}],["删除集合中指定的",{"2":{"201":1,"208":1}}],["删除对应位置的数组项",{"2":{"163":1,"171":1}}],["删除哈希表中特定位置的元素",{"2":{"157":1}}],["删除都会影响",{"2":{"148":1}}],["删除一个数据项时",{"2":{"148":1}}],["删除操作和上述两种情况类似",{"2":{"148":1}}],["删除",{"2":{"95":1,"96":1,"100":2,"142":1}}],["删除最后一个节点的情况",{"2":{"95":1,"100":1}}],["删除第一个节点的情况",{"2":{"95":1,"100":1}}],["删除指定",{"2":{"100":1,"136":1,"137":1,"140":2,"163":1,"171":1}}],["删除指定位置的节点",{"2":{"95":1,"100":1,"136":1,"140":1}}],["删除指定索引位置的元素",{"2":{"51":1}}],["删除等操作时",{"2":{"83":1}}],["删除节点",{"2":{"78":2,"79":4,"80":3,"82":1}}],["删除根节点",{"2":{"78":1,"79":2}}],["删除的是有两个子节点的节点",{"0":{"80":1},"1":{"81":1},"2":{"77":1,"81":1,"82":1}}],["删除的是只有一个子节点的节点",{"0":{"79":1},"2":{"77":1,"78":1,"79":1,"82":1}}],["删除的是叶子节点的情况",{"2":{"78":1,"82":1}}],["删除的是叶子节点分两种情况",{"2":{"78":1}}],["删除的是叶子节点",{"0":{"78":1},"2":{"77":1}}],["删除找到的指定节点",{"2":{"77":1}}],["删除数据",{"0":{"77":1},"1":{"78":1,"79":1,"80":1,"81":1,"82":1}}],["删除数组首位的元素",{"2":{"51":1}}],["删除数组最后的元素",{"2":{"51":1}}],["删除索引",{"2":{"51":1}}],["删除元素",{"0":{"51":1}}],["添加一个新元素到栈顶位置",{"2":{"214":1}}],["添加一个元素到数组的最后位置",{"2":{"50":1}}],["添加到新集合",{"2":{"204":2,"208":2}}],["添加到堆顶",{"2":{"17":1}}],["添加基本属性",{"2":{"129":1}}],["添加边需要传入两个顶点",{"2":{"115":2}}],["添加边",{"0":{"115":1},"2":{"115":1,"117":1}}],["添加点的关系",{"2":{"114":1}}],["添加点",{"2":{"114":1}}],["添加顶点",{"0":{"114":1},"2":{"114":1,"117":1}}],["添加元素",{"0":{"50":1}}],["创建",{"2":{"176":1}}],["创建一个新集合",{"2":{"204":1,"205":1,"206":1,"208":3}}],["创建一个新的容量更大的数组",{"2":{"166":1}}],["创建一个队列",{"2":{"120":1}}],["创建哈希表类",{"0":{"160":1}}],["创建新节点",{"2":{"130":1,"132":1,"140":2}}],["创建新的双向链表节点",{"2":{"93":1,"94":1,"100":1}}],["创建单向链表类",{"0":{"129":1}}],["创建队列",{"2":{"120":1}}],["创建图类",{"0":{"112":1}}],["创建双向链表节点",{"2":{"92":1,"100":1}}],["创建双向链表类",{"0":{"91":1}}],["创建节点对象",{"2":{"68":1}}],["创建数组",{"2":{"48":2}}],["创建和初始化数组",{"0":{"48":1}}],["里数据",{"2":{"161":1,"171":1}}],["里面的每一个元素入队",{"2":{"195":1}}],["里面的",{"2":{"161":1,"171":1}}],["里面节点的情况",{"2":{"95":1,"100":1}}],["里面包含每个节点中的",{"2":{"66":1}}],["里",{"2":{"47":1}}],["然而其中却有许多下标值指向的是无效的数据",{"2":{"143":1}}],["然而插入排序需要的常数时间很小",{"2":{"46":1}}],["然后由内向外逐层计算一次多项式的值",{"2":{"154":1}}],["然后判断根节点是否存在",{"2":{"68":1}}],["然后根据元素出现的次数从小到大依次将元素放入新的数组中",{"2":{"45":1}}],["然后按每个位数分别比较",{"2":{"44":1}}],["然后剩下的元素重新构建为大顶堆",{"2":{"43":1}}],["然后每次划分的时间复杂",{"2":{"42":1}}],["然后将原数组中的元素复制过去",{"2":{"124":1}}],["然后将剩余",{"2":{"43":1}}],["然后将这个值填入",{"2":{"42":2}}],["然后将数组排序合并",{"2":{"41":1}}],["然后",{"2":{"42":2,"44":1,"70":1,"71":1,"72":1,"161":1,"162":1,"163":1,"166":1}}],["然后再按此方法对这两部分数据分别进行快速排序",{"2":{"42":1}}],["然后再用小的数去除以的得到的余数",{"2":{"4":1}}],["然后在递",{"2":{"42":1}}],["然后在逐步增大增量",{"2":{"40":1}}],["然后在同一天出售",{"2":{"29":1}}],["然后继续遍历饼干",{"2":{"28":1}}],["然后调整堆",{"2":{"17":1}}],["来遍历其中的元素",{"2":{"142":1}}],["来赋值",{"2":{"93":1,"94":1,"100":1}}],["来操作一棵树",{"2":{"83":1}}],["来替换当前的节点",{"2":{"80":1}}],["来说",{"2":{"46":1}}],["来解决原来的问题",{"2":{"24":1}}],["系统自带排序实现",{"0":{"46":1}}],["系统会自动报警",{"2":{"26":1}}],["构建已排序数组",{"2":{"45":1}}],["构建大顶堆",{"2":{"43":1}}],["反之则返回",{"2":{"182":1}}],["反向遍历输入数组",{"2":{"45":1}}],["反复循环这个过程",{"2":{"42":1}}],["反复执行",{"2":{"24":1,"25":1,"26":1}}],["累积计数数组",{"2":{"45":1}}],["之后",{"2":{"228":1}}],["之后应该",{"2":{"212":1}}],["之后讨论",{"2":{"166":1}}],["之后得到的下标值",{"2":{"148":1}}],["之后继续在数组或链表中查找就可以了",{"2":{"146":1}}],["之后每组含有的整数越来越多",{"2":{"40":1}}],["之间遍历",{"2":{"132":1,"140":1}}],["之间有边",{"2":{"105":1}}],["之间的关系",{"2":{"104":1}}],["之间的整数",{"2":{"45":1}}],["否则每次探测都是原地踏步的死循环",{"2":{"150":1}}],["否则会影响到之后其他的查询操作",{"2":{"148":1}}],["否则往右查找",{"2":{"77":1,"82":1}}],["否则返回",{"2":{"76":1,"191":1,"200":1,"201":1,"208":1,"214":1}}],["否则使用插入排序",{"2":{"46":1}}],["否则",{"2":{"45":1}}],["\\t",{"2":{"45":2}}],["统一只记录右边的第一个兄弟节点",{"2":{"227":1}}],["统一只记录左边的子节点",{"2":{"227":1}}],["统一为同样的数位长度",{"2":{"44":1}}],["统计元素出现次数并更新",{"2":{"45":1}}],["统计待排序序列中每个元素出现的次数",{"2":{"45":1}}],["确定最大值的位数",{"2":{"44":1}}],["确定排序数组中的最大值",{"2":{"44":1}}],["数中有一个称为根",{"2":{"223":1}}],["数学中常指的集合中的元素是可以重复的",{"2":{"198":1}}],["数字之前的人重新放入到队尾",{"2":{"195":1}}],["数字相加",{"2":{"143":1}}],["数据结构的实现",{"2":{"236":1}}],["数据结构的定义",{"0":{"231":1}}],["数据结构与算法与语言无关",{"2":{"233":1}}],["数据结构与算法分析",{"2":{"231":1}}],["数据结构在生活中应用",{"0":{"232":1}}],["数据结构就是在计算机中",{"2":{"231":1}}],["数据结构是",{"2":{"231":1}}],["数据结构是数据对象",{"2":{"231":1}}],["数据结构",{"2":{"231":2}}],["数据的插入和删除操作效率都很高",{"2":{"223":1}}],["数据",{"2":{"150":1}}],["数列就变成一个有序序列",{"2":{"44":1}}],["数位较短的数前面补零",{"2":{"44":1}}],["数组是一个线性结构",{"2":{"209":1}}],["数组是最简单的内存数据结构",{"2":{"47":1}}],["数组形式",{"2":{"180":1}}],["数组内容",{"2":{"167":1,"171":1}}],["数组每一个下标值对应的位置存储的不再是一个数字了",{"2":{"146":1}}],["数组缺点",{"2":{"124":1}}],["数组常见操作",{"0":{"49":1},"1":{"50":1,"51":1,"52":1}}],["数组中可以保存不同类型的值",{"2":{"47":1}}],["数组中的元素互不相同",{"2":{"32":1}}],["数组",{"0":{"47":1,"124":1,"178":1},"1":{"48":1,"49":1,"50":1,"51":1,"52":1},"2":{"110":1,"124":1,"166":1,"223":1,"233":1}}],["数组长度大于",{"2":{"46":1}}],["数组的创建需要申请一段连续的内存空间",{"2":{"124":1}}],["数组的",{"2":{"33":1,"36":1}}],["数组去重",{"0":{"2":1}}],["数组扁平化",{"0":{"1":1}}],["退出循环",{"2":{"43":1}}],["同时也弥补了它们存在的缺点",{"2":{"223":1}}],["同时返回被移除的元素",{"2":{"214":1}}],["同时将索引值跟新为被替换的值",{"2":{"43":1}}],["同样会影响性能",{"2":{"149":1}}],["同样通过一些特性来保持树的平衡",{"2":{"83":1}}],["同样有两种方式",{"2":{"80":1}}],["同样是",{"2":{"65":1}}],["同样具备",{"2":{"20":1}}],["使其相邻的元素成为新的栈顶元素",{"2":{"210":1}}],["使其满足大顶堆的要求",{"2":{"43":1}}],["使之成为新的栈顶元素",{"2":{"210":1}}],["使用队列实现小游戏",{"2":{"194":1}}],["使用霍纳法则",{"2":{"158":1}}],["使用一个数组来保存",{"2":{"112":1}}],["使用较少",{"2":{"69":1}}],["使用链表时也同样麻烦",{"2":{"142":1}}],["使用链表",{"0":{"63":1},"2":{"142":1}}],["使用数组存储时",{"2":{"62":1}}],["使用数组",{"0":{"62":1}}],["使用",{"2":{"48":2,"218":1}}],["使用桶重新初始化数组",{"2":{"44":1}}],["使用动态规划",{"2":{"25":1}}],["使父节点大于它的子节点",{"2":{"43":1}}],["且小于数组的容量",{"2":{"150":1}}],["且右子元素大于最大值",{"2":{"43":1}}],["且左子元素大于最大值",{"2":{"43":1}}],["且根节点值也相同",{"2":{"23":1}}],["便能得到一个有序序列了",{"2":{"43":1}}],["它具备以下性质",{"2":{"223":1}}],["它是把栈顶元素删除掉",{"2":{"210":1}}],["它是把新元素放到栈顶元素的上面",{"2":{"210":1}}],["它们的性能比线性探测略好",{"2":{"152":1}}],["它存在更多优势",{"2":{"142":1}}],["它必须构造一个",{"2":{"110":1}}],["它通过在每个节点多存储一个额外的数据来保持树的平衡",{"2":{"83":1}}],["它的数据应该是左右均匀分布的",{"2":{"83":1}}],["它的运算效率最高",{"2":{"42":1}}],["它将一个问题分解为相互重叠的子问题",{"2":{"24":1}}],["它将一个问题分成多个和原问题相似的小问题",{"2":{"19":1}}],["划分操作的时间复杂度为",{"2":{"42":1}}],["−1",{"2":{"42":1}}],["归左右两边的的序列",{"2":{"42":1}}],["归并排序的平均时间复杂度为",{"2":{"41":1}}],["归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组",{"2":{"41":1}}],["归并排序是利用归并的思想实现的排序方法",{"2":{"41":1}}],["归并排序",{"0":{"41":1},"2":{"19":1}}],["枢纽值右边的值都比枢纽值大",{"2":{"42":1}}],["进栈出栈",{"2":{"212":6}}],["进栈",{"2":{"212":5}}],["进栈顺序为",{"2":{"212":1}}],["进入下一次循环",{"2":{"42":1}}],["进行封装",{"2":{"197":1}}],["进行删除操作",{"2":{"187":1}}],["进行新增数据操作",{"2":{"161":1}}],["进行取余操作",{"2":{"146":1}}],["进行越界判断",{"2":{"132":1,"140":1}}],["进行插入操作",{"2":{"187":1}}],["进行插入",{"2":{"83":1}}],["进行比较",{"2":{"65":1}}],["进行排序合并",{"2":{"41":1}}],["进行划分",{"2":{"17":1}}],["值越小",{"2":{"176":1}}],["值与之比较",{"2":{"76":1}}],["值为止",{"2":{"42":1}}],["值等于",{"2":{"42":1}}],["值的时候停止",{"2":{"42":2}}],["值",{"2":{"42":2,"201":1,"208":1}}],["临时数组的大小为",{"2":{"41":1}}],["临时变量数组空间复杂度",{"2":{"25":1}}],["截取右半部分",{"2":{"41":1}}],["截取左半部分",{"2":{"41":1}}],["该方法不会移除栈顶的元素",{"2":{"214":1}}],["该方法性能较好",{"2":{"169":1}}],["该函数就称为哈希函数",{"2":{"144":1}}],["该数组用于存储顶点连接的所有的边",{"2":{"114":1}}],["该整数作为数组的下标值",{"2":{"109":1}}],["该属性指向末尾的节点",{"2":{"91":1}}],["该属性用于指向上一个节点",{"2":{"91":1}}],["该算法采用经典的分治策略",{"2":{"41":1}}],["该位置以后的序列都是已排好的序列",{"2":{"37":1}}],["但需要注意的是",{"2":{"148":1}}],["但它神奇之处在于对下标值的一种变换",{"2":{"142":1}}],["但并未被探索过",{"2":{"119":2}}],["但回到前一个节点很难",{"2":{"86":1}}],["但在",{"2":{"47":1}}],["但总的来说时间复杂度是小于",{"2":{"40":1}}],["但是好的算法对比于差的算法",{"2":{"237":1}}],["但是如果线段在另一头",{"2":{"237":1}}],["但是如果是较长的字符",{"2":{"143":1}}],["但是这样父节点不是变了吗",{"2":{"228":1}}],["但是这种方式会存在这样的问题",{"2":{"143":1}}],["但是有时候",{"2":{"209":1}}],["但是计算机中集合的元素不能重复",{"2":{"198":1}}],["但是效率不高",{"2":{"169":1}}],["但是该位置已经放置了数据",{"2":{"148":1}}],["但是可以通过其他方式解决",{"2":{"143":1}}],["但是相对于数组",{"2":{"142":1}}],["但是回到前一个节点是很难的",{"2":{"125":1}}],["但是链表和数组的实现机制完全不同",{"2":{"123":1}}],["但是它的整体效率不如红黑树",{"2":{"83":1}}],["但是插入连续数据后",{"2":{"83":1}}],["但是在数据量很小的情况下和",{"2":{"46":1}}],["但是在希尔排序中",{"2":{"40":1}}],["但是由于这些数也越来越有序",{"2":{"40":1}}],["但是",{"2":{"28":1,"87":1,"155":2,"166":1}}],["但是增加空间复杂度为",{"2":{"15":1}}],["所谓合适的位置指的是空的位置",{"2":{"148":1}}],["所表示的数字就非常大",{"2":{"143":1}}],["所在的节点",{"2":{"100":1,"137":1}}],["所占内存空间更大一些",{"2":{"87":1}}],["所以错误",{"2":{"212":1}}],["所以当前栈的顺序为",{"2":{"211":1}}],["所以当排序序列有序的时候",{"2":{"42":1}}],["所以采用",{"2":{"195":1}}],["所以这个哈希表可以无限制地插入新数据",{"2":{"166":1}}],["所以这里不考虑方向问题",{"2":{"115":1}}],["所以我们使用",{"2":{"155":1}}],["所以哈希函数不能采用消耗性能较高的复杂算法",{"2":{"153":1}}],["所以该方式不合理",{"2":{"143":1}}],["所以查找起来十分麻烦",{"2":{"142":1}}],["所以不需要引用",{"2":{"226":1}}],["所以不能以一种固定的方式",{"2":{"142":1}}],["所以不是二叉树",{"2":{"64":1}}],["所以边是可以双向的",{"2":{"115":1}}],["所以表示起来会稍微麻烦一些",{"2":{"108":1}}],["所以平衡树的应用基本都是红黑树",{"2":{"83":1}}],["所以它的时间复杂度也是",{"2":{"83":1}}],["所以它不是完全二叉树",{"2":{"60":1}}],["所以遍历方式有多种选择",{"2":{"69":1}}],["所以",{"2":{"65":3,"66":1}}],["所以相对别的排序来说更快",{"2":{"46":1}}],["所以最好的时候为",{"2":{"42":1}}],["所以最坏",{"2":{"42":1}}],["所以最优的时间复杂度为",{"2":{"42":1}}],["所以归",{"2":{"41":1}}],["所以归并排序的时间复杂度不管在什么情况下都为",{"2":{"41":1}}],["所以递归的深度为",{"2":{"41":1}}],["所以希尔排序是一个不稳定的排序",{"2":{"40":1}}],["所以可能会造成相同元素位置的变化",{"2":{"40":1}}],["所以排序速度也很快",{"2":{"40":1}}],["所以排序很快",{"2":{"40":1}}],["所以能够最大化插入排序的优点",{"2":{"40":1}}],["所以每一次都可以看做是一个基本排序的序列",{"2":{"40":1}}],["所有的未被访问过的邻接点",{"2":{"120":1}}],["所有子集",{"2":{"32":1}}],["所有排列情况",{"2":{"31":1}}],["相等",{"2":{"161":1,"171":1}}],["相同",{"2":{"148":1}}],["相同的树",{"0":{"22":1}}],["相连",{"2":{"120":1}}],["相邻顶点",{"2":{"105":1}}],["相处腾出",{"2":{"93":1,"94":1,"100":1}}],["相对地",{"2":{"210":1}}],["相对数组效率高很多",{"2":{"125":1}}],["相对于双向链表的便利性而言",{"2":{"87":1}}],["相对于单向链表",{"2":{"87":1}}],["相对较大的值总是保存在右节点上",{"2":{"64":1}}],["相当于删除了当前节点",{"2":{"136":1,"140":1}}],["相当于编写了一个链表",{"2":{"83":1}}],["相当于将插入排序的",{"2":{"40":1}}],["相信你已经发现其中的规律了",{"2":{"80":1}}],["相差无几",{"2":{"46":1}}],["算法案例",{"0":{"237":1}}],["算法通俗理解",{"0":{"236":1}}],["算法",{"0":{"235":1}}],["算法与应用",{"2":{"231":1}}],["算法便终止",{"2":{"40":1}}],["算法设计思想",{"0":{"18":1},"1":{"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1}}],["随便放",{"2":{"232":1}}],["随后",{"2":{"162":1,"163":1,"211":1}}],["随后放置在该索引值的位置",{"2":{"161":1}}],["随着数据量的增多",{"2":{"166":1}}],["随着装填因子的变大",{"2":{"152":1}}],["随着装填因子的增大",{"2":{"152":1}}],["随着装填因子变小",{"2":{"152":1}}],["随着填装因子变大",{"2":{"150":1}}],["随着增量逐渐减少",{"2":{"40":1}}],["随机选择一个数字",{"2":{"20":1}}],["希尔排序的平均时间复杂度为",{"2":{"40":1}}],["希尔排序的时间复杂度根据选择的增量序列不同而不同",{"2":{"40":1}}],["希尔排序",{"0":{"40":1}}],["保存余数",{"2":{"218":1}}],["保存旧的",{"2":{"167":1,"171":1}}],["保存要找到的后续",{"2":{"81":1,"82":1}}],["保存",{"2":{"77":1}}],["保存最大值的索引",{"2":{"43":1}}],["保存当前需要排序的元素",{"2":{"39":1}}],["保证接的数字都是后面的数字",{"2":{"32":1}}],["可通过下标值取出信息",{"2":{"180":1}}],["可分为三种方法",{"2":{"147":1}}],["可能是最常用的数据结构",{"2":{"124":1}}],["可能是中间数",{"2":{"39":1}}],["可知节点",{"2":{"80":6}}],["可以快速定位到处问题的地方",{"2":{"237":1}}],["可以在数组的任意位置插入和删除元素",{"2":{"209":1}}],["可以直接使用",{"2":{"195":1}}],["可以重复",{"2":{"180":1}}],["可以大于",{"2":{"166":1}}],["可以看到随着装填因子的增加",{"2":{"152":1}}],["可以看到",{"2":{"152":1}}],["可以充分利用计算机的内存",{"2":{"125":1}}],["可以用于存储一系列的元素",{"2":{"123":1}}],["可以指定顶点和顶点之间的边",{"2":{"115":1}}],["可以另外创建一个数组",{"2":{"108":1}}],["可以轻松到达下一个节点",{"2":{"86":1}}],["可以通过下标值访问",{"2":{"223":1}}],["可以通过取余操作来实现",{"2":{"143":1}}],["可以通过",{"2":{"78":2,"180":1}}],["可以通过二分查找",{"2":{"65":1}}],["可以通过分解质因数并计算两数的最大公约数",{"2":{"5":1}}],["可以为空",{"2":{"64":1}}],["放入栈中",{"2":{"218":1}}],["放左边",{"2":{"39":1}}],["放哪里无所谓",{"2":{"39":1}}],["插入或删除的效率都不高",{"2":{"223":1}}],["插入或修改操作",{"2":{"157":1}}],["插入和删除值都只需接近常量的时间",{"2":{"142":1}}],["插入节点",{"2":{"132":2,"140":2}}],["插入元素",{"2":{"93":1,"94":1,"100":1}}],["插入数据",{"0":{"68":1},"2":{"68":1}}],["插入",{"2":{"50":1,"83":1,"142":1,"148":1,"232":1}}],["插入到前面已经排好序的有序序列中去",{"2":{"39":1}}],["插入排序是一个稳定排序",{"2":{"40":1}}],["插入排序的平均时间复杂度为",{"2":{"39":1}}],["插入排序核心是扑克牌思想",{"2":{"39":1}}],["插入排序",{"0":{"39":1}}],["设置其计数为",{"2":{"45":1}}],["设置当前循环最小元素索引",{"2":{"38":1}}],["设置最后一次交换元素的位置",{"2":{"37":1}}],["直至数组剩下一个元素",{"2":{"194":1}}],["直接从队列中删除",{"2":{"195":1}}],["直接从变换前的",{"2":{"154":1}}],["直接添加",{"2":{"176":1}}],["直接",{"2":{"162":1}}],["直接指向",{"2":{"126":1}}],["直接通过",{"2":{"78":1}}],["直接插入",{"2":{"68":2}}],["直接把新节点作为二叉搜索树的根节点",{"2":{"68":1}}],["直接返回对应的",{"2":{"162":1}}],["直接返回",{"2":{"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"162":1,"163":1}}],["直到是为止",{"2":{"170":1}}],["直到节点为",{"2":{"97":1,"98":1,"100":2,"131":1,"140":1}}],["直到找到目标数据为止",{"2":{"223":1}}],["直到找到目标值或者遍历完数组",{"2":{"10":1}}],["直到找到要插入的位置",{"2":{"132":1,"140":1}}],["直到找到对应的元素",{"2":{"125":1}}],["直到找到或查找到",{"2":{"76":1}}],["直到遇到传入",{"2":{"68":1}}],["直到遇到无左子节点成功插入",{"2":{"68":1}}],["直到成功插入新节点为止",{"2":{"68":1}}],["直到",{"2":{"42":1}}],["直到其中一个数组的元素全部加入完则停止",{"2":{"41":1}}],["直到插完所有元素为止",{"2":{"39":1}}],["直到所有元素排完为止",{"2":{"38":1}}],["直到问题解决",{"2":{"30":1}}],["直到数组遍历完成",{"2":{"17":1}}],["直到余数为",{"2":{"4":1}}],["那这个变量存储的就是当前最小元素的下标",{"2":{"38":1}}],["那么",{"2":{"224":1}}],["那么就是修改操作",{"2":{"161":1}}],["那么就是插入操作",{"2":{"161":1}}],["那么就把",{"2":{"143":1}}],["那么效率就会更高",{"2":{"150":1}}],["那么线性探测就是按照下标值",{"2":{"149":1}}],["那么新插入的一个数据可能需要探测很长的距离",{"2":{"149":1}}],["那么是一件非常麻烦的事情",{"2":{"110":1}}],["那么矩阵中将存在大量的",{"2":{"109":1}}],["那么这种情况下会造成空间的浪费",{"2":{"109":1}}],["那么这些",{"2":{"108":1}}],["那么说明这条边可以保证",{"2":{"105":1}}],["那么两者满足关系",{"2":{"57":1}}],["那么我们可以通过",{"2":{"110":1}}],["那么我们则将最大值与其交换",{"2":{"17":1}}],["那么我们已经找到了前",{"2":{"17":1}}],["那么枢纽值和它前面的所有数字就是最小的",{"2":{"17":1}}],["为递归函数",{"2":{"211":1}}],["为什么没有停止条件的递归会造成栈溢出",{"2":{"211":1}}],["为什么需要扩容",{"2":{"166":1}}],["为",{"2":{"129":1,"130":1,"132":1,"140":3,"143":4}}],["为了提供效率",{"2":{"155":1}}],["为了方便理解我们创建这样一套编码系统",{"2":{"143":1}}],["为了把字符串转化为对应的下标值",{"2":{"143":1}}],["为了记录顶点是否被访问过",{"2":{"119":1}}],["为了保证算法的效率",{"2":{"119":1}}],["为了能够正确的显示图的结果",{"2":{"116":1}}],["为了能以较快的时间",{"2":{"83":1}}],["为父节点",{"2":{"79":4}}],["为根节点",{"2":{"79":2}}],["为止",{"2":{"68":1,"76":1}}],["为度为",{"2":{"57":1}}],["为叶子节点",{"2":{"57":1}}],["为最大元素的长度",{"2":{"44":1}}],["为最好的时间复杂度",{"2":{"39":1}}],["为最好的时间复杂度为",{"2":{"37":1}}],["为每一趟从待排序的数据元素中选择最小",{"2":{"38":1}}],["选择质数作为哈希表容量",{"0":{"168":1},"1":{"169":1,"170":1}}],["选择插入排序是因为虽然时间复杂度很差",{"2":{"46":1}}],["选择排序的平均时间复杂度为",{"2":{"38":1}}],["选择排序",{"0":{"38":1}}],["选基准把数组分成两个子数组",{"2":{"19":1}}],["是计算机中存储",{"2":{"231":1}}],["是节点",{"2":{"224":1}}],["是否等于传入的",{"2":{"162":1}}],["是否为",{"2":{"77":1,"162":1,"163":1}}],["是质数",{"2":{"150":1,"170":1}}],["是比较简单的",{"2":{"110":1}}],["是",{"2":{"109":1,"112":1,"195":1,"224":1}}],["是一种运算受限的线性表",{"2":{"187":1,"210":1}}],["是一条简单路径",{"2":{"105":1}}],["是一个正读和反读都一样的字符串",{"2":{"7":1}}],["是不能重复且无序的",{"2":{"180":1}}],["是不能使用树来表示",{"2":{"104":1}}],["是不允许重复的",{"2":{"142":1}}],["是不相邻的",{"2":{"105":1}}],["是相邻的",{"2":{"105":2}}],["是最早的一种平衡树",{"2":{"83":1}}],["是稳定排序",{"2":{"37":1,"39":1,"41":1,"44":1,"45":1}}],["外层循环的优化",{"2":{"37":1}}],["浮",{"2":{"37":1}}],["顺序相反则进行交换",{"2":{"37":1}}],["顺序搜索",{"0":{"34":1}}],["冒泡排序的平均时间复杂度为",{"2":{"37":1}}],["冒泡排序",{"0":{"37":1}}],["把书架划分成几块区域",{"2":{"232":1}}],["把另一端称为栈底",{"2":{"210":1}}],["把",{"2":{"195":1}}],["把关键字用另一个哈希函数",{"2":{"150":1}}],["把大数字进行哈希化的代码实现放在一个函数中",{"2":{"144":1}}],["把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中",{"2":{"143":1}}],["把数组按下标的一定增量分组",{"2":{"40":1}}],["把数组从中间一分为二",{"2":{"19":1}}],["把某个乱序的数组变成升序或者降序的数组",{"2":{"36":1}}],["就将新插入的元素插入到最后",{"2":{"176":1}}],["就执行后续操作",{"2":{"161":1}}],["就修改该值",{"2":{"161":1}}],["就知道要继续查找",{"2":{"148":1}}],["就停止",{"2":{"148":1}}],["就直接返回",{"2":{"148":1}}],["就像一次访问图的一层",{"2":{"120":1}}],["就是",{"2":{"224":1}}],["就是聚集",{"2":{"148":1}}],["就是用幂的连乘来表示它的唯一性的",{"2":{"143":1}}],["就是先宽后深的访问顶点",{"2":{"120":1}}],["就是拿出二维数组的每一项",{"2":{"116":1}}],["就是一个集合类",{"2":{"199":1}}],["就是一个边",{"2":{"105":1}}],["就是一条路径",{"2":{"105":1}}],["就是节点",{"2":{"81":2}}],["就需要重写继承自",{"2":{"89":1,"127":1}}],["就会越来越长",{"2":{"166":1}}],["就会变成深度过大的搜索二叉树",{"2":{"83":1}}],["就会造成二叉搜索树的深度过大",{"2":{"83":1}}],["就向右查找",{"2":{"76":1}}],["就依次往后移动位置",{"2":{"39":1}}],["就插在中间",{"2":{"39":1}}],["就想着自己在打扑克牌",{"2":{"39":1}}],["就返回它的下标",{"2":{"34":1}}],["就回溯",{"2":{"31":1}}],["就回溯并选择另一个动作",{"2":{"30":1}}],["搜索",{"0":{"33":1},"1":{"34":1,"35":1},"2":{"64":1}}],["收集所有到达递归终点的情况",{"2":{"32":1}}],["收集所有到达递归的情况",{"2":{"31":1}}],["长度相等就返回",{"2":{"31":1}}],["返回以字符串形式的栈内元素数据",{"2":{"215":1}}],["返回栈里的元素个数",{"2":{"214":1}}],["返回栈顶的元素",{"2":{"214":1}}],["返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合",{"2":{"203":1}}],["返回一个包含两个集合中共有元素的新集合",{"2":{"203":1}}],["返回一个包含两个集合中所有元素的新集合",{"2":{"203":1}}],["返回一个包含集合中所有值的数组",{"2":{"200":1}}],["返回集合所包含元素的数量",{"2":{"200":1}}],["返回这个人在原数组中对应的索引",{"2":{"195":1}}],["返回删除的那个元素",{"2":{"192":1}}],["返回删除的元素",{"2":{"176":1}}],["返回队列包含的元素个数",{"2":{"191":1}}],["返回队列中的第一个元素",{"2":{"191":1}}],["返回字典所包含元素的数量",{"2":{"182":1}}],["返回哈希表包含的元素个数",{"2":{"157":1}}],["返回指定",{"2":{"134":1,"140":1}}],["返回反向遍历的节点的字符串形式",{"2":{"89":1}}],["返回正向遍历节点字符串形式",{"2":{"89":1}}],["返回链表包含的元素个数",{"2":{"89":1,"127":1}}],["返回元素在链表中的索引",{"2":{"89":1,"127":1}}],["返回",{"2":{"77":1,"82":1,"89":1,"127":1,"133":1,"134":1,"140":2,"157":1,"163":1,"184":2,"191":1,"200":1,"201":1,"207":1,"208":2}}],["返回树中最大的值",{"2":{"67":1}}],["返回树中最小的值",{"2":{"67":1}}],["返回中间索引值",{"2":{"42":1}}],["返回该数组所有可能的子集",{"2":{"32":1}}],["返回函数",{"2":{"31":1}}],["返回你能获得的最大利润",{"2":{"29":1}}],["遇到包含重复元素的情况",{"2":{"31":1}}],["全排列",{"0":{"31":1}}],["通常删除一个位置的数据项时",{"2":{"148":1}}],["通常情况下当装填因子",{"2":{"167":1}}],["通常情况下",{"2":{"142":1,"231":1}}],["通常使用",{"2":{"109":1}}],["通常表示有向",{"2":{"104":1}}],["通常表示无向",{"2":{"104":1}}],["通常用",{"2":{"104":2}}],["通常需要递归模拟所有的路",{"2":{"30":1}}],["通过键值查找特定的数值并返回",{"2":{"182":1}}],["通过使用键值来从字典中移除键值对应的数据值",{"2":{"182":1}}],["通过哈希函数获取它在",{"2":{"162":1,"163":1}}],["通过哈希函数获取",{"2":{"161":1,"171":1}}],["通过哈希函数可以获取",{"2":{"142":1}}],["通过取余操作实现哈希化",{"2":{"158":1}}],["通过以下案例了解哈希表",{"2":{"142":1}}],["通过循环调用",{"2":{"170":1}}],["通过循环遍历",{"2":{"136":1,"140":1}}],["通过循环而不是递归的方式来实现",{"2":{"11":1}}],["通过将顶点存入栈中",{"2":{"119":1}}],["通过这种算法来访问某个顶点的数据以及它对应的边",{"2":{"118":1}}],["通过二维数组",{"2":{"109":1}}],["通过下图来了解图的术语",{"2":{"105":1}}],["通过",{"2":{"76":1,"130":1}}],["通过递归实现",{"2":{"76":1}}],["通过递归来实现",{"2":{"1":1}}],["通过后序遍历方式遍历所有节点",{"2":{"67":1}}],["通过中序遍历方式遍历所有节点",{"2":{"67":1}}],["通过先序遍历方式遍历所有节点",{"2":{"67":1}}],["通过一趟排序将要排序的数据分割成独立的两部分",{"2":{"42":1}}],["通过反复求解子问题",{"2":{"24":1}}],["通过观察",{"2":{"16":1}}],["也称为叶子节点",{"2":{"224":1}}],["也称为二叉排序树和二叉查找树",{"2":{"64":1}}],["也被压入栈",{"2":{"211":1}}],["也不能重复",{"2":{"198":1}}],["也将是最先被移除的元素",{"2":{"191":1}}],["也浪费很多时间",{"2":{"109":1}}],["也有一个向后连接的引用",{"2":{"87":1}}],["也有两种方式",{"2":{"80":1}}],["也有出路",{"2":{"30":1}}],["也可以实现哈希表容量的压缩",{"2":{"167":1}}],["也可以使用不同的探测序列",{"2":{"150":1}}],["也可以使用递归",{"2":{"121":1}}],["也可以抽象成",{"2":{"108":1}}],["也可以保证",{"2":{"105":1}}],["也可以是无向的",{"2":{"104":1}}],["也可以从尾遍历到头",{"2":{"87":1}}],["也可以采用循环来实现",{"2":{"76":1}}],["也可以跳上",{"2":{"12":1}}],["也就是说",{"2":{"142":1}}],["也就是",{"2":{"109":1}}],["也就是顶点到自己的连线",{"2":{"109":1}}],["也就是没有节点",{"2":{"55":1}}],["也就不再调用",{"2":{"68":1}}],["也成为满二叉树",{"2":{"59":1}}],["回顾邻接表的实现方式",{"2":{"114":1}}],["回路",{"2":{"105":1}}],["回溯算法会先从一个可能的动作开始解问题",{"2":{"30":1}}],["回溯算法是一种渐进式寻找构建问题解决的策略",{"2":{"30":1}}],["回溯算法是算法设计的一种方法",{"2":{"30":1}}],["回溯算法",{"0":{"30":1},"1":{"31":1,"32":1}}],["回文字符串",{"2":{"7":1}}],["用",{"2":{"223":1}}],["用的不多",{"2":{"200":1}}],["用这次哈希化的结果作为该关键字的步长",{"2":{"150":1}}],["用于存储所有的边",{"2":{"112":1}}],["用于存储所有的顶点",{"2":{"112":1}}],["用于存储对应的其他数据",{"2":{"108":1}}],["用于保存不同的元素",{"2":{"142":1}}],["用于保存它的父节点",{"2":{"77":1}}],["用于保存需要删除的节点",{"2":{"77":1}}],["用于查找插入点",{"2":{"68":1}}],["用递归模拟出所有情况",{"2":{"32":1}}],["用来统计总利润",{"2":{"29":1}}],["用大的数去除以小的那个数",{"2":{"4":1}}],["见差不动",{"2":{"29":1}}],["见好就收",{"2":{"29":1}}],["知道未来的价格",{"2":{"29":1}}],["股票",{"2":{"29":1}}],["天的价格",{"2":{"29":1}}],["其余节点可分为",{"2":{"223":1}}],["其他任一节点的层数是其父节点的层数加",{"2":{"224":1}}],["其他方法的实现",{"0":{"99":1}}],["其他各层的节点数都达到了最大值",{"2":{"60":1}}],["其原理是将整数按位数切割成不同的数字",{"2":{"44":1}}],["其实是一个对称图",{"2":{"109":1}}],["其实图中叫顶点",{"2":{"104":1}}],["其实",{"2":{"65":1,"228":1}}],["其实我们很容易发现",{"2":{"38":1}}],["其实有很多的计算过程其实是重复的",{"2":{"15":1}}],["其中每个集合本身又是一棵树",{"2":{"223":1}}],["其中一部分的所有数据都比另外一部分的所有数据都要小",{"2":{"42":1}}],["其中",{"2":{"29":1,"150":1}}],["三个属性",{"2":{"66":1}}],["三",{"2":{"28":1}}],["找出数组中某个元素的下标",{"2":{"33":1}}],["找出其中最小的",{"2":{"17":1}}],["找到对应位置的",{"2":{"163":1,"171":1}}],["找到指定",{"2":{"135":1,"136":1,"140":2}}],["找到",{"2":{"110":1}}],["找到要插入位置的节点",{"2":{"93":1,"94":1,"100":1}}],["找到后续节点",{"2":{"81":1,"82":1}}],["找到最后都没找到相等的节点",{"2":{"77":1,"82":1}}],["找到中间索引值",{"2":{"41":1}}],["找到目标的元素",{"2":{"34":1}}],["找到满足第二",{"2":{"28":1}}],["找到能满足第一个孩子的饼干",{"2":{"28":1}}],["遍历到的元素为指定数字",{"2":{"194":1}}],["遍历完所有的",{"2":{"207":1,"208":1}}],["遍历完",{"2":{"162":1}}],["遍历所有顶点",{"2":{"121":1}}],["遍历所有的节点",{"2":{"97":1,"98":1,"100":2,"131":1,"140":1}}],["遍历的注意点",{"2":{"119":1}}],["遍历的方式",{"0":{"119":1}}],["遍历第一行即可",{"2":{"109":1}}],["遍历根",{"2":{"71":1,"72":1}}],["遍历根节点",{"2":{"70":1}}],["遍历其右子树",{"2":{"70":1,"71":1,"72":1}}],["遍历其左子树",{"2":{"70":1,"71":1,"72":1}}],["遍历数据",{"0":{"69":1},"1":{"70":1,"71":1,"72":1,"73":1}}],["遍历数组",{"2":{"34":1}}],["遍历",{"2":{"45":1,"163":1,"167":1,"169":1,"171":2}}],["遍历输入数组",{"2":{"45":1}}],["遍历价格数组",{"2":{"29":1}}],["遍历饼干数组",{"2":{"28":1}}],["遍历判断单词出现次数",{"2":{"9":1}}],["胃口最小",{"2":{"28":1}}],["局部最优",{"2":{"28":1,"29":1}}],["想要给你的孩子们一些小饼干",{"2":{"28":1}}],["期盼通过每个阶段的局部最优选择",{"2":{"27":1}}],["贪心算法是算法设计中的一种方法",{"2":{"27":1}}],["贪心算法",{"0":{"27":1},"1":{"28":1,"29":1}}],["给火车加上数据后的结构",{"2":{"126":1}}],["给该顶点创建一个数组",{"2":{"114":1}}],["给定一个代表每个房屋存放金额的非负整数数组",{"2":{"26":1}}],["给你一个整数数组",{"2":{"29":1,"32":1}}],["给你一个二叉树的根节点",{"2":{"23":1}}],["给你两棵二叉树的根节点",{"2":{"22":1}}],["影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统",{"2":{"26":1}}],["计数",{"2":{"45":1}}],["计数排序的平均时间复杂度",{"2":{"45":1}}],["计数排序是一种稳定的排序算法",{"2":{"45":1}}],["计数排序",{"0":{"45":1}}],["计划偷窃沿街的房屋",{"2":{"26":1}}],["计算机中存储的数据量相对于图书馆的书籍来说数据量更大",{"2":{"232":1}}],["计算机中数据量非常庞大",{"2":{"232":1}}],["计算机打印多个文件的时候",{"2":{"189":1}}],["计算",{"2":{"158":1}}],["计算你",{"2":{"26":1}}],["计算中间元素",{"2":{"20":1}}],["计算最小公倍数",{"2":{"5":1}}],["计算最大公约数",{"2":{"5":1}}],["空格为",{"2":{"143":1}}],["空间利用率高",{"2":{"223":1}}],["空间利用率不高",{"2":{"223":1}}],["空间",{"2":{"93":1,"94":1,"100":1}}],["空间复杂度",{"2":{"20":1,"21":1,"22":1,"23":1,"45":1}}],["空间复杂度为递归的深度",{"2":{"14":1}}],["空间复杂度为",{"2":{"11":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1}}],["空的二叉树",{"2":{"56":1}}],["空数组改为两个变量",{"2":{"25":1}}],["阶爬",{"2":{"25":2}}],["阶可以在第",{"2":{"25":1}}],["阶你才能到达楼顶",{"2":{"25":1}}],["爬到第",{"2":{"25":1}}],["爬楼梯问题",{"0":{"25":1},"2":{"13":1}}],["你会发现",{"2":{"237":1}}],["你可以按任意顺序返回解集",{"2":{"32":1}}],["你可以决定是否购买和",{"2":{"29":1}}],["你也可以先购买",{"2":{"29":1}}],["你在任何时候",{"2":{"29":1}}],["你的目标是尽可能满足越多数量的孩子",{"2":{"28":1}}],["你是一个专业的小偷",{"2":{"26":1}}],["你有多少种不同的方法可以爬到楼顶呢",{"2":{"25":1}}],["你猜测的数字比我选出的数字是大了还是小了",{"2":{"20":1}}],["或多个",{"2":{"191":1}}],["或大于链表长度",{"2":{"132":1,"140":1}}],["或列表",{"2":{"124":1}}],["或两个机场间的距离",{"2":{"106":1}}],["或者两种颜色也可以",{"2":{"119":1}}],["或者什么样的数据使用图来模拟更合适呢",{"2":{"104":1}}],["或者在第",{"2":{"25":1}}],["或最大",{"2":{"38":1}}],["或出售股票",{"2":{"29":1}}],["或",{"2":{"25":1,"218":1}}],["需要多少次可以排查完呢",{"2":{"237":1}}],["需要大量的位移操作",{"2":{"223":1}}],["需要排队打印",{"2":{"189":1}}],["需要探测的次数也呈指数形式增长",{"2":{"152":1}}],["需要有一套编码系统",{"2":{"143":1}}],["需要从头开始依次查找",{"2":{"223":1}}],["需要从头开始一个个访问",{"2":{"125":1}}],["需要从头开始访问",{"2":{"125":1}}],["需要进行大量元素的位移",{"2":{"124":1}}],["需要扩容",{"2":{"124":1}}],["需要通过某种算法来遍历图结构中每一个数据",{"2":{"118":1}}],["需要在",{"2":{"81":1}}],["需要查询",{"2":{"65":1}}],["需要",{"2":{"25":1,"226":1}}],["树种所有节点中的最大层次是这棵树的深度",{"2":{"224":1}}],["树结构的组成方式类似于链表",{"2":{"226":1}}],["树结构的表示方式",{"0":{"225":1},"1":{"226":1,"227":1,"228":1}}],["树结构的优势",{"0":{"223":1}}],["树结构综合了上述三种结构的优点",{"2":{"223":1}}],["树结构",{"2":{"223":2}}],["树结构对比于数组",{"2":{"223":1}}],["树枝的最后是叶子",{"2":{"222":1}}],["树枝会继续分化成更小的树枝",{"2":{"222":1}}],["树干会发生分叉",{"2":{"222":1}}],["树一般都有一个根",{"2":{"222":1}}],["树一不满足条件",{"2":{"64":1}}],["树有很多的其他术语",{"2":{"105":1}}],["树是图的一种",{"2":{"104":1}}],["树是平衡树",{"2":{"83":1}}],["树的深度",{"2":{"224":1}}],["树的所有节点中最大的度数",{"2":{"224":1}}],["树的度",{"2":{"224":1}}],["树的常用术语",{"0":{"224":1}}],["树的特点",{"0":{"222":1}}],["树的平衡性",{"2":{"83":1}}],["树的每一层都是一个归并排序的过程",{"2":{"41":1}}],["树二和树三符合",{"2":{"64":1}}],["树",{"0":{"220":1},"1":{"221":1,"222":1,"223":1,"224":1,"225":1,"226":1,"227":1,"228":1},"2":{"23":3,"83":2,"223":1,"233":1}}],["树就相同",{"2":{"22":1}}],["左节点>的情况",{"2":{"79":1,"82":1}}],["左节点的引用和右节点的引用",{"2":{"63":1}}],["左根右",{"2":{"71":1,"73":1}}],["左指针",{"2":{"66":1}}],["左",{"2":{"64":1}}],["左子树中的最大值",{"2":{"80":1}}],["左子树中比",{"2":{"80":1}}],["左子树相同",{"2":{"22":1}}],["左子节点的序号等于父节点序号",{"2":{"62":1}}],["左右根",{"2":{"72":1,"73":1}}],["左右两个数组的元素依次比较",{"2":{"41":1}}],["左右子树是否为镜像",{"2":{"23":1}}],["检查它是否轴对称",{"2":{"23":1}}],["编写一个函数来检验这两棵树是否相同",{"2":{"22":1}}],["qadj",{"2":{"120":3}}],["qval",{"2":{"120":5}}],["quot",{"2":{"180":10}}],["queueelement",{"2":{"176":8,"177":8}}],["queue",{"2":{"120":6,"176":6,"187":1,"192":1,"193":14,"195":9,"233":1}}],["quicksort",{"2":{"42":4}}],["quickselect",{"2":{"17":2}}],["q",{"2":{"22":7,"120":4,"232":1}}],["考虑使用回溯算法",{"2":{"32":1}}],["考虑回溯算法",{"2":{"31":1}}],["考虑动态规划",{"2":{"26":1}}],["考虑分而治之",{"2":{"21":1}}],["考虑选择分而治之",{"2":{"20":1,"22":1,"23":1}}],["符合入栈顺序",{"2":{"212":1}}],["符合要求",{"2":{"80":6}}],["符合",{"2":{"21":1,"22":1,"23":1}}],["翻转二叉树",{"0":{"21":1}}],["我会告诉你",{"2":{"20":1}}],["我都会从",{"2":{"20":1}}],["我们不仅仅要把书放进入",{"2":{"232":1}}],["我们知道",{"2":{"232":1}}],["我们知道树可以用来模拟很多现实的数据结构",{"2":{"104":1}}],["我们为了实现某些功能",{"2":{"209":1}}],["我们已经有办法处理映射到相同下标值的情况",{"2":{"155":1}}],["我们只能解决冲突",{"2":{"145":1}}],["我们通常会将单词转化成大数字",{"2":{"144":1}}],["我们平时使用的大于",{"2":{"143":1}}],["我们也必须遍历一行来找出这个边",{"2":{"109":1}}],["我们用一个二维数组来表示顶点之间的连接",{"2":{"109":1}}],["我们使用三种颜色来反应它们的状态",{"2":{"119":1}}],["我们使用",{"2":{"108":1}}],["我们抽象成了",{"2":{"108":1}}],["我们来看一张有向和带权的图",{"2":{"105":1}}],["我们在学习树的时候",{"2":{"105":1}}],["我们就可以使用图来模拟它们",{"2":{"104":1}}],["我们就还需要到后半部分去寻找后半部分",{"2":{"17":1}}],["我们会发现",{"2":{"104":1}}],["我们需要排查",{"2":{"237":1}}],["我们需要在使用常量的地方",{"2":{"155":1}}],["我们需要保证树总是平衡的",{"2":{"83":1}}],["我们需要继续对左半部分进行划分",{"2":{"17":1}}],["我们称这种树为非平衡树",{"2":{"83":1}}],["我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树",{"2":{"65":1}}],["我们将每一个数字都对",{"2":{"146":1}}],["我们将该元素与堆的最大值进行比较",{"2":{"17":1}}],["我们将算法的时间复杂度降低为",{"2":{"15":1}}],["我们可以看成是步长为",{"2":{"149":1}}],["我们可以将它进行特殊处理",{"2":{"148":1}}],["我们可以将这个饼干",{"2":{"28":1}}],["我们可以很快的找到一个顶点和哪些顶点有连线",{"2":{"109":1}}],["我们可以使用一个数组来存储起来",{"2":{"108":1}}],["我们可以通过设置一个变量",{"2":{"38":1}}],["我们可以记录当前循环中最后一次元素交换的位置",{"2":{"37":1}}],["我们可以记录当前循环中是否发生了交换",{"2":{"37":1}}],["我们可以发现每一个值其实都等于它的前面两个值的和",{"2":{"16":1}}],["我们可以得到一个递归关系",{"2":{"14":1}}],["我们可以从二维数组的右上角开始遍历",{"2":{"10":1}}],["猜数字游戏的规则如下",{"2":{"20":1}}],["猜数字大小",{"0":{"20":1}}],["differenceset",{"2":{"206":3,"208":3}}],["difference",{"2":{"206":2,"208":2}}],["dict",{"2":{"181":1}}],["dictonary",{"2":{"181":1}}],["dictionay",{"2":{"112":1}}],["dfsvisit",{"2":{"121":3}}],["dfs",{"0":{"121":1},"2":{"119":2,"121":4}}],["data",{"0":{"96":1},"2":{"93":1,"94":1,"95":1,"96":3,"97":1,"98":1,"100":13,"129":4,"130":2,"131":1,"132":2,"133":4,"134":5,"135":6,"137":4,"140":25,"227":6,"231":2}}],["daysofweek",{"2":{"48":2}}],["doublynode",{"2":{"91":2,"92":1,"93":1,"94":1,"100":2}}],["doublylinkedlist",{"0":{"91":1},"2":{"91":2,"100":1,"101":22}}],["dlr",{"2":{"70":1}}],["d",{"2":{"56":1,"62":1,"70":1,"108":4,"109":2,"110":1,"117":5,"120":1,"121":1,"177":4,"193":4,"211":6,"212":2,"224":4,"226":1}}],["degree",{"2":{"224":1}}],["dec",{"2":{"218":5}}],["dec2bin",{"2":{"218":1,"219":3}}],["dequeue",{"2":{"120":1,"176":4,"177":3,"191":1,"192":2,"193":3,"195":3}}],["depth",{"2":{"119":1,"224":1}}],["delete",{"2":{"184":1,"201":1,"208":1}}],["deletecount",{"2":{"51":1}}],["delnode",{"2":{"81":6,"82":6}}],["description",{"2":{"20":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1}}],["dp1",{"2":{"25":4}}],["dp0",{"2":{"25":4}}],["dp",{"2":{"12":5,"25":5,"26":6}}],["height",{"2":{"180":1}}],["heap",{"2":{"233":1}}],["heapsize",{"2":{"43":3}}],["heapsort",{"2":{"43":2}}],["head",{"2":{"88":1,"92":2,"93":7,"94":7,"95":5,"97":1,"100":15,"126":2,"129":3,"130":3,"131":1,"132":8,"133":1,"134":1,"135":1,"136":3,"140":21}}],["handle",{"2":{"120":3,"121":6}}],["hasownproperty",{"2":{"184":1,"201":1,"208":1}}],["hash",{"2":{"233":1}}],["hashtable",{"2":{"160":2,"167":1,"170":1,"171":1}}],["hashfn",{"2":{"158":2,"161":1,"162":1,"163":1,"171":3}}],["hashmap",{"2":{"152":1,"155":1,"181":1}}],["hashcode",{"2":{"142":1,"155":1,"158":8}}],["has",{"2":{"15":1,"182":1,"184":4,"185":3,"200":1,"201":4,"202":3,"205":1,"206":1,"207":1,"208":7}}],["h",{"2":{"57":1,"60":1,"62":1,"70":1,"117":2,"120":1,"121":1,"224":2}}],["hillsort",{"2":{"40":2}}],["high",{"2":{"20":4,"35":4}}],["higher",{"2":{"20":1}}],["house",{"2":{"26":1}}],["https",{"2":{"20":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1}}],["二分查找",{"2":{"237":1}}],["二分查找确定位置",{"2":{"232":1}}],["二分查找法",{"2":{"232":1}}],["二分搜索",{"0":{"20":1,"35":1},"2":{"20":1}}],["二次探测和再哈希法性能相当",{"2":{"152":1}}],["二次探测和再哈希化的性能",{"2":{"152":1}}],["二次探测的步长是固定的",{"2":{"150":1}}],["二次探测存在的问题",{"2":{"149":1}}],["二次探测是在线性探测的基础上进行了优化",{"2":{"149":1}}],["二次探测法可以解决该问题",{"2":{"148":1}}],["二次探测",{"0":{"149":1},"2":{"147":1,"149":1}}],["二叉搜索树中的数据分布就变得不均匀了",{"2":{"83":1}}],["二叉搜索树中除了定义",{"2":{"66":1}}],["二叉搜索树有四个最基本的属性",{"2":{"66":1}}],["二叉搜索树的缺陷",{"2":{"83":1}}],["二叉搜索树的常见操作",{"0":{"67":1},"1":{"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1}}],["二叉搜索树的封装",{"0":{"66":1}}],["二叉搜索树的特点主要是较小的值总是保存在左节点上",{"2":{"64":1}}],["二叉搜索树应用举例",{"0":{"65":1}}],["二叉搜索树是一棵二叉树",{"2":{"64":1}}],["二叉搜索树",{"0":{"64":1},"1":{"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1},"2":{"64":1}}],["二叉树最常见的存储方式为链表",{"2":{"63":1}}],["二叉树可以为空",{"2":{"55":1}}],["二叉树的节点遍历顺序为",{"2":{"70":1}}],["二叉树的数据存储",{"0":{"61":1},"1":{"62":1,"63":1}}],["二叉树的特性",{"0":{"57":1}}],["二叉树的五种形态",{"0":{"56":1}}],["二叉树的组成",{"0":{"55":1}}],["二叉树的概念",{"0":{"54":1}}],["二叉树",{"0":{"53":1},"1":{"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1,"61":1,"62":1,"63":1}}],["二维数组中的查找",{"0":{"10":1}}],["场景",{"0":{"173":1}}],["场景二",{"2":{"19":1}}],["场景一",{"2":{"19":1}}],["合并有序子数组",{"2":{"19":1}}],["合",{"2":{"19":2,"20":2,"21":2,"22":2,"23":2}}],["合法性判断",{"2":{"9":1}}],["解析",{"2":{"212":1}}],["解决问题的办法有很多",{"2":{"237":1}}],["解决问题方法的效率",{"2":{"232":1}}],["解决冲突常见的两种方案",{"2":{"145":1}}],["解决办法需自己去研究下",{"2":{"109":1}}],["解集不能包含重复的子集",{"2":{"32":1}}],["解题步骤",{"2":{"20":1,"21":2,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1}}],["解",{"2":{"19":2,"20":2,"21":2,"22":2,"23":2}}],["再从中间位置分开",{"2":{"237":1}}],["再二分查找",{"2":{"232":1}}],["再进行其他方法的实现",{"2":{"160":1}}],["再进行判断",{"2":{"10":2}}],["再做一次哈希化",{"2":{"150":1}}],["再哈希法的做法为",{"2":{"150":1}}],["再哈希法",{"0":{"150":1},"2":{"147":1}}],["再通过下标值查找效率就非常高了",{"2":{"142":1}}],["再根据工号查找该员工的完整信息呢",{"2":{"142":1}}],["再逐步实现单向链表的常用方法",{"2":{"129":1}}],["再取出其中的内容",{"2":{"110":1}}],["再了解",{"2":{"105":1}}],["再接起来一张",{"2":{"39":1}}],["再将子树换个位置",{"2":{"21":1}}],["再将结果合并以解决原来的问题",{"2":{"19":1}}],["分别指向子节点",{"2":{"226":2}}],["分析",{"2":{"194":1}}],["分析递归的方法我们可以发现",{"2":{"15":1}}],["分给",{"2":{"28":1}}],["分配给孩子",{"2":{"28":1}}],["分发饼干",{"0":{"28":1}}],["分解为",{"2":{"23":1}}],["分割数组",{"2":{"20":1}}],["分",{"2":{"19":2,"20":2,"21":2,"22":2,"23":2}}],["分而治之是算法设计的一种方法",{"2":{"19":1}}],["分而治之",{"0":{"19":1},"1":{"20":1,"21":1,"22":1,"23":1}}],["方案二",{"2":{"143":1}}],["方案一",{"2":{"143":1}}],["方式",{"2":{"80":6}}],["方便模拟最大堆",{"2":{"17":1}}],["方法进行删除",{"2":{"195":1}}],["方法非常类似",{"2":{"191":1}}],["方法中添加如下代码",{"2":{"170":2}}],["方法中关于数组扩容的相关操作",{"2":{"170":1}}],["方法和删除元素的",{"2":{"170":1}}],["方法和获取质数的",{"2":{"170":1}}],["方法二",{"2":{"169":1}}],["方法一",{"2":{"169":1}}],["方法",{"0":{"6":1,"113":1,"116":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1},"1":{"114":1,"115":1,"116":1},"2":{"1":1,"33":1,"36":1,"68":1,"89":1,"127":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1,"167":3,"170":1,"232":3}}],["先定类别",{"2":{"232":2}}],["先进后出",{"2":{"210":1}}],["先进先出",{"2":{"187":1}}],["先创建",{"2":{"161":1}}],["先创建单向链表类",{"2":{"129":1}}],["先访问其所有的相邻点",{"2":{"120":1}}],["先来创建",{"2":{"112":1}}],["先找到需要删除的节点",{"2":{"77":1}}],["先序遍历先遍历根节点",{"2":{"73":1}}],["先序遍历的过程为",{"2":{"70":1}}],["先序遍历",{"0":{"70":1},"2":{"69":1,"70":1}}],["先将",{"2":{"28":1}}],["先将数组逆序",{"2":{"17":1}}],["先翻转左右子树",{"2":{"21":1}}],["先判断计算结果是否已经存在",{"2":{"15":1}}],["以",{"2":{"237":1}}],["以什么样的方式来存储和组织我们的数据",{"2":{"232":1}}],["以及存在于该对象的实例和组成实例的数据元素之间的各种联系",{"2":{"231":1}}],["以及它的",{"2":{"77":1,"82":1}}],["以下为儿子",{"2":{"228":1}}],["以下是使用欧几里得算法计算最大公约数进而求最小公倍数的",{"2":{"5":1}}],["以此类推",{"2":{"126":1,"132":1,"140":1,"143":1}}],["以此达到整个数据变成有序序列",{"2":{"42":1}}],["以遍历根",{"2":{"73":1}}],["以后的元素遍历时",{"2":{"17":1}}],["对应这个人",{"2":{"195":1}}],["对应的",{"2":{"166":1}}],["对应的数组",{"2":{"110":1}}],["对象",{"2":{"176":1,"195":1}}],["对象默认的",{"2":{"89":1,"127":1}}],["对哈希表容量进行压缩",{"2":{"167":1}}],["对哈希表进行扩容",{"2":{"167":1}}],["对哈希表进行扩容操作",{"2":{"157":1}}],["对步长进行了优化",{"2":{"149":1}}],["对最终数据插入的数组进行整个结构的封装",{"2":{"144":1}}],["对称的位置",{"2":{"109":1}}],["对称二叉树",{"0":{"23":1}}],["对飞机航线建模",{"2":{"106":1}}],["对交通流量建模",{"2":{"106":1}}],["对任何非空二叉树",{"2":{"57":1}}],["对于任意一棵非空树",{"2":{"223":1}}],["对于给定的两个集合",{"2":{"203":3}}],["对于每一条所连接的没有被访问过的顶点",{"2":{"119":1}}],["对于一棵平衡二叉树来说",{"2":{"83":1}}],["对于",{"2":{"46":1}}],["对每个点操作",{"2":{"121":1}}],["对每个分组使用插入排序",{"2":{"40":1}}],["对每个孩子",{"2":{"28":1}}],["对每组使用直接插入排序算法排序",{"2":{"40":1}}],["对相邻的元素进行两两比较",{"2":{"37":1}}],["对饼干数组和胃口数组升序排序",{"2":{"28":1}}],["对两个子数组进行合并",{"2":{"19":1}}],["对",{"2":{"17":1,"132":1,"140":1,"148":1,"158":1}}],["对数组进行遍历时",{"2":{"17":1}}],["获取余数",{"2":{"218":1}}],["获取栈中元素个数",{"2":{"215":1}}],["获取集合中所有的",{"2":{"201":1,"208":1}}],["获取集合中的",{"2":{"201":1,"208":1}}],["获取字典中的键值对个数",{"2":{"184":1}}],["获取所有的",{"2":{"184":2}}],["获取最后剩下的那个人",{"2":{"195":1}}],["获取最后一个非叶子点的元素",{"2":{"43":1}}],["获取最临近的质数",{"2":{"170":1,"171":1}}],["获取要映射到",{"2":{"161":1,"171":1}}],["获取索引值",{"2":{"161":1}}],["获取哈希表中特定位置的元素",{"2":{"157":1}}],["获取数据时比较麻烦",{"2":{"142":1}}],["获取指定",{"2":{"133":1,"140":1,"184":1}}],["获取指定位置的",{"2":{"140":1}}],["获取指定位置的元素",{"2":{"89":1}}],["获取指定位置",{"2":{"133":1}}],["获取对应位置的元素",{"2":{"127":1}}],["获取链表的长度",{"2":{"100":1,"139":1,"140":1}}],["获取后续节点",{"2":{"81":1,"82":1}}],["获取二叉搜索树最大值",{"2":{"75":1}}],["获取二叉搜索树最小值",{"2":{"75":1}}],["获取当前位的值",{"2":{"44":1}}],["获取右子元素的索引",{"2":{"43":1}}],["获取左子元素的索引",{"2":{"43":1}}],["获取左右子树",{"2":{"21":1}}],["获取枢纽值的大小",{"2":{"42":1}}],["获取两个树的左子树和右子树",{"2":{"22":1,"23":1}}],["获取",{"2":{"17":1,"162":1,"171":1}}],["说明该子树满足大顶堆的要求",{"2":{"43":1}}],["说明后面全部排序完毕",{"2":{"37":1}}],["说明最小的",{"2":{"17":1}}],["说明目标值可能在当前行的下一行",{"2":{"10":1}}],["说明目标值可能在当前列的上一行",{"2":{"10":1}}],["大海捞针",{"2":{"232":1}}],["大一点点的节点",{"2":{"80":1,"81":1}}],["大多数强类型的编程语言里面数组通常情况下都用于存储一系列同一种数据类型的值",{"2":{"47":1}}],["大时",{"2":{"17":1}}],["大家都知道斐波那契数列",{"2":{"11":1}}],["当需要在链表中间位置插入或删除数据时",{"2":{"223":1}}],["当不确定循环次数时",{"2":{"218":1}}],["当新开启的线程所需的资源不足时就先放入线程队列",{"2":{"189":1}}],["当开启多线程时",{"2":{"189":1}}],["当装填因子",{"2":{"167":1}}],["当使用者传入一个",{"2":{"161":1}}],["当删除",{"2":{"148":1}}],["当查询",{"2":{"148":1}}],["当要查找张三的号码时",{"2":{"142":1}}],["当前存放的元素个数",{"2":{"160":1,"171":1}}],["当前节点初始化为",{"2":{"132":1,"140":1}}],["当前数组不能满足容量需求时",{"2":{"124":1}}],["当链表中一个节点也没有的时候",{"2":{"126":1}}],["当然",{"2":{"108":1}}],["当插入数据分布性较大的一组数据时",{"2":{"149":1}}],["当插入",{"2":{"148":1}}],["当插入一组有序数据",{"2":{"83":1}}],["当插入的数据是有序的数据",{"2":{"83":1}}],["当该叶子节点不为根节点时也有两种情况",{"2":{"78":1}}],["当该叶子节点为根节点时",{"2":{"78":1}}],["当该枢纽值的位置比",{"2":{"17":1}}],["当每次换分的结果为",{"2":{"42":1}}],["当每次换分的结果为含",{"2":{"42":1}}],["当遇到比枢纽值大的值或者",{"2":{"42":1}}],["当遇到比枢纽值小的值或者",{"2":{"42":1}}],["当",{"2":{"42":3,"68":6,"79":2,"130":1,"140":1,"223":1}}],["当增量减至",{"2":{"40":1}}],["当轮循环结束之后",{"2":{"38":1}}],["当排序序列为已排序序列时",{"2":{"37":1}}],["当最后一个交换的元素为第一个时",{"2":{"37":1}}],["当元素为数组时递归调用",{"2":{"1":1}}],["则扩容",{"2":{"161":1,"167":1,"170":1,"171":1}}],["则修改数据",{"2":{"161":1,"171":1}}],["则线性查找",{"2":{"148":1}}],["则余数的范围",{"2":{"146":1}}],["则需要在",{"2":{"81":1}}],["则合适的节点指的是",{"2":{"80":1}}],["则不需要删除",{"2":{"77":1}}],["则向左查找",{"2":{"76":1}}],["则返回",{"2":{"67":2,"89":1,"127":1,"157":1,"182":1}}],["则满足以下性质",{"2":{"64":1}}],["则它由根节点和称为其左子树",{"2":{"55":1}}],["则更新",{"2":{"45":2}}],["则更新最大值索引",{"2":{"43":2}}],["则更新最小元素索引",{"2":{"38":1}}],["则交换位置",{"2":{"43":1}}],["则把剩余的元素全部加入到结果数组中",{"2":{"41":2}}],["则说明该序列已经为有序序列了",{"2":{"37":1}}],["则在大于或小于中间元素的那一半数组中搜索",{"2":{"35":1}}],["则搜索结束",{"2":{"35":1}}],["则认为它们是相同的",{"2":{"22":1}}],["则继续向后遍历",{"2":{"17":1}}],["则直接将元素加入到堆中",{"2":{"17":1}}],["则最小的",{"2":{"17":1}}],["则将位置向左移动",{"2":{"10":1}}],["则将位置向下移动",{"2":{"10":1}}],["个引用",{"2":{"226":2}}],["个互不相交的有限集合",{"2":{"223":1}}],["个节点构成的有限集合",{"2":{"223":1}}],["个一次多项式的值",{"2":{"154":1}}],["个人的信息",{"2":{"142":1}}],["个位置插入",{"2":{"93":1,"94":1,"100":1}}],["个条件属于二叉树",{"2":{"64":1}}],["个子节点",{"2":{"59":1}}],["个元素就排到了队列的最前面",{"2":{"195":1}}],["个元素先删除后添加到队列末尾",{"2":{"195":1}}],["个元素",{"2":{"51":1,"212":1}}],["个元素的次小值",{"2":{"43":1}}],["个元素重新构造成一个堆",{"2":{"43":1}}],["个元素时就停止数数",{"2":{"195":1}}],["个元素时",{"2":{"42":2}}],["个孩子的饼干",{"2":{"28":1}}],["个房屋的钱数",{"2":{"26":1}}],["个房屋中能窃取的最大数额",{"2":{"26":1}}],["个台阶",{"2":{"25":3}}],["个最小数",{"2":{"17":1}}],["个值还在左半部分",{"2":{"17":1}}],["个整数",{"2":{"17":1}}],["个数据",{"2":{"65":1}}],["个数就是最小的",{"2":{"17":1}}],["个数不一定是按序排序的",{"2":{"17":1}}],["个数字是",{"2":{"17":1}}],["个数字",{"2":{"17":1}}],["个数",{"0":{"17":1},"2":{"17":5,"201":1,"208":1}}],["keys",{"2":{"182":1,"184":3,"185":2,"201":2,"208":2}}],["key",{"0":{"161":1,"162":1,"163":1},"2":{"66":5,"67":3,"68":11,"70":1,"71":1,"72":1,"75":2,"76":19,"77":4,"82":5,"142":2,"150":2,"155":1,"157":3,"161":13,"162":8,"163":6,"171":18,"180":2,"182":4,"184":19}}],["ksmallestnums",{"2":{"17":4}}],["kthsmallest",{"2":{"17":2}}],["k",{"0":{"17":1},"2":{"17":34,"26":9,"37":2,"44":3,"57":2,"226":1}}],["并拼接到一起",{"2":{"218":1}}],["并集的实现",{"0":{"204":1}}],["并集",{"2":{"203":1}}],["并添加必要的属性和上面实现的哈希函数",{"2":{"160":1}}],["并将",{"2":{"120":1}}],["并将其加进待访问顶点列表中",{"2":{"119":1}}],["并排序的空间复杂度为",{"2":{"41":1}}],["并返回取出的那个元素",{"2":{"215":1}}],["并返回被移除的元素",{"2":{"191":1}}],["并返回右部分的第一个元素的索引值",{"2":{"42":1}}],["并返回",{"2":{"31":1,"32":1,"158":1}}],["并输出这个最大数值",{"2":{"28":1}}],["并且可以快速获取最大值和最小值等",{"2":{"223":1}}],["并且哈希表中的元素是无序的",{"2":{"223":1}}],["并且在插入和删除元素时",{"2":{"223":1}}],["并且在插入的过程中需要经历多次这种情况",{"2":{"148":1}}],["并且删除",{"2":{"163":1}}],["并且结果不可能为",{"2":{"150":1}}],["并且这个节点会连接下一个节点",{"2":{"126":1}}],["并且大小可以无限延伸下去",{"2":{"125":1}}],["并且大小是固定的",{"2":{"124":1}}],["并且追踪有哪些顶点还没有被访问到",{"2":{"119":1}}],["并且",{"2":{"60":1,"146":1}}],["并且它额外所需空间最小",{"2":{"42":1}}],["并且每块饼干",{"2":{"28":1}}],["并且节点具有相同的值",{"2":{"22":1}}],["并且将算法的空间复杂度降低为",{"2":{"16":1}}],["并根据比较结果动态调整行或列的位置",{"2":{"10":1}}],["迭代法",{"0":{"16":1}}],["将栈结构的内容以字符串的形式返回",{"2":{"214":1}}],["将当前集合",{"2":{"204":1,"208":1}}],["将元素加入到队列中",{"2":{"192":1}}],["将元素按优先级加入到队列中",{"2":{"176":1}}],["将这个字典中的所有元素全部删除",{"2":{"182":1}}],["将队列中的元素以字符串形式返回",{"2":{"192":1}}],["将队列中的内容",{"2":{"191":1}}],["将队列中元素以字符串形式返回",{"2":{"176":1}}],["将队头关联的点添加到队尾",{"2":{"120":1}}],["将数据插入到",{"2":{"161":1}}],["将数组划分为两部分",{"2":{"42":1}}],["将数组分为比枢纽值大和比枢纽值小的两个部分",{"2":{"17":1}}],["将大数字转化成数组范围内下标的过程",{"2":{"144":1}}],["将字典所包含的所有数值以数组形式返回",{"2":{"182":1}}],["将字典所包含的所有键名以数组形式返回",{"2":{"182":1}}],["将字母转化为数字也有很多种方案",{"2":{"143":1}}],["将字符串反转",{"2":{"7":1}}],["将颜色设置为访问中",{"2":{"121":1}}],["将传入的顶点放入队列",{"2":{"120":1}}],["将传入的数组建立为大顶堆",{"2":{"43":1}}],["将入队列",{"2":{"120":1}}],["将其顺时针旋转",{"2":{"228":1}}],["将其删除",{"2":{"163":1,"171":1,"195":1}}],["将其标注为被发现的",{"2":{"119":1}}],["将其与末尾元素进行交换",{"2":{"43":1}}],["将添加的顶点放入到数组中",{"2":{"114":1}}],["将经过两个顶点的每条航线看作一条边",{"2":{"106":1}}],["将每个机场看成顶点",{"2":{"106":1}}],["将后续的左节点改为被删除的左节点",{"2":{"81":1,"82":1}}],["将",{"2":{"65":1,"115":2,"120":5,"166":1,"195":1,"204":1,"208":1}}],["将所有待比较数值",{"2":{"44":1}}],["将剩下的元素重新构建为大顶堆",{"2":{"43":1}}],["将最大的元素与末尾元素交换",{"2":{"43":1}}],["将待排序序列构造成一个大顶堆",{"2":{"43":1}}],["将一开始保留的枢纽值填入这个位置",{"2":{"42":1}}],["将枢纽值交换到中间点",{"2":{"42":1}}],["将比枢纽值大的值交换到",{"2":{"42":1}}],["将比枢纽值小的值交换到",{"2":{"42":1}}],["将较小的元素加入结果数组中",{"2":{"41":1}}],["将分组的大小增大",{"2":{"40":1}}],["将序列分为多个小的分组进行",{"2":{"40":1}}],["将找到的位置插入元素",{"2":{"39":1}}],["将空间复杂度下降至",{"2":{"25":1}}],["将上述结果合并",{"2":{"22":1}}],["将翻转后的左右子树换个位置放到根节点上",{"2":{"21":1}}],["将已经计算出的值给保存下来",{"2":{"15":1}}],["备忘录方法",{"0":{"15":1}}],["递归",{"2":{"211":1}}],["递归本质上就是函数栈的调用",{"2":{"121":1}}],["递归停止",{"2":{"68":1}}],["递归调用",{"2":{"68":1}}],["递归的代码较难理解一些",{"2":{"121":1}}],["递归的次数为",{"2":{"42":1}}],["递归的将数组两两分开直到只包含一个元素",{"2":{"41":1}}],["递归排序右半部分",{"2":{"42":1}}],["递归排序左半部分",{"2":{"42":1}}],["递归分解后",{"2":{"41":1}}],["递归地判断树",{"2":{"23":1}}],["递归地判断两个树的左子树是否相同",{"2":{"22":1}}],["递归地翻转左右子树",{"2":{"21":1}}],["递归地在较大或者较小数组进行二分搜索",{"2":{"20":1}}],["递归地两个子数组进行快速排序",{"2":{"19":1}}],["递归地对两个子数组进行归并排序",{"2":{"19":1}}],["递归解决小问题",{"2":{"19":1}}],["递归结束的标志为从",{"2":{"14":1}}],["递归方法分析",{"0":{"14":1}}],["到顶端",{"2":{"37":1}}],["到",{"2":{"14":5,"20":1,"45":1,"167":1,"171":1}}],["九级阶梯走上去的情况",{"2":{"14":1}}],["9",{"2":{"14":2,"35":1,"62":2,"65":4,"71":1,"72":1,"79":4,"80":6,"105":3,"150":1}}],["因为函数还没有执行完",{"2":{"211":1}}],["因为",{"2":{"161":1}}],["因为只要愿意",{"2":{"151":1}}],["因为只有空白的单元才能放入元素",{"2":{"151":1}}],["因为一遇到为",{"2":{"148":1}}],["因为插入",{"2":{"148":1}}],["因为链条的元素一般不会太多",{"2":{"146":1}}],["因为这里实现的是无向图",{"2":{"115":1}}],["因为边是两个顶点之间的边",{"2":{"115":2}}],["因为边是两个顶点之间的关系",{"2":{"108":1}}],["因为所有的边都没有方向",{"2":{"105":1}}],["因为整个树的高度为",{"2":{"41":1}}],["因为在子数组中搜索到就返回",{"2":{"20":1}}],["因为每一步只允许走",{"2":{"14":1}}],["因此都需要在程序中体现出来",{"2":{"107":1}}],["因此堆排序的时间复杂度在不管什么情况下都是",{"2":{"43":1}}],["因此下一轮循环中无需再去比较",{"2":{"37":1}}],["因此我们不需要再执行之后的外层循环",{"2":{"37":1}}],["因此我们可以使用快速排序中的",{"2":{"17":1}}],["因此我们可以使用自底向上的方式来实现",{"2":{"16":1}}],["因此我们可以使用一个数组",{"2":{"15":1}}],["因此我们可以通过循环的方式",{"2":{"11":1}}],["因此该方法的时间复杂度可以近似的看为",{"2":{"14":1}}],["因此从",{"2":{"14":1}}],["因此分别为从",{"2":{"14":1}}],["因此",{"2":{"12":1,"155":1}}],["因此跳上",{"2":{"12":1}}],["这是最坏的情况",{"2":{"237":1}}],["这是能让孩子们满足胃口的饼干的最小尺寸",{"2":{"28":1}}],["这条链条常使用的数据结构为数组或链表",{"2":{"146":1}}],["这副图来帮助理解过程",{"2":{"121":1}}],["这一端被称为栈顶",{"2":{"210":1}}],["这一步是完成bfs的关键",{"2":{"120":1}}],["这一种方法的平均时间复杂度为",{"2":{"17":2}}],["这一种方法的时间复杂度取决于我们选择的排序算法的时间复杂度",{"2":{"17":1}}],["这一种方式最坏情况下的时间复杂度为",{"2":{"10":2}}],["这两种遍历算法",{"2":{"119":1}}],["这两个都是非常重要的图信息",{"2":{"107":1}}],["这两个特殊的节点有特殊的名字",{"2":{"81":1}}],["这意味着我们浪费了计算机存储空间来表示根本不存在的边",{"2":{"109":1}}],["这种表示方法可以完整地记录每个节点的数据",{"2":{"227":1}}],["这种方法缺点在于我们无法确定某一结点的引用数",{"2":{"226":1}}],["这种方法虽然能实现质数的判断",{"2":{"169":1}}],["这种算法把求",{"2":{"154":1}}],["这种一连串填充单元就称为聚集",{"2":{"148":1}}],["这种变换我们可以称之为哈希函数",{"2":{"142":1}}],["这种情况会造成步长不一的一种聚集",{"2":{"149":1}}],["这种情况称为冲突",{"2":{"145":1}}],["这种情况下需要从要删除节点下面的子节点中找到一个合适的节点",{"2":{"80":1}}],["这种情况十分复杂",{"2":{"80":1}}],["这种特点使得二叉搜索树的查询效率非常高",{"2":{"64":1}}],["这里不做封装",{"2":{"200":1}}],["这里我们重新封装一个",{"2":{"199":1}}],["这里使用",{"2":{"197":1}}],["这里直接使用函数的调用栈",{"2":{"121":1}}],["这里实现的是无向图",{"2":{"115":1}}],["这里采用邻接表的形式",{"2":{"112":1}}],["这里的深度优先搜索算法可以使用栈完成",{"2":{"121":1}}],["这里的权重可以是任意你希望表示的数据",{"2":{"105":1}}],["这里的边不要叫做路径",{"2":{"105":1}}],["这里介绍几个比较常见的术语",{"2":{"105":1}}],["这里",{"2":{"105":1}}],["这里暂不讨论",{"2":{"81":1}}],["这里可以使用递归实现",{"2":{"76":1}}],["这里所说的树的遍历不仅仅针对二叉搜索树",{"2":{"69":1}}],["这也就是二叉搜索树中",{"2":{"64":1}}],["这就是数据结构需要考虑的问题",{"2":{"232":1}}],["这就是数组二分法查找效率之所以高的原因",{"2":{"65":1}}],["这就会造成哈希表效率的降低",{"2":{"166":1}}],["这就意味着下标值为",{"2":{"148":1}}],["这就要求树中每个节点左边的子孙节点的个数",{"2":{"83":1}}],["这就构成了完美二叉树",{"2":{"59":1}}],["这就相当于我们假设前",{"2":{"17":1}}],["这些联系可以通过定义相关的函数来给出",{"2":{"231":1}}],["这些缺点微不足道",{"2":{"87":1}}],["这些交换都是无意义的",{"2":{"38":1}}],["这些路里",{"2":{"30":1}}],["这样就成为了一棵二叉树",{"2":{"228":1}}],["这样第",{"2":{"195":1}}],["这样计算机直接运算二进制数据",{"2":{"155":1}}],["这样一次性探测比较长的距离",{"2":{"149":1}}],["这样在查找时遇到",{"2":{"148":1}}],["这样可以根据下标值获取到整个数组或链表",{"2":{"146":1}}],["这样可以保证",{"2":{"118":1}}],["这样的单词",{"2":{"143":1}}],["这样的树就称为二叉树",{"2":{"54":1}}],["这样单词也可以用该种方式来表示",{"2":{"143":1}}],["这样方便之后删除节点时改变相关节点的指向",{"2":{"77":1}}],["这样会浪费很大的存储空间",{"2":{"62":1}}],["这样会得到",{"2":{"43":1}}],["这样从最低位排序一直到最高位排序完成以后",{"2":{"44":1}}],["这样",{"2":{"37":1,"150":1}}],["这个单词本意就是解决问题的办法",{"2":{"236":1}}],["这个方法和数组的",{"2":{"214":1}}],["这个列表有很多中方式来存储",{"2":{"110":1}}],["这个时候",{"2":{"104":1,"108":1}}],["这个时候一共有两种情况",{"2":{"14":1}}],["这个孩子会得到满足",{"2":{"28":1}}],["这",{"2":{"17":2}}],["由此我们可以得出结论",{"2":{"228":1}}],["由此得到质数",{"2":{"170":1}}],["由",{"2":{"223":1}}],["由下图可知",{"2":{"152":1}}],["由一条边连接在一起的顶点称为相邻顶点",{"2":{"105":1}}],["由于队列没有像数组一样的下标值不能直接取到某一元素",{"2":{"195":1}}],["由于使用的是链地址法",{"2":{"166":1}}],["由于不知道存储张三数据对象的下标值",{"2":{"142":1}}],["由于链表项使用了",{"2":{"89":1,"127":1}}],["由于树结构不是线性结构",{"2":{"69":1}}],["由于",{"2":{"60":1,"65":4,"83":1}}],["由于相同的元素可能在不同的分组中",{"2":{"40":1}}],["由于开始时每组只有很少整数",{"2":{"40":1}}],["由于每一次都是基于上一",{"2":{"40":1}}],["由于排序基数小",{"2":{"40":1}}],["由于一次只能够跳",{"2":{"12":1}}],["由分析可知",{"2":{"14":1}}],["每条指令的描述不依赖于语言",{"2":{"235":1}}],["每种数据结构都有自己特定的应用场景",{"2":{"223":1}}],["每层节点都有",{"2":{"59":1}}],["每个元素不再只是一个数据",{"2":{"174":1}}],["每个顶点至多访问两次",{"2":{"119":1}}],["每个语言的排序内部实现都是不同的",{"2":{"46":1}}],["每个孩子最多只能给一块饼干",{"2":{"28":1}}],["每",{"2":{"41":1}}],["每组包含的元素越来越多",{"2":{"40":1}}],["每间房内都藏有一定的现金",{"2":{"26":1}}],["每次在插入或删除某个节点时",{"2":{"87":1}}],["每次调整堆的时间复杂度为",{"2":{"43":1}}],["每次循环",{"2":{"43":1}}],["每次基数排序的效果较好",{"2":{"40":1}}],["每次增量的大小减半",{"2":{"40":1}}],["每次你可以爬",{"2":{"25":1}}],["每次计算时",{"2":{"15":1}}],["每轮游戏",{"2":{"20":1}}],["每跨一步只能向上",{"2":{"13":1}}],["每一个父节点需要的引用数量也不同",{"2":{"226":1}}],["每一个工号对应一个员工的信息",{"2":{"142":1}}],["每一个节点由三部分组成",{"2":{"88":1}}],["每一个节点封装成一个",{"2":{"63":1}}],["每一步将一个待排序的记录",{"2":{"39":1}}],["每一次比较仅存储较小元素的数组下标",{"2":{"38":1}}],["每一次选择一个枢纽值",{"2":{"17":1}}],["每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小",{"2":{"38":1}}],["每一趟会将最小或最大的元素",{"2":{"37":1}}],["每一列都按照从上到下递增的顺序排序",{"2":{"10":1}}],["每一行都按照从左到右递增的顺序排序",{"2":{"10":1}}],["从中间位置开始排查",{"2":{"237":1}}],["从上海的起点开始一米一米的排查",{"2":{"237":1}}],["从自己角度认识",{"2":{"231":1}}],["从栈中取出元素",{"2":{"215":1}}],["从一个栈删除元素又称作出栈或退栈",{"2":{"210":1}}],["从当前集合中取出每一个",{"2":{"205":1,"206":1,"207":1,"208":3}}],["从集合移除一个值",{"2":{"200":1}}],["从队列中删除队头元素",{"2":{"192":1}}],["从队列中删除前端元素",{"2":{"176":1}}],["从链表中移除一项",{"2":{"127":1}}],["从链表中的删除指定位置的元素",{"2":{"89":1}}],["从链表的特定位置移除一项",{"2":{"127":1}}],["从链表删除指定的元素",{"2":{"89":1}}],["从节点",{"2":{"80":6}}],["从树中移除某个键",{"2":{"67":1}}],["从左到右的方式存储数据",{"2":{"62":1}}],["从最低位开始",{"2":{"44":1}}],["从数组的中间元素开始",{"2":{"35":1}}],["从而达到全局的最优",{"2":{"27":1}}],["从前",{"2":{"26":1}}],["从",{"2":{"24":1,"25":1,"26":1,"120":1,"148":1}}],["从下往上走",{"2":{"13":1}}],["从右上角开始遍历二维数组",{"2":{"10":1}}],["动态规划是算法设计的一种方法",{"2":{"24":1}}],["动态规划",{"0":{"13":1,"24":1},"1":{"14":1,"15":1,"16":1,"25":1,"26":1}}],["动态规划公式",{"2":{"12":1}}],["有不存在的返回",{"2":{"207":1,"208":1}}],["有些情况下不需要输入",{"2":{"235":1}}],["有些编程语言中称这种映射关系为",{"2":{"181":1}}],["有些编程语言中称这种映射关系为字典",{"2":{"181":1}}],["有些语言称为指针",{"2":{"125":1}}],["有紧急情况",{"2":{"173":1}}],["有了编码系统后",{"2":{"143":1}}],["有没有一种数据结构",{"2":{"142":1}}],["有一天高架线中有其中一米出现了故障",{"2":{"237":1}}],["有一个火车头",{"2":{"126":1}}],["有一座高度是",{"2":{"13":1}}],["有边",{"2":{"110":1}}],["有可能还表示其他含义的数据",{"2":{"108":1}}],["有向图表示的图中的边是有方向的",{"2":{"105":1}}],["有向图",{"2":{"105":1}}],["有两种方案",{"2":{"190":1}}],["有两种方式",{"2":{"80":1}}],["有两种算法可以对图进行遍历",{"2":{"119":1}}],["有两级台阶时",{"2":{"12":1}}],["有六种情况",{"2":{"79":1}}],["有右子节点时",{"2":{"68":1}}],["有左子节点时",{"2":{"68":1}}],["有左右两个子树的二叉树",{"2":{"56":1}}],["有递归模拟所有的情况",{"2":{"31":1}}],["有出路",{"2":{"31":1,"32":1}}],["有死路",{"2":{"30":1,"31":1,"32":1}}],["有很多路",{"2":{"30":1}}],["有",{"2":{"12":1,"212":1}}],["只要能正确找到对应节点即可",{"2":{"228":1}}],["只要查询到空位置",{"2":{"148":1}}],["只返回元素信息与",{"2":{"191":1}}],["只允许在表的后端",{"2":{"187":1}}],["只允许在表的前端",{"2":{"187":1}}],["只不过哈希表能够通过哈希函数把字符串转化为对应的下标值",{"2":{"142":1}}],["只不过是遍历的顺序不一样了",{"2":{"71":1,"72":1}}],["只能被",{"2":{"169":1}}],["只能从头遍历到尾或者从尾遍历到头",{"2":{"86":1}}],["只能持有",{"2":{"29":1}}],["只存在右节点",{"2":{"79":1,"82":1}}],["只存在",{"2":{"79":2,"82":2}}],["只存在左节点",{"2":{"79":1,"82":1}}],["只需要遍历",{"2":{"169":1}}],["只需要几个机器指令即可完成",{"2":{"142":1}}],["只需要",{"2":{"109":1}}],["只需要从根节点开始将需要查找节点的",{"2":{"76":1}}],["只需要一直向左",{"2":{"75":1}}],["只需要查找",{"2":{"65":1}}],["只缺失右侧若干叶子节点",{"2":{"60":1}}],["只有右子树",{"2":{"56":1}}],["只有左子树",{"2":{"56":1}}],["只有一个节点的二叉树",{"2":{"56":1}}],["只有一级台阶时",{"2":{"12":1}}],["只有",{"2":{"12":1}}],["只适合于数组中元素都是整数的情况",{"2":{"1":1}}],["不过",{"2":{"226":1}}],["不过初始两项的值变为了",{"2":{"12":1}}],["不对栈做任何修改",{"2":{"214":1}}],["不停地把相同的函数",{"2":{"211":1}}],["不会把函数弹出栈",{"2":{"211":1}}],["不移除元素",{"2":{"191":1}}],["不用判断优先级",{"2":{"176":1}}],["不用通过循环找到最后一个节点",{"2":{"92":1,"100":1}}],["不再往下执行",{"2":{"171":1}}],["不再符合该情况",{"2":{"68":1}}],["不是",{"2":{"195":1}}],["不是则",{"2":{"170":1}}],["不是质数",{"2":{"169":1,"170":3}}],["不是稳定排序",{"2":{"38":1,"40":1,"42":1,"43":1}}],["不存在的即为差集",{"2":{"206":1,"208":1}}],["不存在则创建",{"2":{"161":1,"171":1}}],["不存在",{"2":{"161":1}}],["不存在时通过",{"2":{"68":1}}],["不然哈希化后的结果仍是原来位置",{"2":{"150":1}}],["不同探测方式性能的比较",{"0":{"152":1}}],["不同的关键字即使映射到相同的数组下标",{"2":{"150":1}}],["不同于数组",{"2":{"125":1}}],["不相同时",{"2":{"148":1}}],["不考虑大写情况",{"2":{"143":1}}],["不像数组",{"2":{"142":1}}],["不断地从栈中取出元素",{"2":{"218":1}}],["不断地调用自己",{"2":{"211":1}}],["不断地更新",{"2":{"132":1,"140":1}}],["不断通过叠加来实现第",{"2":{"11":1}}],["不为空时",{"2":{"130":1,"140":1}}],["不能按照固定顺序遍历哈希表中的元素",{"2":{"223":1}}],["不能重复意味着相同的对象在集合中只会存在一份",{"2":{"198":1}}],["不能重复的元素构成",{"2":{"198":1}}],["不能被",{"2":{"169":1}}],["不能输出为",{"2":{"150":1}}],["不能将该位置下标的内容设置为",{"2":{"148":1}}],["不能放置相同的",{"2":{"142":1}}],["不能小于",{"2":{"132":1,"140":1}}],["不能说",{"2":{"105":1}}],["不能保证一定可以",{"2":{"105":1}}],["不能包含一模一样的数字",{"2":{"31":1}}],["不做赘述",{"2":{"105":1}}],["不做任何长远打算",{"2":{"29":1}}],["不包括",{"2":{"45":1}}],["不需要排序",{"2":{"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1}}],["不需要此步",{"2":{"20":1}}],["不触动警报装置的情况下",{"2":{"26":1}}],["跳上",{"2":{"12":1}}],["跳台阶的问题是一个动态规划的问题",{"2":{"12":1}}],["跳台阶",{"0":{"12":1}}],["级或",{"2":{"14":1}}],["级或者",{"2":{"12":1,"13":1}}],["级阶梯的走法数量和从",{"2":{"14":1}}],["级阶梯的走法数量",{"2":{"14":2}}],["级阶梯的走法数量加上从",{"2":{"14":1}}],["级阶梯的走法数量就等于从",{"2":{"14":1}}],["级阶梯和从",{"2":{"14":1}}],["级阶梯",{"2":{"14":2}}],["级跳上",{"2":{"12":1}}],["级的台阶总共有多少种跳法",{"2":{"12":1}}],["级",{"2":{"12":2}}],["级台阶的楼梯",{"2":{"13":1}}],["级台阶一共有两种方案",{"2":{"12":1}}],["级台阶",{"2":{"12":1,"13":1}}],["一定在有限步骤之后终止",{"2":{"235":1}}],["一定也是",{"2":{"109":1}}],["一整块内存",{"2":{"124":1}}],["一个有限指令集",{"2":{"235":1}}],["一个庞大的图书馆中存放了大量的书籍",{"2":{"232":1}}],["一个",{"2":{"195":1,"218":1}}],["一个图包含很多顶点",{"2":{"107":1}}],["一个顶点的度是相邻顶点的数量",{"2":{"105":1}}],["一个二叉树的第",{"2":{"57":1}}],["一组边",{"2":{"104":1}}],["一组顶点",{"2":{"104":1}}],["一般情况下是申请一个更大的数组",{"2":{"124":1}}],["一般从头到尾",{"2":{"86":1}}],["一般来说只要每次换分都是常比例的划分",{"2":{"42":1}}],["一直查找新节点适合插入的位置",{"2":{"68":1}}],["一直这样递归下去",{"2":{"4":1}}],["一层归并的时间复杂度为",{"2":{"41":1}}],["一股",{"2":{"29":1}}],["一夜之内能够偷窃到的最高金额",{"2":{"26":1}}],["一步一级或一步两级",{"2":{"12":1}}],["一种是从",{"2":{"12":2}}],["一只青蛙一次可以跳上",{"2":{"12":1}}],["项值的构建",{"2":{"11":1}}],["项",{"2":{"11":1,"191":1}}],["请你想出一种算法",{"2":{"237":1}}],["请你猜选出的是哪个数字",{"2":{"20":1}}],["请你输出斐波那契数列的第",{"2":{"11":1}}],["请完成一个函数",{"2":{"10":1}}],["斐波那契数列的规律是",{"2":{"11":1}}],["斐波那契数列",{"0":{"11":1}}],["75",{"2":{"161":1,"166":1,"167":2,"170":1,"171":2}}],["78",{"2":{"32":1}}],["70",{"2":{"25":1}}],["7",{"2":{"10":1,"12":1,"17":4,"35":1,"52":2,"62":2,"71":1,"72":1,"80":6,"81":2,"83":1,"148":1,"158":1,"160":2,"163":1,"166":1,"167":1,"170":2,"171":3}}],["示例",{"2":{"10":1,"11":1}}],["child",{"2":{"224":1}}],["charcodeat",{"2":{"158":1}}],["cpu",{"2":{"189":1}}],["ceil",{"2":{"169":1}}],["cats",{"2":{"143":3}}],["cc",{"2":{"101":1,"131":1,"132":1,"135":2,"136":1,"137":1}}],["clear",{"2":{"182":1,"184":2,"200":1,"201":2,"202":2,"208":2}}],["class",{"2":{"66":1,"91":2,"129":1,"140":1,"176":2,"184":1,"201":1,"208":1,"215":1}}],["climbstairs2",{"2":{"25":1}}],["climbstairs1",{"2":{"25":1}}],["climbing",{"2":{"25":1}}],["c",{"2":{"45":13,"56":1,"57":1,"62":2,"70":1,"108":4,"110":1,"117":4,"120":1,"121":1,"130":1,"143":1,"177":2,"193":5,"211":6,"212":2,"224":2,"226":1,"227":1}}],["cn",{"2":{"20":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1,"185":4}}],["currentnode",{"2":{"77":10,"78":3,"79":20,"81":3,"82":36,"93":6,"94":6,"95":8,"97":5,"98":5,"100":24,"130":9,"131":5,"132":6,"133":4,"134":5,"135":5,"136":7,"140":38}}],["current",{"2":{"10":3,"11":2,"77":2,"78":3,"79":18,"80":7,"81":16,"82":6}}],["count++",{"2":{"161":1,"171":1}}],["count",{"2":{"160":1,"161":1,"163":2,"164":1,"165":1,"167":4,"170":2,"171":7}}],["countingsort",{"2":{"45":2}}],["complete",{"2":{"60":1}}],["cookies",{"2":{"28":1}}],["color",{"2":{"120":5,"121":8}}],["colors",{"2":{"119":3}}],["col",{"2":{"10":4}}],["constant",{"2":{"150":3}}],["constructor",{"2":{"66":1,"91":2,"100":1,"112":1,"129":1,"140":1,"160":1,"171":1,"176":2,"184":1,"192":1,"201":1,"208":1,"215":1}}],["const",{"2":{"10":2,"17":13,"20":3,"23":1,"25":3,"26":1,"28":1,"31":2,"32":2,"35":2,"38":1,"68":1,"70":1,"71":1,"72":1,"92":1,"93":1,"94":1,"96":1,"100":3,"130":1,"132":1,"140":2,"158":1,"161":1,"162":3,"163":3,"167":3,"169":1,"171":10,"176":1,"195":3,"196":2,"218":1}}],["console",{"2":{"1":2,"2":1,"3":2,"4":2,"5":1,"6":1,"8":1,"10":2,"11":4,"12":3,"17":3,"50":1,"51":1,"52":2,"101":12,"120":1,"121":1,"130":1,"131":1,"132":1,"133":2,"134":2,"135":2,"136":1,"137":1,"138":1,"139":1,"158":1,"177":5,"185":8,"193":6,"196":1,"202":7,"216":6,"219":2}}],["concat",{"2":{"1":1,"31":1,"32":1}}],["xpoet",{"2":{"185":6}}],["x+3^3^",{"2":{"149":1}}],["x+3",{"2":{"149":1}}],["x+2^2^",{"2":{"149":1}}],["x+2",{"2":{"149":1}}],["x+1^2^",{"2":{"149":1}}],["x+1",{"2":{"149":1}}],["x",{"2":{"149":2,"154":1}}],["xx",{"2":{"101":2}}],["x26",{"2":{"10":2,"17":2,"22":10,"23":10,"39":2,"40":2,"41":2,"42":4,"43":4,"78":2,"82":2,"163":2,"167":2,"170":2,"171":2}}],["x3c",{"2":{"2":2,"6":1,"9":1,"10":1,"11":2,"12":2,"14":1,"15":1,"16":2,"17":8,"25":4,"26":1,"29":1,"32":2,"34":1,"35":2,"37":2,"38":3,"39":2,"40":2,"41":6,"42":5,"43":5,"44":7,"45":3,"68":1,"76":2,"77":1,"79":2,"82":3,"93":2,"94":2,"95":2,"100":4,"116":2,"117":1,"119":1,"120":1,"121":2,"132":4,"133":2,"135":2,"136":2,"140":10,"161":1,"163":2,"167":1,"169":4,"170":1,"171":3,"176":2,"195":1}}],["radixsort",{"2":{"44":2}}],["random",{"2":{"17":1}}],["r",{"2":{"23":6,"223":1}}],["rob",{"2":{"26":1}}],["robber",{"2":{"26":1}}],["root",{"2":{"21":5,"23":5,"66":2,"68":13,"70":1,"71":1,"72":1,"75":4,"76":4,"77":1,"78":4,"79":10,"81":2,"82":11,"223":1}}],["row++",{"2":{"10":1}}],["row",{"2":{"10":3}}],["rightsibling",{"2":{"227":3}}],["rightlength",{"2":{"41":3}}],["rightarray",{"2":{"41":5}}],["right",{"2":{"17":11,"21":2,"22":2,"23":3,"38":3,"41":2,"66":4,"68":3,"70":1,"71":1,"72":1,"75":2,"76":2,"77":1,"78":3,"79":14,"81":7,"82":18}}],["rear",{"2":{"187":1}}],["removeat",{"0":{"95":1,"136":1},"2":{"89":1,"95":3,"96":1,"100":4,"101":3,"127":1,"136":3,"137":1,"140":3}}],["remove",{"0":{"137":1,"163":1},"2":{"67":1,"82":1,"89":1,"100":3,"101":3,"127":1,"137":3,"140":2,"157":1,"163":2,"167":1,"170":2,"171":2,"182":1,"184":2,"185":2,"200":1,"201":2,"202":2,"208":2}}],["resize",{"0":{"167":1},"2":{"157":1,"161":1,"163":1,"167":4,"170":2,"171":3}}],["res",{"2":{"20":3,"31":3,"32":3,"116":5}}],["result",{"2":{"1":3,"2":4,"8":5,"17":7,"41":6,"70":8,"71":8,"72":8,"96":2,"97":3,"98":3,"100":8,"120":3,"121":3,"131":3,"140":3,"176":3,"192":3,"215":3}}],["rec",{"2":{"20":4}}],["reverse",{"2":{"7":1}}],["reversestr",{"2":{"7":2}}],["replace",{"2":{"7":1}}],["regexp",{"2":{"9":1}}],["reg",{"2":{"7":2}}],["reduce",{"2":{"1":1,"8":2}}],["return",{"2":{"1":5,"2":4,"4":2,"5":3,"6":3,"7":1,"8":4,"9":2,"10":3,"11":4,"12":4,"14":4,"15":5,"16":4,"17":8,"20":5,"21":2,"22":3,"23":5,"25":4,"26":2,"28":2,"29":1,"31":3,"32":2,"34":2,"35":2,"37":2,"38":2,"39":2,"40":2,"41":3,"42":2,"43":2,"44":2,"45":1,"70":2,"71":2,"72":2,"75":4,"76":7,"77":1,"81":1,"82":2,"93":2,"94":2,"95":2,"96":1,"97":1,"98":1,"100":12,"116":1,"119":1,"131":1,"132":2,"133":2,"134":2,"135":2,"136":2,"138":1,"139":1,"140":13,"158":1,"161":2,"162":4,"163":2,"164":1,"165":1,"169":6,"170":1,"171":10,"176":5,"184":6,"192":5,"195":1,"201":6,"204":1,"205":1,"206":1,"207":2,"208":11,"215":5,"218":1}}],["基本可以瞬间查找到想要的元素",{"2":{"142":1}}],["基本思想",{"2":{"37":1,"38":1,"39":1,"40":1,"42":1,"43":1,"45":1}}],["基本思想是采用辗转相除的方法",{"2":{"4":1}}],["基于链表实现",{"2":{"190":1}}],["基于数组实现",{"2":{"190":1}}],["基于栈",{"2":{"119":1}}],["基于队列",{"2":{"119":1}}],["基于第二种方式",{"2":{"10":1}}],["基数排序是一种非比较型整数排序算法",{"2":{"44":1}}],["基数排序",{"0":{"44":1},"2":{"40":1}}],["第",{"2":{"26":1,"65":4}}],["第三次找",{"2":{"65":1}}],["第三种方法是维护一个容量为",{"2":{"17":1}}],["第三项以后的值都等于前面两项的和",{"2":{"11":1}}],["第二次哈希化需要满足以下两点",{"2":{"150":1}}],["第二次找",{"2":{"65":1}}],["第二个参数为",{"2":{"50":1}}],["第二种方案",{"2":{"143":1}}],["第二种方式是利用递增序列的特点",{"2":{"10":1}}],["第二种思路是由于我们只需要获得最小的",{"2":{"17":1}}],["第二项为",{"2":{"11":1}}],["第一个弹出栈空间",{"2":{"210":1}}],["第一个顶点和最后一个顶点相同的路径称为回路",{"2":{"105":1}}],["第一步",{"2":{"77":1,"170":1}}],["第一次找",{"2":{"65":1}}],["第一层确定增量的大小",{"2":{"40":1}}],["第一种方案",{"2":{"143":1}}],["第一种方式是使用两层循环依次遍历",{"2":{"10":1}}],["第一种思路是首先将数组排序",{"2":{"17":1}}],["第一项为",{"2":{"11":1}}],["overflow",{"2":{"211":1}}],["otherset",{"2":{"204":3,"205":3,"206":3,"207":3,"208":12}}],["out",{"2":{"187":1,"210":1}}],["output",{"2":{"177":2}}],["object",{"2":{"184":2,"197":1,"201":2,"208":2}}],["oldstorage",{"2":{"166":2,"167":3,"171":3}}],["of",{"2":{"158":1,"162":1,"167":2,"171":3,"176":1,"192":1,"195":1,"204":2,"205":1,"206":1,"207":1,"208":5,"215":1}}],["or",{"2":{"20":1}}],["o",{"2":{"10":2,"11":2,"14":2,"15":2,"16":2,"17":3,"20":2,"21":2,"22":2,"23":2,"25":3,"34":1,"35":1,"37":4,"38":4,"39":4,"40":4,"41":6,"42":10,"43":6,"44":3,"45":3,"46":1,"83":6,"125":1,"142":1,"154":3}}],["思路",{"2":{"10":1,"11":1,"12":1,"17":1,"20":1,"21":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1}}],["输入",{"2":{"17":1}}],["输入这样的一个二维数组和一个整数",{"2":{"10":1}}],["输出深度优先",{"2":{"121":1}}],["输出图结构",{"2":{"116":1}}],["输出节点的顺序应为",{"2":{"71":1,"72":1}}],["输出",{"2":{"5":1,"10":2,"11":4,"12":3,"17":3}}],[">>",{"2":{"40":2,"41":1,"43":1}}],[">=",{"2":{"10":1,"28":1,"39":1,"40":2,"42":2,"43":1,"44":1,"45":1,"133":1,"135":1,"136":1,"140":3}}],[">",{"2":{"9":1,"10":1,"20":1,"29":1,"35":1,"37":2,"38":1,"39":1,"40":1,"43":1,"44":1,"50":1,"51":1,"52":2,"76":2,"93":1,"94":1,"95":1,"100":2,"101":2,"116":1,"131":1,"132":2,"133":2,"134":2,"135":2,"136":2,"137":1,"138":1,"139":1,"140":2,"158":2,"161":2,"163":1,"167":3,"170":3,"171":3,"177":5,"185":6,"193":6,"195":1,"196":1,"202":7,"216":6,"218":1,"219":2}}],["vn",{"2":{"105":1}}],["v2",{"2":{"105":1}}],["v1",{"2":{"105":1}}],["v",{"2":{"104":1,"115":2,"120":8,"121":2}}],["vertexes",{"2":{"112":2,"114":1,"116":3,"119":2,"120":2,"121":3}}],["vertex",{"2":{"104":2}}],["visited",{"2":{"9":2}}],["val2",{"2":{"115":3}}],["val1",{"2":{"115":3}}],["values",{"2":{"182":1,"184":2,"185":2,"200":1,"201":2,"202":3,"204":2,"205":1,"206":1,"207":1,"208":7}}],["value",{"0":{"161":1},"2":{"15":3,"157":2,"161":7,"162":2,"171":7,"180":2,"182":1,"184":5,"200":3,"201":19,"204":6,"205":4,"206":4,"207":3,"208":36}}],["valueof",{"2":{"8":2}}],["val",{"2":{"6":2,"21":2,"22":2,"23":2,"114":3,"121":5}}],["var",{"2":{"2":1}}],["zxc",{"2":{"202":6}}],["zxcvvv",{"2":{"143":1}}],["zz",{"2":{"101":2}}],["z",{"2":{"9":1,"143":1}}],["type",{"2":{"231":1}}],["tm",{"2":{"223":1}}],["t2",{"2":{"223":1}}],["t1",{"2":{"223":1}}],["tuple",{"2":{"161":6,"162":3,"163":4,"171":13}}],["tuesday",{"2":{"48":4}}],["tail",{"2":{"88":1,"91":2,"92":4,"93":4,"94":4,"95":5,"98":1,"100":15}}],["targetindex++",{"2":{"93":1,"94":1,"95":1,"100":2}}],["targetindex",{"2":{"93":1,"94":1,"95":1,"100":2,"196":2}}],["target",{"2":{"10":3}}],["tl",{"2":{"55":1,"56":1}}],["t",{"2":{"44":2}}],["time",{"2":{"29":1}}],["temp",{"2":{"16":4,"25":2,"38":2,"39":3,"40":3,"43":2,"169":2}}],["thursday",{"2":{"48":4}}],["this",{"2":{"34":2,"35":2,"66":3,"68":7,"70":4,"71":4,"72":4,"75":4,"76":5,"77":1,"78":4,"79":8,"81":3,"82":10,"91":4,"92":7,"93":15,"94":15,"95":15,"96":2,"97":1,"98":1,"100":42,"112":2,"114":2,"115":2,"116":4,"119":2,"120":3,"121":7,"129":1,"130":5,"131":1,"132":6,"133":2,"134":1,"135":2,"136":5,"137":2,"138":1,"139":1,"140":27,"160":3,"161":10,"162":2,"163":10,"164":1,"165":1,"166":2,"167":19,"170":13,"171":35,"176":9,"184":11,"192":7,"201":9,"204":2,"205":1,"206":1,"207":1,"208":14,"215":8,"227":9}}],["than",{"2":{"11":1}}],["the",{"2":{"11":1}}],["trun",{"2":{"89":1,"127":1,"157":1}}],["true",{"2":{"10":2,"22":2,"23":3,"37":1,"43":1,"67":1,"76":3,"77":2,"79":2,"82":2,"93":1,"94":1,"100":1,"169":2,"176":1,"182":1,"185":1,"191":1,"200":1,"201":2,"202":1,"207":2,"208":4,"214":1}}],["tr",{"2":{"55":1,"56":1}}],["treemap",{"2":{"181":1}}],["tree",{"2":{"22":1,"23":1,"59":2,"60":1,"64":1,"223":1,"233":1}}],["trim",{"2":{"9":1}}],["tony",{"2":{"196":1}}],["tom",{"2":{"180":2,"196":1}}],["to",{"2":{"29":1}}],["tolowercase",{"2":{"7":1,"9":1}}],["tostring",{"0":{"116":1,"131":1},"2":{"1":2,"89":2,"116":1,"127":2,"131":2,"132":1,"135":2,"136":1,"137":1,"140":2,"176":3,"177":2,"191":1,"192":2,"193":2,"214":1,"215":2,"216":2}}],["参数处理",{"2":{"9":1}}],["如图",{"2":{"226":1}}],["如何以高效的方式组织和存储呢",{"2":{"232":1}}],["如何进行扩容",{"2":{"166":1}}],["如何查找一篇英文文章中出现频率最高的单词",{"0":{"9":1}}],["如哈希表中还没插入任何元素时",{"2":{"148":1}}],["如",{"2":{"143":1,"181":1,"224":1}}],["如上图树的深度为",{"2":{"224":1}}],["如上图树的度为",{"2":{"224":1}}],["如上图节点",{"2":{"224":1}}],["如上图的",{"2":{"224":1}}],["如上图中",{"2":{"148":1}}],["如上图就是一张无权图",{"2":{"105":1}}],["如上图所示",{"2":{"64":1,"70":1}}],["如节点",{"2":{"79":6}}],["如下图所示",{"2":{"57":1,"75":1,"78":2,"83":1,"146":1}}],["如此反复执行",{"2":{"43":1}}],["如果栈里没有任何元素就返回",{"2":{"214":1}}],["如果值在集合中",{"2":{"200":1}}],["如果队列中不包含任何元素",{"2":{"191":1}}],["如果集合不存在该",{"2":{"184":1,"201":1,"208":1}}],["如果某个键值存在于这个字典中",{"2":{"182":1}}],["如果遍历完所有元素",{"2":{"176":1}}],["如果等于",{"2":{"162":1}}],["如果为空",{"2":{"176":1}}],["如果为",{"2":{"162":1,"163":1}}],["如果为数组则递归调用",{"2":{"1":1}}],["如果已经有值了",{"2":{"161":1}}],["如果已经存在就直接使用",{"2":{"15":1}}],["如果原来已经存在该",{"2":{"161":1}}],["如果原来不存在该",{"2":{"161":1}}],["如果哈希表长度大于",{"2":{"157":1}}],["如果哈希表中不包含任何元素",{"2":{"157":1}}],["如果使用大",{"2":{"154":1}}],["如果发生冲突",{"2":{"150":1}}],["如果之前的数据是连续插入的",{"2":{"149":1}}],["如果没有发生冲突",{"2":{"150":1}}],["如果没有发生交换",{"2":{"37":1}}],["如果没有",{"2":{"134":1,"140":1,"161":1,"184":1}}],["如果相邻点未未访问状态",{"2":{"121":1}}],["如果图是一个稀疏图",{"2":{"109":1}}],["如果你找一本专门讲图的各个方面的书籍",{"2":{"105":1}}],["如果你猜错了",{"2":{"20":1}}],["如果链表长度大于",{"2":{"89":1,"127":1}}],["如果链表中不包含任何元素",{"2":{"89":1,"127":1}}],["如果链表中没有该元素就返回",{"2":{"89":1,"127":1}}],["如果要删除的节点有两个子节点",{"2":{"80":1}}],["如果节点存在",{"2":{"67":1}}],["如果树中的每一个节点最多只能有两个子节点",{"2":{"54":1}}],["如果未被更新",{"2":{"43":1}}],["如果最大元素被更新了",{"2":{"43":1}}],["如果右子元素存在",{"2":{"43":1}}],["如果左子元素存在",{"2":{"43":1}}],["如果是一个无向图",{"2":{"109":1}}],["如果是排序好的数组",{"2":{"65":1}}],["如果是右边数组还有剩余",{"2":{"41":1}}],["如果是左边数组还有剩余",{"2":{"41":1}}],["如果比需要排序的元素大",{"2":{"39":1}}],["如果比最大值小",{"2":{"17":1}}],["如果目标值大于或者小于中间元素",{"2":{"35":1}}],["如果中间元素正好是目标值",{"2":{"35":1}}],["如果不存在",{"2":{"67":1}}],["如果不为空",{"2":{"64":1}}],["如果不是数组或者数组长度小于等于",{"2":{"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1}}],["如果不是则加入结果数组中",{"2":{"1":1}}],["如果不行",{"2":{"30":1}}],["如果当前元素大于等于",{"2":{"45":1}}],["如果当前元素小于等于",{"2":{"45":1}}],["如果当前元素比最小元素索引小",{"2":{"38":1}}],["如果当前价格",{"2":{"29":1}}],["如果当前数值比目标值小",{"2":{"10":1}}],["如果当前数值比目标值大",{"2":{"10":1}}],["如果当前数值比所求的数要大",{"2":{"10":1}}],["如果当前数值比所求的数要小",{"2":{"10":1}}],["如果",{"2":{"28":1,"45":1,"120":1,"148":1,"161":2,"171":1}}],["如果两间相邻的房屋在同一晚上被小偷闯入",{"2":{"26":1}}],["如果两个树在结构上相同",{"2":{"22":1}}],["如果上述都成立",{"2":{"23":1}}],["如果根节点的值也相同",{"2":{"22":1}}],["如果大于等于堆的最大值",{"2":{"17":1}}],["如果堆的容量还没有达到",{"2":{"17":1}}],["如果枢纽值的位置小于",{"2":{"17":1}}],["如果该枢纽值的位置为",{"2":{"17":1}}],["+1",{"2":{"148":1,"170":1}}],["+=",{"2":{"29":1,"97":1,"98":1,"100":2,"116":3,"120":1,"121":1,"131":1,"140":1,"176":1,"192":1,"215":1,"218":1}}],["+ak",{"2":{"26":2}}],["+",{"2":{"8":2,"9":7,"11":1,"12":3,"14":1,"15":1,"16":1,"17":3,"20":2,"24":1,"25":4,"26":1,"32":1,"35":2,"37":3,"38":1,"42":1,"43":2,"44":3,"45":2,"57":2,"62":1,"97":1,"98":1,"100":2,"116":2,"120":1,"121":1,"130":1,"131":1,"140":2,"143":9,"158":1,"170":3,"176":3,"192":1,"215":1}}],["+item",{"2":{"1":1}}],["例如输入",{"2":{"17":1}}],["例如",{"2":{"8":1,"143":1,"150":1,"232":1}}],["替换为空字符并将大写字母转换为小写",{"2":{"7":1}}],["匹配所有非单词的字符以及下划线",{"2":{"7":1}}],["wc",{"2":{"173":1,"187":1}}],["was",{"2":{"143":1}}],["white",{"2":{"119":1,"120":1,"121":2}}],["while",{"2":{"10":1,"35":1,"37":1,"39":1,"40":1,"41":3,"42":3,"43":1,"75":2,"76":2,"77":1,"81":1,"82":2,"93":1,"94":1,"95":1,"97":1,"98":1,"100":4,"120":1,"130":2,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"140":7,"170":1,"171":1,"195":1,"218":3}}],["wednesday",{"2":{"48":4}}],["word",{"2":{"9":2}}],["wordlist",{"2":{"9":3}}],["w",{"2":{"7":1,"115":2,"121":3}}],["判断栈是否为空",{"2":{"215":1}}],["判断集合中是否存在",{"2":{"201":1,"208":1}}],["判断字典中是否存在某个",{"2":{"184":1}}],["判断队列是否为空",{"2":{"176":1}}],["判断得到的容量是否为质数",{"2":{"170":1}}],["判断获取到的",{"2":{"162":1,"163":1}}],["判断哈希表是否要扩容",{"2":{"161":1,"167":1,"170":1,"171":1}}],["判断是插入数据操作还是修改数据操作",{"2":{"161":1,"171":1}}],["判断是否在",{"2":{"205":1,"206":1,"207":1,"208":3}}],["判断是否需要调用扩容函数进行压缩",{"2":{"167":1}}],["判断是否需要调用扩容函数进行扩容",{"2":{"167":1}}],["判断是否要进行哈希表压缩",{"2":{"163":1,"167":1,"170":1,"171":1}}],["判断是否存在",{"2":{"161":1,"171":1}}],["判断是否为根节点",{"2":{"81":1,"82":1}}],["判断是否含有该整数",{"2":{"10":1}}],["判断新增还是修改原来的值",{"2":{"161":1}}],["判断链表是否为空",{"2":{"100":1,"138":1,"140":1}}],["判断多种插入情况",{"2":{"93":1,"94":1,"100":1}}],["判断寻找到的后续节点是否直接就是要删除节点的",{"2":{"81":1,"82":1}}],["判断枢纽值的位置",{"2":{"17":1}}],["判断数组中是否含有该整数",{"2":{"10":1}}],["判断一个字符串是否为回文字符串",{"0":{"7":1}}],["判断元素是否为数组",{"2":{"1":1}}],["测试封装的栈结构",{"0":{"216":1}}],["测试代码",{"0":{"117":1,"177":1,"193":1,"196":1},"2":{"117":1,"120":1,"121":1}}],["测试",{"0":{"219":1},"2":{"5":1,"101":9,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1,"177":5,"185":7,"193":6,"196":1,"202":6,"216":6,"219":1}}],["email",{"2":{"185":4}}],["export",{"2":{"176":1}}],["extends",{"2":{"91":2,"100":1,"176":1}}],["enqueue",{"2":{"120":2,"176":3,"177":6,"191":1,"192":2,"193":5,"195":2}}],["endname",{"2":{"195":2}}],["end",{"2":{"42":21}}],["edge",{"2":{"104":1}}],["e",{"2":{"56":1,"57":1,"62":1,"70":1,"104":1,"117":3,"120":1,"121":1,"177":4,"224":2,"226":1,"227":1}}],["element",{"0":{"92":1,"93":1,"94":1},"2":{"35":3,"89":5,"91":2,"92":3,"93":2,"94":2,"100":5,"127":5,"176":7,"177":8,"191":1}}],["else",{"2":{"5":1,"10":2,"11":3,"12":3,"15":1,"35":2,"41":1,"43":1,"44":1,"68":4,"76":4,"77":1,"78":2,"79":6,"81":3,"82":12,"92":1,"93":3,"94":3,"95":3,"100":7,"130":1,"132":1,"136":1,"140":3,"176":1}}],["es6",{"2":{"2":1,"199":1}}],["的对数",{"2":{"237":1}}],["的对应位置",{"2":{"161":1}}],["的定义",{"0":{"235":1}}],["的物理实现",{"2":{"231":1}}],["的路径长度为",{"2":{"224":1}}],["的子节点",{"2":{"224":1}}],["的父节点",{"2":{"224":2}}],["的度为",{"2":{"224":1}}],["的特殊节点",{"2":{"223":1}}],["的特性",{"2":{"20":1}}],["的树",{"2":{"222":1}}],["的所有",{"2":{"204":1,"208":1}}],["的所有非空右子树的键值都大于",{"2":{"64":1}}],["的所有非空左子树的键值都小于",{"2":{"64":1}}],["的人可优先处理",{"2":{"173":1}}],["的平方根即可",{"2":{"169":1}}],["的实现",{"0":{"167":1}}],["的实现思路",{"2":{"68":1}}],["的数组",{"2":{"166":1}}],["的数据",{"2":{"163":1,"171":1}}],["的数字",{"2":{"143":1}}],["的格式",{"2":{"161":1,"171":1}}],["的变量",{"2":{"158":1}}],["的值",{"2":{"158":2}}],["的值就转化为求",{"2":{"154":1}}],["的值等于",{"2":{"42":1}}],["的探测序列",{"2":{"150":1}}],["的探测",{"2":{"149":1}}],["的幂相乘求和",{"2":{"143":1}}],["的节点称为父节点",{"2":{"224":1}}],["的节点",{"2":{"135":1,"136":1,"140":3,"224":1}}],["的情况",{"2":{"132":2,"136":2,"140":4}}],["的递归方法",{"2":{"121":1}}],["的点并设置为访问中状态",{"2":{"120":1}}],["的缩写",{"2":{"112":1}}],["的时间复杂度",{"2":{"142":1}}],["的时间复杂度为",{"2":{"42":1}}],["的时候进行扩容",{"2":{"166":1}}],["的时候",{"2":{"109":1,"130":1,"140":1}}],["的边更远或者用的时间更长",{"2":{"105":1}}],["的边",{"2":{"105":1}}],["的一个连续序列",{"2":{"105":1}}],["的一个元素作为首元素",{"2":{"38":1}}],["的后继时",{"2":{"81":1}}],["的后继",{"2":{"81":1}}],["的前驱",{"2":{"81":1}}],["的左节点",{"2":{"77":1}}],["的左子节点",{"2":{"65":2,"79":2}}],["的左子树中一直向右遍历查找",{"2":{"81":1}}],["的左子树中查找最大值",{"2":{"81":1}}],["的左子树中选择一合适的节点替代节点",{"2":{"80":3}}],["的左子树是否镜像",{"2":{"23":2}}],["的左子树和树",{"2":{"23":2}}],["的右子节点",{"2":{"65":1,"79":2}}],["的右子树节点",{"2":{"81":1,"82":1}}],["的右子树中一直向左遍历查找",{"2":{"81":1}}],["的右子树中查找最小值",{"2":{"81":1}}],["的右子树中选择一合适的节点替代节点",{"2":{"80":3}}],["的右子树和树",{"2":{"23":2}}],["的右子树是否为镜像",{"2":{"23":2}}],["的来源",{"2":{"64":1}}],["的规律",{"2":{"57":1}}],["的非叶子节点",{"2":{"57":1}}],["的非叶子节点个数",{"2":{"57":1}}],["的二叉树的最大节点总数为",{"2":{"57":1}}],["的二叉树",{"2":{"56":2}}],["的两个不相交的二叉树组成",{"2":{"55":1}}],["的位置都放置了数据",{"2":{"148":1}}],["的位置就会停止查找",{"2":{"148":1}}],["的位置就是合适的位置",{"2":{"148":1}}],["的位置存放的数据与需要查询的数据",{"2":{"148":1}}],["的位置起",{"2":{"52":1}}],["的位置的元素为",{"2":{"52":1}}],["的位置",{"2":{"42":2,"50":1}}],["的",{"2":{"40":1,"42":1,"68":1,"83":1,"132":2,"133":1,"134":1,"140":3,"184":1,"197":1}}],["的孩子",{"2":{"28":1}}],["的最大堆",{"2":{"17":1}}],["的最大公约数",{"2":{"5":1}}],["的话",{"2":{"17":2}}],["的乘积的绝对值",{"2":{"5":1}}],["的方式来求两个数的最小公倍数",{"2":{"5":1}}],["和第一个哈希函数不同",{"2":{"150":1}}],["和开放地址法",{"2":{"145":1}}],["和其他数据结构一样",{"2":{"118":1}}],["和右子树",{"2":{"55":1}}],["和斐波那契数列类似",{"2":{"12":1}}],["和",{"2":{"5":2,"12":1,"22":1,"42":2,"45":1,"66":1,"110":1,"132":1,"140":1,"169":1,"181":1,"211":1,"224":4,"226":1}}],["表示就是后进入的元素",{"2":{"210":1}}],["表示时间复杂度的话",{"2":{"154":1}}],["表示新插入后是第二个节点",{"2":{"132":1,"140":1}}],["表示新插入后是第一个节点",{"2":{"132":1,"140":1}}],["表示该顶点被访问过且被完全探索过",{"2":{"119":1}}],["表示该顶点被访问过",{"2":{"119":1}}],["表示该顶点还没有被访问",{"2":{"119":1}}],["表示有连线",{"2":{"109":1}}],["表示没有连线",{"2":{"109":1}}],["表示图中的一个结点",{"2":{"105":1}}],["表示边的集合",{"2":{"104":1}}],["表示顶点的集合",{"2":{"104":1}}],["表示需要删除的节点",{"2":{"80":1}}],["表示叶子节点的个数",{"2":{"57":1}}],["表示插入数据",{"2":{"50":1}}],["表示某支股票第",{"2":{"29":1}}],["表示",{"2":{"5":2,"109":1,"223":1}}],["|a",{"2":{"5":2}}],["||",{"2":{"2":2,"10":1,"17":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":2,"43":1,"44":1,"45":2,"93":1,"94":1,"95":1,"100":2,"132":1,"133":1,"135":1,"136":1,"140":4,"169":1}}],["最普通的表示方法",{"0":{"226":1}}],["最先被添加",{"2":{"191":1}}],["最大值在二叉搜索树的最右边",{"2":{"75":1}}],["最后造成栈溢出",{"2":{"211":1}}],["最后放上的托盘",{"2":{"210":1}}],["最后通过",{"2":{"130":1}}],["最后一个节点的",{"2":{"130":1,"140":1}}],["最后一层的叶子节点从左向右是连续存在",{"2":{"60":1}}],["最后",{"2":{"70":1,"71":1,"72":1,"161":1,"162":1,"163":1,"166":1}}],["最后的被除数就是两个数的最大公约数",{"2":{"4":1}}],["最坏的情况是",{"2":{"237":1}}],["最坏的情况",{"2":{"237":1}}],["最坏的时候为",{"2":{"42":1}}],["最坏时间复杂度",{"2":{"45":1}}],["最坏时间复杂度为",{"2":{"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1}}],["最坏情况发生",{"2":{"42":1}}],["最好的情况还是让数据在哈希表中均匀分布",{"2":{"155":1}}],["最好的情况下为",{"2":{"17":1}}],["最好的装填因子取决于存储效率和速度之间的平衡",{"2":{"152":1}}],["最好情况发生",{"2":{"42":1}}],["最终一定能找到出问题的线段",{"2":{"237":1}}],["最终查找到数据",{"2":{"65":1}}],["最终合并为排序好的数组",{"2":{"41":1}}],["最终达到完全有序",{"2":{"37":1}}],["最多",{"2":{"29":1}}],["最小值在二叉搜索树的最左边",{"2":{"75":1}}],["最小的",{"0":{"17":1}}],["最小公倍数可以通过以下公式计算",{"2":{"5":1}}],["gray",{"2":{"120":2,"121":1}}],["graph",{"2":{"112":2,"117":13,"120":2,"121":1,"233":1}}],["greater",{"2":{"11":1}}],["gap",{"2":{"40":9}}],["gt",{"2":{"28":1,"57":2,"65":1,"68":1,"70":8,"71":14,"72":14,"76":1,"104":1,"105":4,"109":2,"166":1,"167":1,"211":6,"212":5,"223":2,"224":1}}],["guessnumber",{"2":{"20":1}}],["guess",{"2":{"20":2}}],["getprime",{"2":{"161":1,"163":1,"167":2,"170":5,"171":4}}],["getdata",{"0":{"133":1},"2":{"100":3,"101":2,"133":3,"140":2}}],["getelement",{"2":{"89":1}}],["getsuccessor",{"2":{"81":2,"82":2}}],["get",{"0":{"162":1},"2":{"15":1,"115":2,"116":1,"120":1,"121":1,"127":1,"157":1,"162":2,"171":2,"182":1,"184":2,"185":2}}],["getclimbingways",{"2":{"14":3,"15":4,"16":2}}],["getmaxcommondivisor",{"2":{"4":4}}],["g",{"2":{"7":1,"9":2,"28":5,"57":1,"62":1,"70":1,"117":3,"120":1,"121":1}}],["gcd",{"2":{"5":7}}],["中文维基百科",{"2":{"231":1}}],["中添加如下代码",{"2":{"167":2}}],["中每一个",{"2":{"162":1,"166":1}}],["中对应的索引值",{"2":{"162":1,"163":1}}],["中使用的就是链地址法",{"2":{"152":1}}],["中取出队列",{"2":{"120":1}}],["中序遍历第二遍历根节点",{"2":{"73":1}}],["中序遍历",{"0":{"71":1},"2":{"69":1,"71":1}}],["中包含存储的数据",{"2":{"63":1}}],["中的每一个数据取出来依次添加到",{"2":{"166":1}}],["中的每一个",{"2":{"166":1}}],["中的",{"2":{"152":1,"155":1,"181":3,"199":1}}],["中的排序",{"2":{"36":1}}],["中的搜索",{"2":{"33":1}}],["中",{"2":{"5":1,"204":2,"208":2}}],["jack",{"2":{"196":1}}],["java",{"2":{"152":1,"155":1,"181":1}}],["javascript",{"0":{"215":1},"2":{"5":3,"33":1,"36":1,"47":1,"89":1,"127":1,"155":2,"197":1}}],["j++",{"2":{"37":1,"38":1,"44":2,"116":1}}],["j",{"2":{"28":4,"37":9,"38":4,"39":7,"40":7,"43":3,"44":8,"57":1,"116":3}}],["jumpstairs",{"2":{"12":4}}],["join",{"2":{"7":1,"9":1}}],["jshashfn",{"2":{"158":1}}],["jssize",{"2":{"139":1,"165":1}}],["jsisempty",{"2":{"138":1,"164":1}}],["jsindexof",{"2":{"134":1}}],["jsinsertnode",{"2":{"68":1}}],["jsremove",{"2":{"137":1}}],["jsremoveat",{"2":{"136":1}}],["jsupdate",{"2":{"135":1}}],["jsgetdata",{"2":{"133":1}}],["jstostring",{"2":{"131":1}}],["jsconsole",{"2":{"158":1}}],["jsconst",{"2":{"3":1,"20":1,"21":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1,"48":2,"50":1,"51":1,"52":2,"101":1,"130":1,"177":1,"185":1,"193":1,"202":1}}],["jsclass",{"2":{"100":1,"112":1,"129":1,"140":1,"160":1,"171":1,"192":1}}],["jsarray",{"2":{"34":1,"35":1}}],["jslet",{"2":{"15":1,"77":1}}],["js",{"2":{"10":1,"46":1,"66":1,"68":1,"70":1,"71":1,"72":1,"75":1,"76":1,"78":1,"79":1,"81":1,"82":1,"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"114":1,"115":1,"116":1,"117":1,"119":1,"120":2,"121":2,"130":1,"131":1,"132":2,"133":1,"134":1,"135":1,"136":1,"137":1,"138":1,"139":1,"161":1,"162":1,"163":1,"167":3,"170":3,"176":1,"184":1,"195":1,"196":1,"201":1,"204":1,"205":1,"206":1,"207":1,"208":1,"215":1,"216":1,"219":1,"227":1}}],["jsfunction",{"2":{"1":2,"2":1,"4":1,"6":1,"7":1,"8":1,"9":1,"11":1,"12":1,"14":1,"16":1,"17":3,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"169":2,"218":1}}],["在代码实现中谁是父节点并没有关系",{"2":{"228":1}}],["在字典中删除指定的",{"2":{"184":1}}],["在字典中添加键值对",{"2":{"184":1}}],["在字典中",{"2":{"180":1}}],["在添加元素过程中",{"2":{"174":1}}],["在哈希表中的删除方法",{"2":{"167":1}}],["在哈希表中的添加方法",{"2":{"167":1}}],["在进行较大数据的与运算时会出现问题",{"2":{"155":1}}],["在设计哈希表时",{"2":{"155":1}}],["在中国霍纳法则也叫做秦久韶算法",{"2":{"154":1}}],["在开发中使用链地址法较多",{"2":{"152":1}}],["在开放地址法中寻找空白单元格的最好的解决方式为再哈希化",{"2":{"150":1}}],["在实际中",{"2":{"145":1}}],["在实际开发中",{"2":{"86":1}}],["在当前节点和当前节点的上一节点之间插入新节点",{"2":{"132":1,"140":1}}],["在当前已排序序列中比较",{"2":{"39":1}}],["在指定的位置插入元素",{"2":{"176":1}}],["在指定位置",{"2":{"132":1,"140":1}}],["在指定索引位置插入元素",{"2":{"50":1}}],["在最后面添加新节点",{"2":{"130":1,"140":1}}],["在最后一个位置插入",{"2":{"93":1,"94":1,"100":1}}],["在我们需要时",{"2":{"118":1}}],["在二维数组中",{"2":{"109":1}}],["在二叉搜索树中",{"2":{"81":1}}],["在二叉搜索树中查找最值非常简单",{"2":{"75":1}}],["在二叉树中",{"2":{"59":1}}],["在后面的案例中",{"2":{"108":1}}],["在数组开头或中间位置插入数据的成本很高",{"2":{"124":1}}],["在数组首位插入一个元素",{"2":{"50":1}}],["在数学的概念上",{"2":{"104":1}}],["在数学上起源于哥尼斯堡七桥问题",{"2":{"103":1}}],["在计算机程序设计中",{"2":{"103":1}}],["在第",{"2":{"93":1,"94":1,"100":1}}],["在保证删除节点",{"2":{"80":3}}],["在树中查找一个键",{"2":{"67":1}}],["在排序好的数组中查询数据",{"2":{"65":1}}],["在上图中",{"2":{"60":1}}],["在索引",{"2":{"50":1,"52":1}}],["在一开始序列为无序序列时",{"2":{"40":1}}],["在一个二维数组中",{"2":{"10":1}}],["在还未完全确定当前最小元素之前",{"2":{"38":1}}],["在算法实现时",{"2":{"38":1}}],["在每一天",{"2":{"29":1}}],["在",{"2":{"5":1,"93":1,"94":1,"96":1,"100":2,"132":1,"140":1,"170":1,"211":1}}],["black",{"2":{"120":1,"121":1}}],["bfs",{"0":{"120":1},"2":{"119":2,"120":3}}],["breadth",{"2":{"119":1}}],["break",{"2":{"17":1,"37":1,"43":1,"176":1}}],["backwardstring",{"0":{"98":1},"2":{"98":2,"100":2,"101":2}}],["backwordstring",{"2":{"89":1}}],["backtrack",{"2":{"31":3,"32":3}}],["bst",{"2":{"64":1}}],["binarystring",{"2":{"218":3}}],["binarysearch",{"2":{"35":2}}],["binary",{"2":{"59":2,"60":1,"64":1}}],["bb",{"2":{"52":3,"131":1,"132":1,"135":2}}],["bucket",{"2":{"44":7,"161":14,"162":7,"163":9,"166":2,"167":3,"171":23}}],["buildmaxheap",{"2":{"43":2}}],["bubblesort",{"2":{"37":2}}],["buy",{"2":{"29":1}}],["best",{"2":{"29":1}}],["be",{"2":{"11":1}}],["b|",{"2":{"5":2}}],["b",{"2":{"4":4,"5":12,"16":4,"17":6,"28":2,"45":4,"56":1,"57":1,"62":2,"70":1,"104":2,"108":4,"109":2,"110":1,"117":4,"120":1,"121":1,"130":1,"143":1,"167":3,"171":3,"177":4,"193":2,"211":7,"212":2,"224":6,"226":2,"227":2}}],["时将该元素删除",{"2":{"194":1}}],["时就会发现",{"2":{"148":1}}],["时不会跳过空位置去插入其他位置",{"2":{"148":1}}],["时间复杂度可以达到",{"2":{"125":1}}],["时间复杂度也是",{"2":{"83":1}}],["时间复杂度都为",{"2":{"38":1,"42":1}}],["时间复杂度",{"2":{"25":1}}],["时间复杂度降为了",{"2":{"11":1}}],["时",{"2":{"4":1,"40":1,"50":1,"130":3,"140":3,"148":3,"161":1,"167":2,"195":2,"223":1}}],["0~9",{"2":{"146":1}}],["000",{"2":{"237":5}}],["00",{"2":{"101":1}}],["0",{"2":{"4":2,"5":1,"6":1,"8":2,"9":2,"10":4,"11":6,"12":2,"14":6,"15":1,"16":2,"17":6,"20":1,"26":4,"28":1,"29":1,"32":2,"34":1,"35":1,"37":2,"38":1,"39":2,"40":1,"41":4,"42":1,"43":4,"44":9,"45":3,"50":5,"89":1,"93":5,"94":5,"95":4,"100":9,"101":3,"105":15,"109":3,"116":2,"117":1,"119":1,"120":3,"121":2,"127":1,"129":2,"130":3,"132":10,"133":3,"134":1,"135":3,"136":5,"138":1,"140":25,"150":2,"157":1,"158":1,"160":1,"161":3,"162":1,"163":2,"164":1,"166":1,"167":5,"169":2,"170":1,"171":12,"176":2,"192":2,"195":1,"215":1,"218":2,"223":4,"224":2}}],["求两个集合的交集",{"2":{"205":1,"208":1}}],["求两个集合的并集",{"2":{"204":1,"208":1}}],["求两个数的最小公倍数",{"0":{"5":1}}],["求两个数的最大公约数",{"0":{"4":1}}],["求多项式的值时",{"2":{"154":1}}],["求该青蛙跳上一个",{"2":{"12":1}}],["求数组的最大值和最小值",{"0":{"3":1}}],["myvertexes",{"2":{"117":3}}],["myarray4",{"2":{"52":3}}],["myarray3",{"2":{"52":3}}],["myarray2",{"2":{"51":3}}],["myarray",{"2":{"50":3}}],["m",{"2":{"62":1,"223":2}}],["monday",{"2":{"48":4}}],["merge",{"2":{"41":2}}],["mergesort",{"2":{"41":4}}],["mid",{"2":{"20":5,"35":5,"41":3}}],["minloadfactor",{"2":{"163":1,"167":1,"170":1,"171":2}}],["minindex",{"2":{"38":4}}],["min",{"2":{"3":1,"38":1,"45":8,"67":1,"75":2}}],["matrix",{"2":{"10":9}}],["match",{"2":{"9":2}}],["mathlcm",{"2":{"5":1}}],["math",{"2":{"3":2,"5":1,"17":2,"20":1,"26":1,"35":1,"163":1,"167":1,"169":2,"170":1,"171":1,"218":1}}],["maxprofit",{"2":{"29":1}}],["maxword",{"2":{"9":3}}],["maxnum",{"2":{"9":4}}],["max",{"2":{"3":1,"26":3,"44":4,"45":10,"67":1,"75":2}}],["map",{"2":{"1":1,"15":5,"114":1,"181":1,"184":1,"185":14,"191":1}}],["names",{"2":{"196":3}}],["namelist",{"2":{"195":4}}],["name",{"2":{"180":1,"185":4,"195":2}}],["n+1",{"2":{"154":1}}],["n+k",{"2":{"45":3}}],["next",{"2":{"88":2,"92":1,"93":5,"94":5,"95":6,"97":1,"100":13,"129":1,"130":7,"131":1,"132":5,"133":1,"134":1,"135":1,"136":6,"140":22}}],["newlimit",{"2":{"167":2,"171":2}}],["newnode",{"2":{"68":8,"92":6,"93":14,"94":14,"100":20,"130":5,"132":7,"140":10}}],["newpivotindex",{"2":{"17":6}}],["newstr",{"2":{"7":3}}],["new",{"2":{"2":1,"9":1,"15":1,"48":2,"68":1,"92":1,"93":1,"94":1,"100":2,"101":1,"112":1,"117":1,"120":1,"130":2,"132":1,"140":2,"176":1,"177":1,"185":1,"193":1,"195":2,"202":1,"204":1,"205":1,"206":1,"208":3,"218":2}}],["node",{"2":{"63":2,"66":1,"68":15,"70":5,"71":5,"72":5,"75":10,"76":16,"89":1,"91":2,"127":1,"129":2,"130":1,"132":1,"140":4,"227":3}}],["n~2~",{"2":{"57":2}}],["n~2~表示度为",{"2":{"57":1}}],["n~0~",{"2":{"57":3}}],["nk",{"2":{"44":2}}],["n^s",{"2":{"40":1}}],["n^2",{"2":{"10":1,"40":1,"154":1}}],["n²",{"2":{"37":2,"38":3,"39":2,"42":2}}],["nlogk",{"2":{"17":1}}],["nlogn",{"2":{"17":1,"40":1,"41":3,"42":3,"43":3}}],["n",{"2":{"10":1,"11":10,"12":16,"14":6,"15":11,"16":6,"17":5,"20":3,"21":2,"22":2,"23":2,"24":4,"25":20,"26":1,"28":3,"31":3,"34":1,"37":1,"39":1,"40":1,"41":4,"42":7,"43":4,"44":1,"46":1,"83":6,"116":1,"154":7,"155":1,"223":4}}],["nums",{"2":{"17":41,"26":5,"31":3,"32":5}}],["number++",{"2":{"170":1,"171":1}}],["number",{"2":{"11":1,"20":1,"52":1,"169":11,"170":5,"171":5,"194":2,"195":9}}],["num",{"2":{"9":3,"169":2}}],["null",{"2":{"3":2,"21":1,"66":2,"68":3,"70":1,"71":1,"72":1,"75":4,"76":3,"77":2,"78":8,"79":4,"81":1,"82":10,"88":2,"91":2,"92":1,"93":2,"94":2,"95":6,"97":1,"98":1,"100":12,"126":2,"129":3,"130":2,"131":1,"132":2,"133":1,"136":2,"140":11,"148":2,"162":6,"163":5,"171":3,"227":3}}],["algorithm",{"0":{"235":1},"2":{"236":1}}],["age",{"2":{"180":1,"185":5}}],["abc",{"2":{"134":1,"158":1,"202":5}}],["abstract",{"2":{"231":1}}],["abs",{"2":{"5":1}}],["append",{"0":{"92":1,"130":1},"2":{"89":1,"92":3,"100":3,"101":4,"127":1,"130":6,"140":2}}],["apply",{"2":{"3":2}}],["avl",{"2":{"83":3}}],["amp",{"0":{"81":1},"2":{"155":1}}],["aaaaaaaaaa",{"2":{"143":1}}],["aa",{"2":{"52":6,"131":1,"132":1,"133":1,"134":1,"135":1}}],["adt",{"2":{"231":1}}],["adjoin",{"2":{"112":1}}],["adj",{"2":{"112":1,"116":3,"121":3}}],["adjlist",{"2":{"112":3,"114":1,"115":2,"116":1,"120":1,"121":1}}],["adjustmaxheap",{"2":{"43":3}}],["address",{"2":{"185":1}}],["added",{"2":{"176":3}}],["addedge",{"2":{"115":1,"117":10}}],["addvertex",{"2":{"114":1,"117":1}}],["add",{"2":{"8":4,"200":1,"201":2,"202":5,"204":3,"205":1,"206":1,"208":7}}],["and",{"2":{"29":1}}],["assign",{"2":{"28":1}}],["ak",{"2":{"26":1}}],["article",{"2":{"9":7}}],["args",{"2":{"8":4}}],["arr",{"2":{"3":3,"37":12,"45":17}}],["array",{"2":{"1":7,"2":10,"6":5,"37":1,"38":14,"39":11,"40":11,"41":7,"42":17,"43":23,"44":14,"48":2,"50":3,"51":3,"52":2,"233":1}}],["a",{"2":{"4":3,"5":11,"9":1,"16":3,"17":6,"28":2,"50":3,"56":1,"57":1,"62":2,"70":1,"104":2,"108":4,"109":4,"110":3,"117":4,"120":5,"121":1,"130":1,"143":1,"177":2,"193":2,"211":8,"212":2,"224":1,"226":1,"227":1}}],["88",{"2":{"219":1}}],["89",{"2":{"15":1,"16":1}}],["8",{"2":{"3":1,"4":1,"14":2,"17":5,"35":1,"62":2,"71":1,"72":1,"78":2,"80":2,"81":1}}],["sibling",{"2":{"224":1}}],["size",{"0":{"139":1,"165":1},"2":{"89":1,"100":3,"127":1,"139":3,"140":2,"157":1,"171":1,"176":4,"177":2,"182":1,"184":2,"185":2,"191":1,"192":2,"193":2,"195":1,"200":1,"201":2,"202":2,"208":2,"214":1,"215":2,"216":2}}],["swift",{"2":{"181":1}}],["swap",{"2":{"38":2,"43":3}}],["sqrt",{"2":{"169":1}}],["shift",{"2":{"51":1,"192":1}}],["should",{"2":{"11":1}}],["saturday",{"2":{"48":4}}],["same",{"2":{"22":1}}],["splice",{"2":{"44":1,"50":3,"51":2,"52":4,"163":1,"171":1,"176":1}}],["split",{"2":{"1":1,"7":1}}],["subtree",{"2":{"223":1}}],["subset",{"2":{"207":2,"208":2}}],["subsets",{"2":{"32":2}}],["super",{"2":{"91":2,"100":6,"176":5}}],["successorparent",{"2":{"81":3,"82":3}}],["successor",{"2":{"81":12,"82":12}}],["sunday",{"2":{"48":4}}],["sum",{"2":{"8":2}}],["s",{"2":{"28":5}}],["symmetric",{"2":{"23":1}}],["stepsize",{"2":{"150":2}}],["stack",{"2":{"210":1,"211":1,"215":1,"216":9,"218":6,"233":1}}],["start++",{"2":{"42":1}}],["start",{"2":{"32":2,"42":24,"51":1}}],["stairs",{"2":{"25":1}}],["storage",{"2":{"160":1,"161":4,"162":2,"163":2,"166":4,"167":4,"171":10}}],["storeindex++",{"2":{"17":1}}],["storeindex",{"2":{"17":6}}],["stock",{"2":{"29":1}}],["structure",{"2":{"231":1}}],["string",{"2":{"158":2}}],["str",{"2":{"7":2,"44":4}}],["slice",{"2":{"17":1,"41":2}}],["sortfunc",{"2":{"28":3}}],["sortednums",{"2":{"17":2}}],["sort",{"2":{"17":3,"28":2,"36":1}}],["search2",{"2":{"76":1}}],["searchnode",{"2":{"76":4}}],["search",{"2":{"64":1,"67":1,"76":2,"119":2}}],["searchinsortedmatrix",{"2":{"10":3}}],["sequentialsearch",{"2":{"34":1}}],["sell",{"2":{"29":1}}],["selectsort",{"2":{"38":2}}],["select",{"2":{"17":4}}],["set",{"2":{"2":1,"15":1,"114":1,"182":1,"184":2,"185":4,"199":2,"201":1,"202":15,"204":1,"205":1,"206":1,"208":4}}],["peek",{"2":{"191":1,"214":1,"215":2,"216":2}}],["perv",{"2":{"93":1,"94":1,"95":1,"100":2}}],["perfect",{"2":{"59":1}}],["permute",{"2":{"31":1}}],["permutations",{"2":{"31":1}}],["python",{"2":{"181":1}}],["put",{"0":{"161":1},"2":{"157":1,"161":2,"167":2,"170":2,"171":4}}],["push",{"2":{"2":1,"17":1,"31":1,"32":1,"41":4,"44":3,"50":1,"70":1,"71":1,"72":1,"114":1,"115":2,"161":1,"167":1,"171":1,"176":2,"192":1,"214":1,"215":3,"216":4,"218":1}}],["position",{"0":{"93":1,"94":1,"95":1,"96":1},"2":{"89":4,"93":8,"94":8,"95":7,"96":6,"100":23,"127":4,"132":13,"133":7,"135":8,"136":11,"140":36}}],["postordertraversalnode",{"2":{"72":4}}],["postordertraversal",{"2":{"72":1}}],["postordertraverse",{"2":{"67":1}}],["pop",{"2":{"51":1,"214":1,"215":3,"216":2,"218":1}}],["passgame",{"2":{"195":1,"196":2}}],["parentnode",{"2":{"77":3,"78":2,"79":8,"81":2,"82":15}}],["parent",{"2":{"77":2,"78":2,"79":8,"224":1}}],["parseint",{"2":{"40":2,"41":1,"43":1,"44":1}}],["partition",{"2":{"17":3,"42":2}}],["path",{"2":{"31":5,"32":4}}],["p",{"2":{"22":7}}],["priorityqueue",{"2":{"176":1,"177":14}}],["priority",{"2":{"176":10,"177":8}}],["prime",{"2":{"158":2}}],["prices",{"2":{"29":8}}],["prototype",{"2":{"34":1,"35":1}}],["profit",{"2":{"29":3}}],["problems",{"2":{"20":1,"22":1,"23":1,"25":1,"26":1,"28":1,"29":1,"31":1,"32":1}}],["preordertraversalnode",{"2":{"70":4}}],["preordertraversal",{"2":{"70":1}}],["preordertraverse",{"2":{"67":1}}],["previousnode",{"2":{"93":4,"94":4,"95":4,"100":8,"132":4,"136":3,"140":7}}],["prev",{"2":{"11":5,"88":2,"91":2,"92":1,"93":3,"94":3,"95":3,"98":1,"100":8}}],["prevprev",{"2":{"11":3}}],["pre",{"2":{"1":2,"8":4}}],["pivot",{"2":{"42":4}}],["pivotvalue",{"2":{"17":2}}],["pivotindex",{"2":{"17":6}}],["利用栈结构的特点封装实现十进制转换为二进制的方法",{"2":{"217":1}}],["利用队列结构的特点实现击鼓传花游戏求解方法的封装",{"2":{"195":1}}],["利用",{"2":{"1":1}}],["654",{"2":{"212":1}}],["65432",{"2":{"212":1}}],["654321",{"2":{"212":2}}],["6543",{"2":{"143":1,"212":1}}],["65",{"2":{"180":1,"212":1}}],["63",{"2":{"149":1}}],["63245986",{"2":{"11":1}}],["60337",{"2":{"143":1}}],["6",{"2":{"1":4,"3":1,"5":1,"12":1,"17":4,"35":1,"37":2,"38":2,"39":2,"40":2,"41":2,"42":2,"43":2,"44":2,"45":2,"52":4,"62":2,"64":4,"71":1,"72":1,"79":1,"83":1,"105":1,"143":1,"148":1,"158":1,"212":11}}],["54321",{"2":{"135":2,"136":1,"137":1}}],["5设置访问完的点为黑色",{"2":{"120":1}}],["55",{"2":{"11":1}}],["500",{"2":{"237":1}}],["50",{"2":{"10":1}}],["5",{"2":{"1":4,"2":2,"6":1,"10":1,"12":1,"17":4,"35":1,"37":2,"38":2,"39":2,"40":2,"41":2,"42":2,"43":2,"44":2,"45":2,"51":1,"52":4,"57":1,"62":2,"71":1,"72":1,"79":5,"80":1,"81":1,"83":1,"105":3,"143":1,"148":1,"150":2,"158":1,"161":1,"171":1,"195":1,"212":10}}],["43",{"2":{"143":3}}],["45°",{"2":{"228":1}}],["456",{"2":{"132":2,"135":2,"136":1,"137":1,"202":1}}],["455",{"2":{"28":1}}],["46",{"2":{"31":1}}],["4",{"2":{"1":4,"2":2,"3":1,"4":2,"5":1,"6":1,"12":2,"17":12,"35":1,"37":2,"38":2,"39":2,"40":2,"41":2,"42":2,"43":2,"44":2,"45":2,"51":1,"52":3,"57":1,"62":2,"65":2,"79":1,"83":1,"105":2,"108":1,"120":5,"121":1,"143":1,"148":1,"150":1,"161":1,"169":1,"171":1,"195":1,"196":1,"212":10,"224":1}}],["31",{"2":{"158":1}}],["3~7",{"2":{"148":1}}],["33",{"2":{"148":1}}],["374",{"2":{"20":1}}],["39",{"2":{"11":2}}],["34",{"2":{"10":1}}],["30",{"2":{"10":1}}],["3",{"2":{"1":4,"2":3,"6":2,"8":1,"10":2,"11":1,"12":1,"16":1,"17":8,"35":1,"37":2,"38":2,"39":2,"40":2,"41":2,"42":2,"43":2,"44":2,"45":2,"50":2,"51":4,"52":3,"62":2,"64":3,"65":1,"71":1,"72":1,"77":1,"79":2,"81":2,"82":3,"83":1,"93":1,"94":1,"100":1,"101":1,"105":2,"108":1,"120":2,"121":1,"130":1,"132":1,"133":1,"135":1,"136":2,"139":1,"140":5,"143":4,"148":1,"149":1,"158":1,"161":1,"167":1,"171":2,"177":1,"195":1,"204":1,"208":1,"212":10,"216":3,"224":1,"226":1,"232":1}}],["21",{"2":{"212":1}}],["213",{"2":{"149":1}}],["24",{"2":{"148":1}}],["27^2",{"2":{"143":1}}],["27^3",{"2":{"143":1}}],["27",{"2":{"143":3,"148":1}}],["26",{"2":{"143":1,"148":1}}],["22222",{"2":{"101":1}}],["22",{"2":{"101":1}}],["25",{"2":{"71":1,"72":1,"148":1,"167":1,"171":1}}],["2^k^",{"2":{"57":1}}],["2^",{"2":{"57":1}}],["2^n",{"2":{"14":1}}],["20",{"2":{"10":1,"71":1,"72":1,"143":2,"177":4,"237":2}}],["23",{"2":{"3":1,"10":1,"148":1}}],["2",{"2":{"1":4,"2":2,"3":1,"6":2,"8":2,"11":2,"12":11,"13":1,"14":5,"15":3,"16":3,"17":8,"20":1,"23":4,"24":2,"25":11,"26":5,"31":1,"32":1,"35":3,"37":2,"38":2,"39":2,"40":2,"41":2,"42":5,"43":5,"44":2,"45":2,"50":2,"51":4,"52":6,"57":2,"59":1,"62":4,"64":1,"65":1,"68":2,"78":1,"79":12,"80":3,"81":1,"82":12,"83":1,"92":1,"93":1,"94":1,"95":1,"96":1,"100":4,"101":1,"105":2,"108":1,"120":2,"121":2,"124":1,"130":1,"132":2,"133":1,"135":1,"136":1,"140":5,"143":1,"154":1,"158":1,"161":2,"163":1,"167":3,"169":5,"170":4,"171":4,"185":1,"193":1,"195":1,"202":1,"204":1,"205":1,"206":1,"208":3,"212":9,"216":5,"218":2,"224":3,"226":1,"232":5,"237":2}}],["17",{"2":{"143":1,"170":2}}],["19",{"2":{"143":1,"180":2}}],["198",{"2":{"26":1}}],["180°",{"2":{"222":1}}],["18",{"2":{"71":1,"72":1,"80":1,"177":4,"185":5}}],["14",{"2":{"71":1,"72":1,"80":1,"170":3}}],["15",{"2":{"65":2,"71":1,"72":1,"80":6,"83":1,"170":2,"177":4}}],["13",{"2":{"10":1,"12":1,"62":1,"65":4,"71":1,"72":1,"148":9,"149":1}}],["10^2",{"2":{"143":1}}],["10^3",{"2":{"143":1}}],["1011000",{"2":{"219":1}}],["101",{"2":{"23":1}}],["1000000",{"2":{"237":2}}],["1000",{"2":{"142":1}}],["100",{"2":{"22":1,"219":1}}],["10",{"2":{"10":1,"11":1,"13":1,"14":2,"15":1,"16":1,"35":1,"44":2,"46":1,"62":1,"65":14,"71":1,"72":1,"78":2,"80":1,"143":2,"146":1,"148":1,"177":2}}],["1其中",{"2":{"5":1}}],["165",{"2":{"180":1}}],["163",{"2":{"149":1}}],["16",{"2":{"4":1,"10":1,"150":1,"170":2}}],["122",{"2":{"29":1}}],["12",{"2":{"4":2,"5":1,"62":1,"71":1,"72":1,"131":1,"138":1,"139":1,"158":1}}],["123代码测试",{"2":{"137":1,"138":1,"139":1}}],["1234在",{"2":{"170":1}}],["12345",{"2":{"135":4,"136":1,"137":1}}],["123456",{"2":{"112":1,"120":1,"130":1}}],["1234567时间复杂度",{"2":{"22":1}}],["1234567",{"2":{"7":1,"114":1,"115":1,"121":1,"160":1,"170":1}}],["12345678顺序搜索的时间复杂度为",{"2":{"34":1}}],["123456789",{"2":{"29":1,"169":1}}],["1234567891011",{"2":{"119":1}}],["123456789101112代码测试",{"2":{"131":1}}],["123456789101112",{"2":{"78":1,"207":1}}],["12345678910111213",{"2":{"70":1,"71":1,"72":1,"97":1,"98":1,"116":1}}],["1234567891011121314代码测试",{"2":{"133":1}}],["123456789101112131415代码测试",{"2":{"134":1}}],["123456789101112131415时间复杂度",{"2":{"20":1}}],["123456789101112131415使用这种方法时整个的递归过程是一个二叉树的结构",{"2":{"14":1}}],["123456789101112131415",{"2":{"6":1,"17":1,"91":1,"205":1,"206":1}}],["12345678910111213141516哈希函数测试",{"2":{"158":1}}],["1234567891011121314151617",{"2":{"162":1,"204":1}}],["1234567891011121314151617代码测试",{"2":{"135":1}}],["123456789101112131415161718二分搜索的时间的复杂度为",{"2":{"35":1}}],["12345678910111213141516171819冒泡排序有两种优化方式",{"2":{"37":1}}],["1234567891011121314151617181920",{"2":{"31":1,"117":1,"167":1,"216":1}}],["12345678910111213141516171819202122",{"2":{"25":1}}],["1234567891011121314151617181920212223这种表示法的优点在于每一个节点中引用的数量都是确定的",{"2":{"227":1}}],["1234567891011121314151617181920212223第二步",{"2":{"77":1}}],["123456789101112131415161718192021222324希尔排序是利用了插入排序对于已排序序列排序效果最好的特点",{"2":{"40":1}}],["123456789101112131415161718192021222324当排序序列为已排序序列时",{"2":{"39":1}}],["1234567891011121314151617181920212223242526",{"2":{"202":1}}],["123456789101112131415161718192021222324252627",{"2":{"185":1}}],["12345678910111213141516171819202122232425262728",{"2":{"45":1,"79":1,"163":1}}],["1234567891011121314151617181920212223242526272829过程图解",{"2":{"130":1}}],["123456789101112131415161718192021222324252627282930313233",{"2":{"177":1}}],["12345678910111213141516171819202122232425262728293031323334",{"2":{"161":1,"195":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940",{"2":{"201":1,"215":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041",{"2":{"95":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142代码测试",{"2":{"132":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142",{"2":{"81":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142这一种方法是填空法",{"2":{"42":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243归并排序将整个排序序列看成一个二叉树进行分解",{"2":{"41":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748",{"2":{"184":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051",{"2":{"93":1,"94":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101",{"2":{"208":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124",{"2":{"171":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204",{"2":{"140":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190",{"2":{"100":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114",{"2":{"82":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879",{"2":{"176":1}}],["12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364建立堆的时间复杂度为",{"2":{"43":1}}],["1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556基数排序的平均时间复杂度为",{"2":{"44":1}}],["123456789101112131415161718192021222324252627282930313233343536373839404142434445",{"2":{"17":1}}],["123456789101112131415161718192021222324252627282930313233343536373839",{"2":{"101":1,"192":1}}],["1234567891011121314151617181920212223242526272829303132333435",{"2":{"10":1,"76":1}}],["12345678910111213141516171819202122232425262728293031代码测试",{"2":{"136":1}}],["12345678910111213141516171819202122232425262728293031",{"2":{"120":1,"121":1}}],["12345678910111213141516171819202122232425262728293031选择排序不管初始序列是否有序",{"2":{"38":1}}],["1234567891011121314151617181920212223242526272829",{"2":{"9":1}}],["123456789101112131415161718192021222324252627通过这种方式我们可以将算法的时间复杂度降低为",{"2":{"16":1}}],["12345678910111213141516171819202122232425",{"2":{"193":1}}],["12345678910111213141516171819202122232425通过这种方式",{"2":{"15":1}}],["123456789101112131415161718192021222324",{"2":{"11":1}}],["1234567891011121314151617181920212223",{"2":{"2":1}}],["123456789101112131415161718192021",{"2":{"8":1,"68":1,"92":1}}],["12345678910111213141516171819",{"2":{"12":1,"75":1,"218":1}}],["12345678910111213141516",{"2":{"5":1,"32":1,"129":1}}],["1234567891011121314",{"2":{"1":1,"28":1}}],["1234567891011insertnode",{"2":{"68":1}}],["1234567891011时间复杂度",{"2":{"23":1}}],["12345678910",{"2":{"1":1,"48":2,"96":1,"169":1}}],["12345678时间复杂度",{"2":{"21":1}}],["12345678",{"2":{"4":1,"17":1,"26":1,"66":1}}],["1234",{"2":{"50":1,"51":1,"52":2,"132":1,"167":2,"170":1,"196":1}}],["123",{"2":{"3":1,"132":2,"133":2,"134":1,"136":1,"137":1,"158":1,"164":1,"165":1,"202":7,"219":1}}],["1100100",{"2":{"219":1}}],["111111",{"2":{"101":2}}],["11",{"2":{"3":1,"10":1,"62":1,"65":3,"71":1,"72":1,"79":4,"83":1,"177":2}}],["1",{"2":{"1":4,"2":7,"3":1,"6":2,"8":1,"10":2,"11":7,"12":11,"13":1,"14":6,"15":4,"16":5,"17":19,"20":6,"23":4,"24":1,"25":13,"26":5,"29":3,"31":1,"32":2,"34":2,"35":6,"37":8,"38":7,"39":10,"40":10,"41":4,"42":9,"43":11,"44":7,"45":7,"50":2,"51":2,"52":8,"57":6,"62":3,"64":1,"65":1,"68":2,"78":1,"79":12,"80":3,"81":1,"82":13,"89":1,"92":1,"93":1,"94":1,"95":5,"96":1,"100":8,"101":2,"105":12,"108":1,"109":4,"120":2,"121":2,"125":1,"127":1,"130":2,"132":2,"133":2,"134":4,"135":2,"136":2,"140":10,"142":1,"143":3,"148":2,"149":1,"150":1,"151":2,"155":1,"158":1,"161":2,"162":1,"163":1,"166":1,"167":2,"169":6,"170":3,"171":6,"180":1,"195":5,"204":1,"205":1,"206":1,"208":3,"212":9,"215":1,"216":3,"218":1,"224":2,"232":5,"237":2}}],["lucy",{"2":{"196":1}}],["last",{"2":{"210":1}}],["lastindex",{"2":{"37":4}}],["laodfactor",{"2":{"167":2}}],["list",{"2":{"233":1}}],["linked",{"2":{"233":1}}],["linkedlist",{"2":{"91":2,"100":1,"129":2,"130":6,"131":1,"132":3,"133":2,"134":2,"135":4,"136":2,"137":2,"138":1,"139":1,"140":1}}],["lifo",{"2":{"210":1}}],["lily",{"2":{"196":2}}],["limit",{"2":{"158":2,"160":1,"161":3,"162":1,"163":4,"167":6,"170":5,"171":10}}],["lrd",{"2":{"72":1}}],["ldr",{"2":{"71":1}}],["lgn",{"2":{"41":1}}],["l",{"2":{"23":6,"32":3}}],["loadfactor",{"2":{"161":1,"166":2,"167":2,"170":1,"171":2}}],["loop",{"2":{"44":3}}],["low",{"2":{"20":3,"35":4}}],["lower",{"2":{"20":1}}],["logn",{"2":{"14":1,"20":2,"35":1,"41":1,"42":3,"43":1,"46":1}}],["log",{"2":{"1":2,"2":1,"3":2,"4":2,"5":1,"6":1,"8":1,"10":2,"11":4,"12":3,"17":3,"50":1,"51":1,"52":2,"83":5,"101":12,"120":1,"121":1,"130":1,"131":1,"132":1,"133":2,"134":2,"135":2,"136":1,"137":1,"138":1,"139":1,"158":2,"177":5,"185":8,"193":6,"196":1,"202":7,"216":6,"219":2,"237":1}}],["lt",{"2":{"11":1,"65":2,"68":1,"76":1,"167":1}}],["lcm",{"2":{"5":4}}],["level",{"2":{"224":1}}],["leaf",{"2":{"224":1}}],["len",{"2":{"45":2,"163":2,"171":2}}],["length++",{"2":{"92":1,"93":1,"94":1,"100":2,"130":1,"132":1,"140":2}}],["length",{"2":{"2":2,"6":3,"9":1,"10":4,"17":6,"26":3,"29":1,"31":2,"32":3,"34":1,"35":1,"37":2,"38":5,"39":4,"40":5,"41":7,"42":3,"43":8,"44":10,"45":1,"89":1,"93":3,"94":3,"95":5,"100":8,"116":2,"117":1,"119":1,"120":1,"121":2,"127":1,"129":1,"130":1,"132":2,"133":1,"135":1,"136":2,"138":1,"139":1,"140":10,"155":1,"161":1,"163":1,"167":1,"171":2,"176":1,"182":1,"184":1,"191":1,"192":2,"200":1,"201":1,"208":1,"214":1,"215":3}}],["leetcode",{"2":{"20":2,"22":2,"23":2,"25":2,"26":2,"28":2,"29":2,"31":2,"32":2}}],["leftchild",{"2":{"227":3}}],["leftlength",{"2":{"41":3}}],["leftarray",{"2":{"41":5}}],["left",{"2":{"17":10,"21":2,"22":2,"23":3,"38":3,"41":2,"66":2,"68":3,"70":1,"71":1,"72":1,"75":2,"76":2,"77":1,"78":3,"79":14,"81":5,"82":16}}],["let",{"2":{"1":1,"6":2,"7":1,"8":2,"9":2,"10":2,"11":4,"12":2,"15":1,"16":2,"17":4,"25":4,"26":1,"28":1,"29":2,"32":2,"34":1,"35":2,"37":3,"38":4,"39":4,"40":5,"41":3,"42":3,"43":6,"44":11,"45":4,"75":2,"76":1,"77":2,"81":4,"82":7,"93":3,"94":3,"95":3,"97":2,"98":2,"100":10,"116":4,"117":3,"119":2,"120":7,"121":5,"130":1,"131":2,"132":3,"133":2,"134":2,"135":2,"136":3,"140":15,"158":2,"161":3,"163":1,"169":2,"171":4,"176":4,"192":2,"195":1,"204":3,"205":2,"206":2,"207":1,"208":8,"215":2,"218":1}}],["front",{"2":{"176":4,"187":1,"191":1,"192":2,"193":2,"195":1}}],["friday",{"2":{"48":4}}],["full",{"2":{"59":1}}],["function",{"2":{"1":2,"2":2,"5":2,"8":4,"9":1,"10":1,"15":1,"17":2,"20":1,"21":1,"22":1,"23":1,"25":2,"26":1,"28":2,"29":1,"31":1,"32":1,"34":1,"35":1,"38":1,"41":1,"42":1,"43":3,"120":1,"121":1,"195":1}}],["flag",{"2":{"37":3}}],["flattenarray",{"2":{"1":5}}],["floor",{"2":{"17":1,"20":1,"35":1,"163":1,"167":1,"170":1,"171":1,"218":1}}],["f",{"2":{"12":6,"24":3,"25":6,"26":7,"57":1,"62":2,"70":1,"117":2,"120":1,"121":1,"154":1,"226":1,"227":1}}],["fifo",{"2":{"187":1}}],["first",{"2":{"119":2,"187":2,"210":1}}],["findcontentchildren",{"2":{"28":1}}],["findksmallestnumberswithmaxheap",{"2":{"17":2}}],["findksmallestnumbers",{"2":{"17":2}}],["findmostword",{"2":{"9":1}}],["fibonacci",{"2":{"11":5}}],["false",{"2":{"10":3,"22":1,"23":1,"37":1,"67":1,"76":3,"77":3,"79":2,"82":3,"89":1,"93":1,"94":1,"100":1,"127":1,"132":1,"135":1,"138":1,"140":2,"157":1,"169":4,"176":1,"177":1,"182":1,"184":2,"185":1,"191":1,"193":1,"200":1,"201":4,"202":1,"207":2,"208":6,"214":1,"216":1}}],["forwardtostring",{"0":{"97":1},"2":{"97":2,"100":2,"101":2}}],["forwardstring",{"2":{"89":1}}],["for",{"2":{"6":1,"11":1,"12":1,"16":1,"17":3,"25":2,"26":1,"29":1,"32":2,"34":1,"37":1,"38":2,"39":1,"40":2,"43":2,"44":6,"45":3,"116":2,"117":1,"119":1,"120":1,"121":2,"158":1,"161":1,"162":1,"163":1,"167":2,"169":2,"171":5,"176":2,"192":1,"195":2,"204":2,"205":1,"206":1,"207":1,"208":5,"215":1}}],["foreach",{"2":{"2":1,"9":1,"28":1,"31":1}}],["==",{"2":{"43":1,"75":2,"76":1,"77":1,"78":1,"79":7,"81":2,"82":3,"93":2,"94":2,"100":2,"130":1,"140":1}}],["===",{"2":{"2":1,"4":1,"5":1,"6":1,"7":1,"10":1,"11":2,"12":2,"14":2,"15":2,"16":2,"17":4,"20":2,"22":1,"23":1,"26":1,"31":1,"32":1,"34":1,"68":3,"70":1,"71":1,"72":1,"76":1,"77":1,"78":3,"79":4,"81":1,"82":9,"92":1,"93":3,"94":3,"95":3,"100":7,"120":1,"121":2,"130":1,"132":1,"134":1,"136":1,"138":1,"140":5,"161":2,"162":2,"163":2,"164":1,"169":3,"171":7,"192":1,"215":1}}],["=>",{"2":{"1":2,"2":1,"15":1,"16":1,"17":3,"20":1,"23":1,"28":1,"31":2,"32":1}}],["=",{"2":{"1":2,"2":3,"3":1,"5":1,"6":2,"7":3,"8":5,"9":10,"10":4,"11":9,"12":7,"15":2,"16":8,"17":22,"20":4,"21":1,"22":1,"23":2,"24":1,"25":15,"26":9,"28":4,"29":3,"31":3,"32":6,"34":2,"35":8,"37":8,"38":9,"39":7,"40":10,"41":10,"42":7,"43":15,"44":17,"45":11,"48":2,"50":1,"51":1,"52":2,"57":4,"65":1,"66":3,"68":6,"70":1,"71":1,"72":1,"75":4,"76":3,"77":8,"78":8,"79":13,"81":13,"82":30,"91":2,"92":6,"93":18,"94":18,"95":14,"96":1,"97":3,"98":3,"100":46,"101":1,"112":2,"116":4,"117":3,"119":3,"120":10,"121":8,"129":5,"130":7,"131":3,"132":14,"133":3,"134":3,"135":4,"136":8,"140":45,"143":4,"150":2,"151":1,"155":1,"158":4,"160":3,"161":7,"162":2,"163":5,"167":6,"169":5,"170":3,"171":23,"176":7,"177":1,"184":3,"185":1,"192":2,"193":1,"195":3,"196":2,"201":3,"202":1,"204":1,"205":1,"206":1,"208":6,"215":2,"218":3,"223":1,"227":9}}],["i>=0",{"2":{"45":1}}],["i+1",{"2":{"45":2}}],["i++",{"2":{"6":1,"11":1,"12":1,"16":1,"17":3,"25":2,"26":1,"28":1,"29":1,"32":2,"34":1,"38":1,"39":1,"40":1,"44":4,"45":2,"116":1,"117":1,"119":1,"120":1,"121":2,"161":1,"163":1,"169":2,"171":2,"176":1,"195":1}}],["i=len",{"2":{"45":1}}],["i=min",{"2":{"45":1}}],["i=0",{"2":{"45":1}}],["iparent",{"2":{"43":2}}],["imax",{"2":{"43":9}}],["iright",{"2":{"43":5}}],["ir++",{"2":{"41":2}}],["ir",{"2":{"41":4}}],["ileft",{"2":{"43":5}}],["il++",{"2":{"41":2}}],["il",{"2":{"41":4}}],["ii",{"2":{"29":1}}],["intersectionset",{"2":{"205":3,"208":3}}],["intersection",{"2":{"205":2,"208":2}}],["in",{"2":{"187":1,"210":1}}],["initializecolor",{"2":{"119":1,"120":1,"121":1}}],["inordertraversalnode",{"2":{"71":4}}],["inordertraversal",{"2":{"71":1}}],["inordertraverse",{"2":{"67":1}}],["insertnode",{"2":{"68":9}}],["insert",{"0":{"93":1,"94":1,"132":1},"2":{"67":1,"68":3,"89":1,"93":3,"94":3,"96":1,"100":4,"101":3,"127":1,"132":5,"140":2}}],["insertsort",{"2":{"39":2}}],["index+1",{"2":{"148":1}}],["index++",{"2":{"132":1,"133":1,"134":1,"135":1,"136":1,"140":5}}],["index=4",{"2":{"148":1}}],["index=3",{"2":{"148":3}}],["index",{"2":{"42":3,"43":7,"50":1,"52":2,"132":2,"133":1,"134":3,"135":1,"136":1,"140":8,"148":1,"155":1,"161":6,"162":3,"163":3,"166":1,"171":9}}],["indexof",{"0":{"6":1,"134":1},"2":{"2":1,"6":2,"9":1,"33":1,"89":1,"100":3,"101":2,"127":1,"134":4,"137":1,"140":3,"195":1}}],["includes",{"2":{"31":1}}],["inverttree",{"2":{"21":3}}],["invalid",{"2":{"11":1}}],["input",{"2":{"11":1}}],["isprime",{"2":{"169":2,"170":3,"171":1}}],["ispalindrome",{"2":{"7":1}}],["isempty",{"0":{"138":1,"164":1},"2":{"89":1,"100":3,"120":1,"127":1,"138":3,"140":2,"157":1,"171":1,"176":5,"177":2,"191":1,"192":2,"193":2,"214":1,"215":2,"216":2,"218":1}}],["isleftchild",{"2":{"77":5,"78":1,"79":6,"81":1,"82":8}}],["ismirror",{"2":{"23":4}}],["issymmetric",{"2":{"23":1}}],["issametree",{"2":{"22":3}}],["isarray",{"2":{"1":2,"2":2,"6":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1}}],["i",{"2":{"6":4,"11":2,"12":5,"16":2,"17":13,"25":7,"26":6,"28":7,"29":8,"32":7,"34":4,"38":5,"39":4,"40":4,"43":12,"44":16,"45":16,"57":4,"62":1,"70":1,"116":4,"117":5,"119":3,"120":4,"121":8,"161":3,"163":4,"169":6,"171":7,"176":4,"185":4,"195":2,"224":1}}],["items",{"2":{"176":6,"177":2,"184":8,"185":1,"192":7,"193":2,"201":7,"202":2,"208":7,"215":8,"216":1}}],["item",{"2":{"1":5,"2":3,"8":4,"9":4,"34":2,"35":3,"50":3,"52":2,"88":1,"158":2,"176":3,"192":5,"215":5}}],["if",{"2":{"1":1,"2":3,"4":1,"5":1,"6":2,"9":3,"10":3,"11":3,"12":3,"14":3,"15":4,"16":3,"17":7,"20":3,"21":1,"22":2,"23":3,"25":2,"26":1,"28":1,"29":1,"31":2,"32":1,"34":1,"35":2,"37":3,"38":2,"39":1,"40":1,"41":2,"42":1,"43":4,"44":3,"68":4,"70":1,"71":1,"72":1,"75":2,"76":5,"77":2,"78":3,"79":6,"81":3,"82":14,"92":1,"93":4,"94":4,"95":4,"100":9,"120":2,"121":3,"130":1,"132":2,"133":1,"134":1,"135":1,"136":2,"140":8,"161":3,"162":2,"163":3,"167":3,"169":4,"170":2,"171":9,"176":3,"184":1,"201":2,"205":1,"206":1,"207":1,"208":5}}],["兼容性好",{"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
